{"meta":{"title":"JUST WRITE IT.","subtitle":"","description":"","author":"Geum Doyun","url":"https://doyuni.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-01-20T12:25:32.000Z","updated":"2020-01-25T04:38:20.526Z","comments":true,"path":"tags/index.html","permalink":"https://doyuni.github.io/tags/index.html","excerpt":"","text":"CI/CD Docker Jenkins NAVER CLOUD NGINX Algorithm"},{"title":"categories","date":"2020-01-20T12:25:42.000Z","updated":"2020-01-25T04:38:20.521Z","comments":true,"path":"categories/index.html","permalink":"https://doyuni.github.io/categories/index.html","excerpt":"","text":"DevOps CI/CD Algorithm BOJ Programmers SWEA"}],"posts":[{"title":"백준 17472번 다리 만들기 2","slug":"Algorithm/BOJ/17472","date":"2020-01-25T08:05:32.000Z","updated":"2020-01-25T13:35:31.290Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17472/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17472/","excerpt":"","text":"#17472. 다리 만들기 2Problem 문제링크 Solution 각 섬에 고유 번호 붙이기(오름차순)섬끼리 연결을 해야하기 때문에 이를 식별해주어야 한다.BFS or DFS를 이용하여 구할 수 있고 필자는 BFS를 사용하였다. 각 섬들마다 연결시키는 모든 경우를 구하되, 각 경우마다 연결이 가능한지 거리를 측정하면서 확인한다.→ 연결이 가능하면 해당 다리를 저장한다.(어디에서 어디로 연결되고 그럴 때 최소 비용 저장) 다리를 선택해서 1개 이상 선택했을 때부터 모든 섬을 연결 시킬 수 있는지 확인한다.→ 모든 섬을 연결할 수 있으면 최소비용 갱신 Answer 완탐 코드 보기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int N, M, total_island, ans = 1e9;int map[10][10];bool visited[10][10]; // 섬에 번호 붙일 때 방문 체크 용도int dist[7][7]; // dist[a][b]: a에서 b로 가는 경로 비용, 기본값 1000int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;vector&lt;pair&lt;int, int&gt;&gt; Island_pos[11]; // Island_pos[i]: i번 섬의 모든 좌표vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; bridge_list; // a, b, c : a-&gt;b의 비용이 c인 다리 목록bool connect[7][7]; // a, b와의 연결 상태 확인 용도bool connect_island[7]; // i번 섬의 방문 체크 용도bool selected[7 * 7]; // 간선의 모든 경우를 담기 위함( N(N-1)/2 )void BFS(int x, int y, int id) &#123; // 섬에 번호 붙이기 queue&lt;pair&lt;int, int&gt; &gt; q; q.push(&#123; x, y &#125;); visited[x][y] = true; map[x][y] = id; Island_pos[id].push_back(&#123; x, y &#125;); while (!q.empty()) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; N &amp;&amp; d_y &lt; M) &#123; if (visited[d_x][d_y] || map[d_x][d_y] != 1) continue; visited[d_x][d_y] = true; map[d_x][d_y] = id; Island_pos[id].push_back(&#123; d_x, d_y &#125;); q.push(&#123; d_x, d_y &#125;); &#125; &#125; &#125;&#125;void Go(int x, int y, int dir, int len, int start, int end) &#123; // 거리 측정하기 int nx = x + dx[dir]; int ny = y + dy[dir]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= M) return; if (map[nx][ny] == end) &#123; if (len &gt; 1) &#123; // 거리 2이상인 경우만 연결 가능 if (dist[start][end] &gt; len) &#123; // 최소 거리 갱신 dist[start][end] = len; dist[end][start] = len; &#125; &#125; return; &#125; else if (map[nx][ny] == 0) Go(nx, ny, dir, len + 1, start, end); else return;&#125;void MakeBridge(int start, int end) &#123; //Start에 해당되는 섬의 모든 좌표를 end에 해당되는 섬까지 도달해본다. for (int i = 0; i &lt; Island_pos[start].size(); i++) &#123; int x = Island_pos[start][i].first; int y = Island_pos[start][i].second; for (int dir = 0; dir &lt; 4; ++dir) &#123; int nx = x + dx[dir]; int ny = y + dy[dir]; if (nx &gt; -1 &amp;&amp; ny &gt; -1 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M) &#123; if (map[nx][ny] == 0) Go(nx, ny, dir, 1, start, end); // 한 방향으로 가야함, 0인 지점 방문이니 거리 1 &#125; &#125; &#125;&#125;void GetDistance() &#123; // 섬들끼리 1:1로 연결시키는 모든 경우 for (int i = 1; i &lt; total_island; i++) &#123; for (int j = i + 1; j &lt; total_island; j++) &#123; MakeBridge(i, j); if (dist[i][j] == 1000) continue; // 연결 불가능한 경우 bridge_list.push_back(&#123; &#123;i, j&#125;, dist[i][j] &#125;); // (i -&gt; j : 비용) 저장 &#125; &#125;&#125;bool CheckConnect() &#123; // 조건에 맞게 모든 섬이 연결되어있는지 확인 memset(connect, false, sizeof(connect)); memset(connect_island, false, sizeof(connect_island)); for (int i = 0; i &lt; bridge_list.size(); i++) // 선택한 다리 연결 표시 &#123; if (selected[i]) &#123; // 연결 표시 (x-&gt;y, y-&gt;x) int x = bridge_list[i].first.first; int y = bridge_list[i].first.second; connect[x][y] = connect[y][x] = true; &#125; &#125; queue&lt;int&gt; q; q.push(1); // 1번 섬(섬은 최소 2개) connect_island[1] = true; // 1번 섬 방문 체크 int Island_cnt = 1; bool flag = false; while (!q.empty()) &#123; // 모든 섬 방문가능한지 체크하는 부분 int cur = q.front(); q.pop(); if (Island_cnt == total_island - 1) &#123; flag = true; break; &#125; for (int i = 1; i &lt; total_island; i++) &#123; if (cur == i) continue; if (connect[cur][i] &amp;&amp; connect_island[i] == false) &#123; // 현재 섬과 i번 섬이 연결되어있고 i번 섬을 방문하지 않았을 때 connect_island[i] = true; q.push(i); Island_cnt++; &#125; &#125; &#125; return flag;&#125;void SelectBridge(int idx, int cnt, int sum) &#123; if (cnt &gt;= 1) &#123; if (CheckConnect() == true) &#123; if (ans &gt; sum) ans = sum; &#125; &#125; for (int i = idx; i &lt; bridge_list.size(); ++i) &#123; if (selected[i] == true) continue; selected[i] = true; SelectBridge(i, cnt + 1, sum + bridge_list[i].second); selected[i] = false; &#125;&#125;int main() &#123; for (int i = 0; i &lt; 7; ++i) &#123; for (int j = 0; j &lt; 7; j++) &#123; dist[i][j] = 1000; &#125; &#125; cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; int id = 1; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; if (map[i][j] != 0 &amp;&amp; !visited[i][j]) BFS(i, j, id++); &#125; &#125; total_island = id; GetDistance(); SelectBridge(0, 0, 0); if (ans == 1e9) ans = -1; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; Solution 위 방식에서 1, 2까지는 동일 크루스칼 알고리즘을 사용한다. Answer 코드 보기123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; d;struct Bridge &#123; int from; int to; int len;&#125;;int N, M, total, ans = 10000;int map[10][10];bool visited[10][10];int parent[7];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;vector&lt;d&gt; island[7];vector&lt;Bridge&gt; bridge;int Go(int from, int to) &#123; int len = 10000; for (int i = 0; i &lt; island[from].size(); i++)&#123; int x = island[from][i].first; int y = island[from][i].second; for (int dir = 0; dir &lt; 4; ++dir) &#123; int nx = x; int ny = y; int cur = 0; while (true) &#123; if (len &lt;= cur) break; nx += dx[dir]; ny += dy[dir]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= M) break; if (map[nx][ny] == 0) &#123; cur++; &#125; else if (map[nx][ny] == to) &#123; if (cur &lt; 2) break; if (len &gt; cur) len = cur; break; &#125; else break; &#125; &#125; &#125; return len;&#125;void GetDistance() &#123; Bridge b; for (int i = 1; i &lt;= total; ++i) &#123; for (int j = i + 1; j &lt;= total; ++j) &#123; b.from = i; b.to = j; b.len = Go(i, j); if (b.len == 10000) continue; bridge.push_back(b); &#125; &#125;&#125;void BFS(int r, int c, int id) &#123; queue&lt;d&gt; q; q.push(&#123; r, c &#125;); visited[r][c] = true; map[r][c] = id; island[id].push_back(&#123; r, c &#125;); while (!q.empty()) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int nx = x + dx[dir]; int ny = y + dy[dir]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= M) continue; if (map[nx][ny] != 1 || visited[nx][ny]) continue; visited[nx][ny] = true; map[nx][ny] = id; island[id].push_back(&#123; nx, ny &#125;); q.push(&#123; nx, ny &#125;); &#125; &#125;&#125;void MakeLabel() &#123; int id = 1; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; if (map[i][j] == 0 || visited[i][j]) continue; BFS(i, j, id++); &#125; &#125; total = id - 1; for (int i = 1; i &lt;= total; ++i) &#123; parent[i] = i; &#125;&#125;int cmp(Bridge a, Bridge b) &#123; return a.len &lt; b.len;&#125;int FindParent(int idx) &#123; if (parent[idx] == idx) return idx; else return FindParent(parent[idx]);&#125;void Union(int from, int to) &#123; int p1 = FindParent(parent[from]); int p2 = FindParent(parent[to]); if (p1 &lt; p2) &#123; parent[to] = p1; parent[p2] = p1; &#125; else &#123; parent[from] = p2; parent[p1] = p2; &#125;&#125;bool CheckConnection() &#123; for (int i = 1; i &lt;= total; ++i) &#123; if (FindParent(parent[i]) != 1) return false; &#125; return true;&#125;void Kruskal() &#123; sort(bridge.begin(), bridge.end(), cmp); int cost = 0; for (int i = 0; i &lt; bridge.size(); ++i) &#123; int from = bridge[i].from; int to = bridge[i].to; if(FindParent(from) == FindParent(to)) continue; else &#123; Union(from, to); cost += bridge[i].len; &#125; &#125; if (CheckConnection()) ans = cost;&#125;void Solve() &#123; MakeLabel(); GetDistance(); Kruskal();&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; Solve(); if (ans == 10000) ans = -1; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 17471번 게리맨더링","slug":"Algorithm/BOJ/17471","date":"2020-01-25T08:05:30.000Z","updated":"2020-01-25T13:35:31.291Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17471/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17471/","excerpt":"","text":"#17471. 게리맨더링Problem 문제링크 Solution city[n][j] = n번째 구역과 인접한구역 j는 1로 표시, 아니면 0으로 표시 한 지역의 구역을 정한다. (중복x, 오름차순으로) - (1,2,3) 과 (2,1,3)은 같은 조합이기에 정한 구역이 이어져 있는지 DFS를 통해 확인한다. 방문표시 전체 구역 탐색하여 해당 지역에 속하고 인접할 때, 해당 구역 탐색 DFS 시작 지점은 해당 지역에서 한 구역으로 지정한다. (그래야 모두 인접해있는지 확인 가능) 2개의 지역 모두 DFS 탐색 후에 check 표시가 모두 되어있지 않으면 return한다. 규칙에 맞게 구역이 나누어져 있지 않다는 뜻이기 때문이다. 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int N, ans = 1e9;bool selected[11];int people[11];int city[11][11];bool check[11];void getDifference() &#123; int a_sum = 0, b_sum = 0; for (int i = 1; i &lt;= N; ++i) &#123; if (selected[i]) a_sum += people[i]; else b_sum += people[i]; &#125; int res = abs(a_sum - b_sum); if (res &lt; ans) ans = res;&#125;void DFS(int n, int status) &#123; check[n] = true; for (int i = 1; i &lt;= N; ++i) &#123; if (check[i]) continue; if (status == 1) &#123; if (selected[i] &amp;&amp; city[n][i]) &#123; check[i] = true; DFS(i, status); &#125; &#125; else &#123; if (!selected[i] &amp;&amp; city[n][i]) &#123; check[i] = true; DFS(i, status); &#125; &#125; &#125;&#125;void Solve() &#123; memset(check, 0, sizeof(check)); for (int i = 1; i &lt;= N; ++i) &#123; if (selected[i]) &#123; DFS(i, 1); break; &#125; &#125; for (int i = 1; i &lt;= N; ++i) &#123; if (!selected[i]) &#123; DFS(i, 0); break; &#125; &#125; for (int i = 1; i &lt;= N; ++i) &#123; if (!check[i]) return; &#125; getDifference();&#125;void SelectArea(int n, int cnt) &#123; if (cnt &gt;= N) return; if (cnt &gt;= 1) &#123; Solve(); &#125; for (int i = n; i &lt;= N; ++i) &#123; if (selected[i]) continue; selected[i] = true; SelectArea(i, cnt + 1); selected[i] = false; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 1; i &lt;= N; ++i) &#123; cin &gt;&gt; people[i]; &#125; for (int i = 1; i &lt;= N; ++i) &#123; int cnt; cin &gt;&gt; cnt; for (int j = 0; j &lt; cnt; ++j) &#123; int n; cin &gt;&gt; n; city[i][n] = 1; &#125; &#125; SelectArea(1, 0); if (ans == 1e9) ans = -1; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 17406번 배열 돌리기 4","slug":"Algorithm/BOJ/17406","date":"2020-01-25T08:05:23.000Z","updated":"2020-01-25T13:35:31.288Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17406/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17406/","excerpt":"","text":"#17406. 배열 돌리기 4Problem 문제링크 Solution 회전 연산 순서를 정한다. (0, 1, 2) 와 (1, 0, 2)는 다른 순서이다! 가장 바깥쪽 부터 시계방향으로 각 원소들을 회전시킨다.가장 바깥쪽 크기는 2*s+1이다. 시작 지점부터 시작해서 +1씩, 크기는 -2씩 변경하며 회전시킨다. 중앙 지점으 만나면 더이상 회전시킬 수 없으므로 종료한다. 회전은 아래와 같은 방법으로 진행한다. “미세먼지 안녕!” 문제에서 설명한 배열 회전 방법과 동일하다.여기선 시계방향이므로 2번째 그림이 이에 해당한다. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;using namespace std;int N, M, K, ans = 1e9;int arr[50][50];int copy_arr[50][50];int order[6];bool selected[6];struct Inst &#123; int r, c, s;&#125;ins[6];void CopyArray() &#123; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; copy_arr[i][j] = arr[i][j]; &#125; &#125;&#125;int getSum() &#123; int res = 1e9; for (int i = 0; i &lt; N; ++i) &#123; int sum = 0; for (int j = 0; j &lt; M; ++j) &#123; sum += copy_arr[i][j]; &#125; if (res &gt; sum) res = sum; &#125; return res;&#125;void Rotate() &#123; CopyArray(); for (int i = 0; i &lt; K; ++i) &#123; int len = ins[order[i]].s * 2 + 1; // 가장 바깥쪽 크기 int mid_r = ins[order[i]].r; // 중심 좌표 int mid_c = ins[order[i]].c; int start_r = ins[order[i]].r - ins[order[i]].s; // 시작 좌표 int start_c = ins[order[i]].c - ins[order[i]].s; while (true) &#123; if (mid_r == start_r &amp;&amp; mid_c == start_c) break; // 중심점이면 종료 int temp = copy_arr[start_r][start_c]; // 시작지점 값만 빼놓기 int end_r = start_r + len - 1; // 끝 행 int end_c = start_c + len - 1; // 끝 열 for (int r = start_r; r &lt; start_r + len - 1; ++r) &#123; // (1) copy_arr[r][start_c] = copy_arr[r + 1][start_c]; &#125; for (int c = start_c; c &lt; start_c + len - 1; ++c) &#123; // (2) copy_arr[end_r][c] = copy_arr[end_r][c + 1]; &#125; for (int r = end_r; r &gt; start_r; --r) &#123; // (3) copy_arr[r][end_c] = copy_arr[r - 1][end_c]; &#125; for (int c = end_c; c &gt; start_c + 1; --c) &#123; // (4) copy_arr[start_r][c] = copy_arr[start_r][c - 1]; &#125; copy_arr[start_r][start_c + 1] = temp; // 빼놓은 값 넣기 start_r++; start_c++; len -= 2; // 시작지점 및 길이 갱신 &#125; &#125; int res = getSum(); if (ans &gt; res) ans = res;&#125;void SelectOrder(int cnt) &#123; if (cnt == K) &#123; Rotate(); return; &#125; for (int i = 0; i &lt; K; ++i) &#123; if (selected[i]) continue; order[cnt] = i; selected[i] = true; SelectOrder(cnt + 1); selected[i] = false; &#125;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; cin &gt;&gt; arr[i][j]; &#125; &#125; for (int i = 0; i &lt; K; ++i) &#123; int r, c, s; cin &gt;&gt; r &gt;&gt; c &gt;&gt; s; ins[i] = &#123; r-1, c-1, s &#125;; &#125; SelectOrder(0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 17298번 오큰수","slug":"Algorithm/BOJ/17298","date":"2020-01-25T08:04:55.000Z","updated":"2020-01-25T13:33:14.417Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17298/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17298/","excerpt":"","text":"#17298. 오큰수문제링크 Problem 길이가 N인 수열 Goal: 각 원소에 대해 자신보다 오른쪽에 있으면서 크고 가장 왼쪽에 위치한 수를 구하여라없다면 -1 출력 Solution Stack을 사용한다. 단계는 문제에 예시로 있는 입력 값으로 설명을 하겠다. 오른쪽 순서로 단계가 진행된다. 원소의 최댓값은 최대 1000000(백만)이기에 +1값을 MAX로 주었다. 수열의 맨 오른쪽부터 진행한다. 사이클 비교 대상인 입력값과 스텍에 있는 값을 비교하여 스텍에 있는 값이 클 때까지 작업(비교)을 수행한다. 만약 MAX가 스텍의 top이라면 이미 자신보다 큰 수가 없다는 뜻이기에 -1를 출력값에 넣어준다. 그게 아니라면 스텍의 top은 항상 현재 입력값보다 크면서 가장 오른쪽에 있는 수이다. 그렇기에 top을 출력값에 넣어준다. 1 Try123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;vector&gt;#define MAX 1000001using namespace std;stack&lt;int&gt; a, ans, num;int main() &#123; int n, input; scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf(\"%d\", &amp;input); num.push(input); &#125; a.push(MAX); while(!num.empty()) &#123; while(a.top() &lt;= num.top()) a.pop(); // 같을 때도 pop을 해주어야 다음 큰 값을 비교가능 if(a.top() == MAX) ans.push(-1); else ans.push(a.top()); a.push(num.top()); num.pop(); &#125; while(!ans.empty()) &#123; printf(\"%d \", ans.top()); ans.pop(); &#125; printf(\"\\n\"); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 17281번 ⚾(야구공)","slug":"Algorithm/BOJ/17281","date":"2020-01-25T08:04:49.000Z","updated":"2020-01-25T13:30:54.806Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17281/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17281/","excerpt":"","text":"#17281. ⚾Problem 문제링크 Solution시뮬레이션 문제이다. 문제의 설명에 맞게 잘 구현하면 큰 어려움은 없는 문제 타자의 순번을 정한다. (1번 선수는 4번 타자로 고정) → (1, 2, 3)과 (2, 1, 3)은 다른 순서임 1이닝부터 N이닝까지 경기를 진행한다. 각 이닝별 진행 흐름 이전 순번 바로 다음부터 순번이 진행된다. (첫 이닝은 1번부터(인덱스상 0)) 아웃이 3번이 될 때까지 진행한다. 1루, 2루, 3루에 선수가 있는지 표시하는 is_there 변수를 사용하여 진행한다. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;using namespace std;int N, ans;int info[50][9]; // 각 이닝별 타자 정보int order[9]; // 타자 순번bool selected[9];void Game() &#123; int idx = 0, score = 0; // 순번 인덱스, 현재 점수 for(int inning = 0; inning &lt; N; ++inning) &#123; bool is_there[3] = &#123; false, false, false &#125;; // 1, 2, 3루 int out = 0; while (true) &#123; if (info[inning][order[idx]] == 0) &#123; // 아웃 out++; &#125; else if (info[inning][order[idx]] == 1) &#123; // 1루타 if (is_there[2]) &#123; // 3루타 -&gt; 홈 score++; is_there[2] = false; &#125; for (int i = 1; i != -1; --i) &#123; // 각각 1 전진 if (is_there[i]) &#123; is_there[i + 1] = true; is_there[i] = false; &#125; &#125; is_there[0] = true; // 1루 전진 &#125; else if (info[inning][order[idx]] == 2) &#123; // 2루타 for (int i = 1; i &lt; 3; ++i) &#123; // 2루, 3루 -&gt; 홈 if (is_there[i]) &#123; score++; is_there[i] = false; &#125; &#125; if (is_there[0]) &#123; // 1루 -&gt; 3루 is_there[2] = true; is_there[0] = false; &#125; is_there[1] = true; // 2루 전진 &#125; else if (info[inning][order[idx]] == 3) &#123; // 3루타 for (int i = 0; i &lt; 3; ++i) &#123; // 1, 2, 3루 -&gt; 홈 if (is_there[i]) &#123; score++; is_there[i] = false; &#125; &#125; is_there[2] = true; // 3루 전진 &#125; else &#123; // 홈런 for (int i = 0; i &lt; 3; ++i) &#123; if (is_there[i]) &#123; score++; is_there[i] = false; &#125; &#125; score++; &#125; idx = (idx + 1) % 9; // 다음 순번 if (out == 3) break; // 3진 아웃 &#125; &#125; if (ans &lt; score) ans = score;&#125;void SelectOrder(int cnt) &#123; if (cnt == 9) &#123; Game(); return; &#125; if (cnt == 3) cnt++; for (int i = 1; i &lt; 9; ++i) &#123; if (selected[i]) continue; selected[i] = true; order[cnt] = i; SelectOrder(cnt + 1); selected[i] = false; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; 9; ++j) &#123; cin &gt;&gt; info[i][j]; &#125; &#125; selected[0] = true; order[3] = 0; // 1번 선수 4번째 고정 SelectOrder(0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 17144번 미세먼지 안녕!","slug":"Algorithm/BOJ/17144","date":"2020-01-25T08:04:44.000Z","updated":"2020-01-25T13:42:17.182Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17144/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17144/","excerpt":"","text":"#17144. 미세먼지 안녕!문제링크 Problem 공기청정기 항상 왼쪽 열 (두 행 차지) 그외 미세먼지나 빈 칸이 존재 1초 동안 일어나는 일 미세먼지 확산4방향(상하좌우)공기청정기나 경계를 벗어나는 칸은 확산이 일어나지 않음미세먼지 양/5 만큼 확산된다. (각 방향에 대해 한 칸)확산된 후 남은 미세먼지 양은현재 미세먼지 양 - 현재 미세먼지 양/5 * 확산된 방향 개수 공기청정기 작동 (바람)위쪽 → 반시계방향 순환아래쪽 → 시계방향 순환미세먼지가 바람의 방향대로 한 칸씩 이동미세먼지가 공기청정기로 들어가면 모두 정화 Goal: T초가 지난 후 남아있는 미세먼지의 양 Solution1초가 지날 때마다 다음과 같은 작업이 수행된다. 미세먼지 확산 바람으로 인한 이동 미세먼지 확산 5 이상인 값만 확산이 일어난다.확산이 일어나기 전에 queue에 이 값과 이 값이 있는 위치를 저장해놓는다.(값을 저장해야 올바른 값을 구할 수 있음)queue에서 하나씩 꺼내어 4가지 방향을 확인한다.(공기청정기 있는 곳과 경계를 넘는 곳은 불가능)1234567891011121314151617void spread() &#123; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().r; int c = q.front().c; int mid = q.front().value; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; map[x][y] != -1) &#123; map[x][y] += mid / 5; map[r][c] -= mid / 5; &#125; &#125; &#125;&#125;확산이 가능하다면 연산을 수행한다. 바람으로 인한 이동 아래 순서대로 map을 바꿔준다. 공기청정기로 들어간다는 것은 굳이 값을 바꿔줄 필요 없이 전의 값이 이를 덮어주기만 하면 된다. (1번째) → 아래 2번 화살표가 잘못되었습니다….(반대입니다)공기청정기에서 나아가는 바람으로(4번째) 값을 0으로 채워주어야 한다.1234567891011121314151617181920212223242526272829303132void wind() &#123; int i, j, clean_row = clean[0];// 위쪽 for (i = clean_row - 2; i &gt;= 0; --i) &#123; map[i + 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[0][j - 1] = map[0][j]; &#125; for (i = 1; i &lt;= clean_row; ++i) &#123; map[i - 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 1; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125;// 아래쪽 map[clean_row][1] = 0; clean_row = clean[1]; for (i = clean_row + 2; i &lt; total_row; ++i) &#123; map[i - 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[total_row - 1][j - 1] = map[total_row - 1][j]; &#125; for (i = total_row - 2; i &gt;= clean_row; --i) &#123; map[i + 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 2; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0;&#125; 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;queue&gt;#define MAX 50using namespace std;int total_row, total_col, time;int map[MAX][MAX];int clean[2]; struct info &#123; int r, c, value;&#125;;queue&lt;info&gt; q;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; total_row &amp;&amp; c &lt; total_col) return true; return false;&#125;void spread() &#123; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().r; int c = q.front().c; int mid = q.front().value; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; map[x][y] != -1) &#123; map[x][y] += mid / 5; map[r][c] -= mid / 5; &#125; &#125; &#125;&#125;void wind() &#123; int i, j, clean_row = clean[0]; for (i = clean_row - 2; i &gt;= 0; --i) &#123; map[i + 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[0][j - 1] = map[0][j]; &#125; for (i = 1; i &lt;= clean_row; ++i) &#123; map[i - 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 1; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0; clean_row = clean[1]; for (i = clean_row + 2; i &lt; total_row; ++i) &#123; map[i - 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[total_row - 1][j - 1] = map[total_row - 1][j]; &#125; for (i = total_row - 2; i &gt;= clean_row; --i) &#123; map[i + 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 2; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0;&#125;int main() &#123; int answer, idx = 0; scanf(\"%d %d %d\", &amp;total_row, &amp;total_col, &amp;time); for (int i = 0; i &lt; total_row; ++i) &#123; for (int j = 0; j &lt; total_col; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); if (map[i][j] &gt;= 5) q.push(&#123; i, j, map[i][j] &#125;); &#125; if (map[i][0] == -1) clean[idx++] = i; &#125; while (time--) &#123; answer = 0; spread(); wind(); for (int i = 0; i &lt; total_row; ++i) &#123; for (int j = 0; j &lt; total_col; ++j) &#123; if (map[i][j] &gt; 0) answer += map[i][j]; if (map[i][j] &gt;= 5) q.push(&#123; i, j, map[i][j] &#125;); &#125; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; 테스트 케이스는 다 맞다는데 틀렸단다…ㅎ 그 이유는 MAX를 50이기 때문이다. (응? 뭔 🙄🤔…다음부터 넉넉히 잡자..)MAX 51로 고쳐주니까 바로 정답 처리 되었다. 2 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;queue&gt;#define MAX 51using namespace std;int total_row, total_col, time;int map[MAX][MAX];int clean[2];struct info &#123; int r, c, value;&#125;;queue&lt;info&gt; q;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; total_row &amp;&amp; c &lt; total_col) return true; return false;&#125;void spread() &#123; while(!q.empty()) &#123; int r = q.front().r; int c = q.front().c; int mid = q.front().value; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; map[x][y] != -1) &#123; map[x][y] += mid / 5; map[r][c] -= mid / 5; &#125; &#125; &#125;&#125;void wind() &#123; int i, j, clean_row = clean[0]; for (i = clean_row - 2; i &gt;= 0; --i) &#123; map[i + 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[0][j - 1] = map[0][j]; &#125; for (i = 1; i &lt;= clean_row; ++i) &#123; map[i - 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 1; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0; clean_row = clean[1]; for (i = clean_row + 2; i &lt; total_row; ++i) &#123; map[i - 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[total_row - 1][j - 1] = map[total_row - 1][j]; &#125; for (i = total_row - 2; i &gt;= clean_row; --i) &#123; map[i + 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 2; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0;&#125;int main() &#123; int answer, idx = 0; scanf(\"%d %d %d\", &amp;total_row, &amp;total_col, &amp;time); for (int i = 0; i &lt; total_row; ++i) &#123; for (int j = 0; j &lt; total_col; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); if (map[i][j] &gt;= 5) q.push(&#123; i, j, map[i][j] &#125;); &#125; if (map[i][0] == -1) clean[idx++] = i; &#125; while (time--) &#123; answer = 0; spread(); wind(); for (int i = 0; i &lt; total_row; ++i) &#123; for (int j = 0; j &lt; total_col; ++j) &#123; if (map[i][j] &gt; 0) answer += map[i][j]; if (map[i][j] &gt;= 5) q.push(&#123; i, j, map[i][j] &#125;); &#125; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; Debug 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;#include &lt;queue&gt;#define MAX 50using namespace std;int total_row, total_col, time;int map[MAX][MAX];int clean[2]; // 공기청정기 위치(무조건 0열)struct info &#123; int r, c, value;&#125;;queue&lt;info&gt; q;// 상하좌우int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; total_row &amp;&amp; c &lt; total_col) return true; return false;&#125;// 1. 미세먼지 확산void spread() &#123; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().r; int c = q.front().c; int mid = q.front().value; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; map[x][y] != -1) &#123; map[x][y] += mid / 5; map[r][c] -= mid / 5; &#125; &#125; &#125;&#125;// 2. 바람으로 미세먼지 이동void wind() &#123; // 위쪽 ( 반시계 작업은 거꾸로 수행, 그래야 편함) int i, j, clean_row = clean[0]; for (i = clean_row - 2; i &gt;= 0; --i) &#123; // 공기청정기에 들어가면 사라지니까 바로 이전건 그냥 덮어쓰면 됨 map[i + 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[0][j - 1] = map[0][j]; &#125; for (i = 1; i &lt;= clean_row; ++i) &#123; map[i - 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 1; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0; // 아래쪽 ( 시계 ) clean_row = clean[1]; for (i = clean_row + 2; i &lt; total_row; ++i) &#123; map[i - 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[total_row - 1][j - 1] = map[total_row - 1][j]; &#125; for (i = total_row - 2; i &gt;= clean_row; --i) &#123; map[i + 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 2; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0;&#125;int main() &#123; int answer, idx = 0; scanf(\"%d %d %d\", &amp;total_row, &amp;total_col, &amp;time); for (int i = 0; i &lt; total_row; ++i) &#123; for (int j = 0; j &lt; total_col; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); if (map[i][j] &gt;= 5) q.push(&#123; i, j, map[i][j] &#125;); &#125; if (map[i][0] == -1) clean[idx++] = i; &#125; while (time--) &#123; answer = 0; spread(); wind(); printf(\"change\\n\"); for (int i = 0; i &lt; total_row; ++i) &#123; for (int j = 0; j &lt; total_col; ++j) &#123; printf(\"%d \", map[i][j]); if (map[i][j] &gt; 0) answer += map[i][j]; if (map[i][j] &gt;= 5) q.push(&#123; i, j, map[i][j] &#125;); &#125; printf(\"\\n\"); &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; 바람에 의한 이동 확인용 test case12345678910111213141516177 8 12 4 0 0 0 0 0 93 0 0 0 3 0 0 8-1 3 5 0 0 0 22 0-1 8 0 0 0 0 0 33 0 0 0 0 10 43 54 0 5 0 15 0 0 02 1 40 0 0 0 20 3&#x2F;&#x2F; outputChange4 0 0 0 0 0 9 82 0 0 0 3 0 0 0-1 0 3 5 0 0 0 22-1 0 8 0 0 0 0 04 0 0 0 0 10 43 32 0 5 0 15 0 0 51 40 0 0 0 20 3 0 12345678910111213146 6 1 5 0 3 4 1 2 0 0 7 0 0 3-1 10 0 46 0 2-1 0 0 0 0 4 3 0 0 0 0 3 1 3 1 2 4 2change!! 3 1 4 4 1 2 1 3 3 10 0 3-1 4 12 10 9 2-1 2 0 9 0 4 3 0 0 0 0 3 1 3 1 2 4 2","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 17143번 낚시왕","slug":"Algorithm/BOJ/17143","date":"2020-01-25T08:04:40.000Z","updated":"2020-01-25T13:28:41.646Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17143/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17143/","excerpt":"","text":"#17143. 낚시왕문제링크 Problem R x C 크기의 격자판 낚시왕 위치 (0, 0) 1초 동안 일어나는 일 낚시왕 오른쪽으로 한 칸 이동(낚시왕이 먼저 이동하기에 상어가 이동하기 전 잡히게 된다.) 낚시왕이 열에 있는 상어 중 가장 가까운 상어를 잡는다. 상어 이동상어 : 속도와 크기를 가짐경계를 넘게되면 방향을 반대로 바꿈이동을 마친 후에 상어가 한 칸에 여러 마리 있으면, 가장 큰 상어가 나머지 상어들을 모두 먹음(사라짐) Goal: 낚시왕이 잡은 상어 크기의 합 입력 R : ~100 C : ~100 M(상어 수) : ~10000 r, c : 위치 ~R, ~C s : 속력 ~1000 d : 이동방향 1~4 상하우좌 z : 크기 ~10000 Solution 필자는 인덱스를 0부터 계산하였기에…이를 모두 신경쓰느라 🐕고생그냥 1부터 신경쓰는게 편할 수도 있다. (입력 받을 때도 신경써주어야함…) 상어 정보 (MAX는 100)1234struct INFO &#123; int row, col, speed, direction, size; bool death = false;&#125;sharks[MAX*MAX]; 상어의 현재 위치, 방향, 크기, 사라졌는지 유무가 저장된다.1234for(열의 수: 처음부터~열의 끝까지 이동) catchShark() // 1. 상어를 잡는다 moveShark() // 2. 상어가 이동한다. updateMap() // 3. 이동을 마친 상어들 map에 반영(먹히면 사라지도록) catchShark()해당 열을 탐색하다가 상어를 발견하면 답에 크기를 더해주고 리턴 moveShark()1234567891011121314151617주기 : 2 * (전체 행이나 열의 크기-1)// ex 방향 -&gt; 전체 열의 크기: 4, 상어는 (1, 2)에 있다고 가정할 때위치: 2 3 2 1 0 1 2 3 2 1 0 1 2 3방향: -&gt; &lt;- &lt;- &lt;- -&gt; -&gt; -&gt; &lt;- &lt;- &lt;- -&gt; -&gt; -&gt; &lt;-이동거리: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 주기가 2 * 3 = 6으로 이동거리가 6마다 같은 위치를 반복하고 있음방향은 0이나 전체 열의 크기-1에 위치할 때 바뀜위치는 방향에 맞게 이동해주면 됨방향1 2 3 4 // 상하 우좌1 &lt;-&gt; 2 (1일 때 2, 2일 때 1)3 &lt;-&gt; 4 (3일 때 4, 4일 때 3)현재 방향을 2로 나눴을 때 나머지가 0이면 현재 방향에서 1을 빼주고아니면 1을 더해주면 바뀐 방향을 구할 수 있다. updateMap() map을 초기화 해준다. (이동한 상어의 위치를 새로 반영하기 위해) 해당 위치에 상어가 있을 때와 없을 때를 구분해서 처리를 해준다. 초기에 입력값을 반영하기 위해, 입력을 모두 받고 한 번 호출해준다. 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cstdio&gt;#define MAX 100using namespace std;int r, c, m, idx, answer;// 상하우좌int dx[4] = &#123;-1, 1, 0, 0&#125;; int dy[4] = &#123;0, 0, 1, -1&#125;;// 상어 정보struct INFO &#123; int row, col, speed, direction, size; bool death = false;&#125;sharks[MAX*MAX];int map[MAX][MAX][2]; // 상어가 존재한다면 해당 상어 크기와 해당 상어가 몇 번째 상어인지void catchShark(int col) &#123; for (int i = 0; i &lt; r; ++i) &#123; if (map[i][col][0] != 0) &#123; sharks[map[i][col][1]].death = true; answer += sharks[map[i][col][1]].size; return; &#125; &#125;&#125;void changeDirection(int idx) &#123; if (sharks[idx].direction % 2 == 0) &#123; sharks[idx].direction--; &#125; else &#123; sharks[idx].direction++; &#125;&#125;void moveShark(int idx, int end) &#123; int period = 2 * end; int move = sharks[idx].speed % period; for (int i = 0; i &lt; move; ++i) &#123; if (sharks[idx].direction &lt;= 2) &#123; // 상하 if ((sharks[idx].row == end &amp;&amp; sharks[idx].direction == 2) || (sharks[idx].row == 0 &amp;&amp; sharks[idx].direction == 1)) &#123; changeDirection(idx); &#125; sharks[idx].row += dx[sharks[idx].direction - 1]; &#125; else &#123; // 우좌 if ((sharks[idx].col == end &amp;&amp; sharks[idx].direction == 3) || (sharks[idx].col == 0 &amp;&amp; sharks[idx].direction == 4)) &#123; changeDirection(idx); &#125; sharks[idx].col += dy[sharks[idx].direction-1]; &#125; &#125;&#125;void updateMap() &#123; for (int i = 0; i &lt; r; ++i) &#123; // map 초기화 for (int j = 0; j &lt; c; ++j) &#123; map[i][j][0] = 0; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; if (sharks[i].death) continue; int r = sharks[i].row; int c = sharks[i].col; if (map[r][c][0] != 0) &#123; // 해당 위치에 상어가 있다면 if (sharks[i].size &gt; map[r][c][0]) &#123; sharks[map[r][c][1]].death = true; map[r][c][0] = sharks[i].size; map[r][c][1] = i; &#125; else &#123; sharks[i].death = true; &#125; &#125; else &#123; // 해당 위치에 상어가 없을 때 map[r][c][0] = sharks[i].size; map[r][c][1] = i; &#125; &#125;&#125;int main() &#123; scanf(\"%d %d %d\", &amp;r, &amp;c, &amp;m); int row, col; for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d\", &amp;row); sharks[idx].row = row - 1; scanf(\"%d\", &amp;col); sharks[idx].col = col - 1; scanf(\"%d\", &amp;sharks[idx].speed); scanf(\"%d\", &amp;sharks[idx].direction); scanf(\"%d\", &amp;sharks[idx++].size); &#125; updateMap(); // 초기 map update for (int i = 0; i &lt; c; ++i) &#123; catchShark(i); // 상어 잡기 for (int j = 0; j &lt; m; ++j) &#123; // 상어 이동 if (sharks[j].death) continue; if (sharks[j].direction &lt;= 2) &#123; moveShark(j, r-1); &#125; else &#123; moveShark(j, c-1); &#125; &#125; updateMap(); // 이동한 상어 위치 반영 &#125; printf(\"%d\\n\", answer); return 0;&#125; 자꾸 for문에서 i나 j가 아닌 r, c로 고정값을 두어서…이런 실수는 진짜진짜 조심하자. For Debug123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdio&gt;#define MAX 100using namespace std;int r, c, m, idx, answer;// 상하우좌int dx[4] = &#123;-1, 1, 0, 0&#125;; int dy[4] = &#123;0, 0, 1, -1&#125;;// 상어 정보struct INFO &#123; int row, col, speed, direction, size; bool death = false;&#125;sharks[MAX*MAX];int map[MAX][MAX][2]; // 상어가 존재한다면 해당 상어 크기와 해당 상어가 몇 번째 상어인지void catchShark(int col) &#123; /*printf(\"%d번째\\n\", col); // map 확인 for (int i = 0; i &lt; r; ++i) &#123; for (int j = 0; j &lt; c; ++j) &#123; printf(\"%d \", map[i][j][0]); &#125; printf(\"\\n\"); &#125;*/ for (int i = 0; i &lt; r; ++i) &#123; if (map[i][col][0] != 0) &#123; sharks[map[i][col][1]].death = true; answer += sharks[map[i][col][1]].size; return; &#125; &#125;&#125;void changeDirection(int idx) &#123; if (sharks[idx].direction % 2 == 0) &#123; sharks[idx].direction--; &#125; else &#123; sharks[idx].direction++; &#125;&#125;void moveShark(int idx, int end) &#123; int period = 2 * end; int move = sharks[idx].speed % period; for (int i = 0; i &lt; move; ++i) &#123; if (sharks[idx].direction &lt;= 2) &#123; // 상하 if ((sharks[idx].row == end &amp;&amp; sharks[idx].direction == 2) || (sharks[idx].row == 0 &amp;&amp; sharks[idx].direction == 1)) &#123; changeDirection(idx); &#125; sharks[idx].row += dx[sharks[idx].direction - 1]; &#125; else &#123; // 우좌 if ((sharks[idx].col == end &amp;&amp; sharks[idx].direction == 3) || (sharks[idx].col == 0 &amp;&amp; sharks[idx].direction == 4)) &#123; changeDirection(idx); &#125; sharks[idx].col += dy[sharks[idx].direction-1]; &#125; &#125;&#125;void updateMap() &#123; for (int i = 0; i &lt; r; ++i) &#123; for (int j = 0; j &lt; c; ++j) &#123; map[i][j][0] = 0; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; if (sharks[i].death) continue; int r = sharks[i].row; int c = sharks[i].col; if (map[r][c][0] != 0) &#123; // 해당 위치에 상어가 있다면 if (sharks[i].size &gt; map[r][c][0]) &#123; sharks[map[r][c][1]].death = true; map[r][c][0] = sharks[i].size; map[r][c][1] = i; &#125; else &#123; sharks[i].death = true; &#125; &#125; else &#123; // 해당 위치에 상어가 없을 때 map[r][c][0] = sharks[i].size; map[r][c][1] = i; &#125; &#125;&#125;int main() &#123; scanf(\"%d %d %d\", &amp;r, &amp;c, &amp;m); int row, col; for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d\", &amp;row); sharks[idx].row = row - 1; scanf(\"%d\", &amp;col); sharks[idx].col = col - 1; scanf(\"%d\", &amp;sharks[idx].speed); scanf(\"%d\", &amp;sharks[idx].direction); scanf(\"%d\", &amp;sharks[idx++].size); &#125; updateMap(); /*for (int i = 0; i &lt; m; ++i) &#123; // 입력 확인 printf(\"%d %d %d %d %d\\n\", sharks[i].row, sharks[i].col, sharks[i].speed, sharks[i].direction, sharks[i].size); &#125;*/ for (int i = 0; i &lt; c; ++i) &#123; catchShark(i); for (int j = 0; j &lt; m; ++j) &#123; if (sharks[j].death) continue; if (sharks[j].direction &lt;= 2) &#123; moveShark(j, r-1); &#125; else &#123; moveShark(j, c-1); &#125; &#125; updateMap(); &#125; printf(\"%d\\n\", answer); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 17142번 연구소 3","slug":"Algorithm/BOJ/17142","date":"2020-01-25T08:04:37.000Z","updated":"2020-01-25T13:28:41.650Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17142/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17142/","excerpt":"","text":"#17142. 연구소 3Problem 문제링크 Solution 퍼트릴 M개의 바이러스를 선택한다. (DFS)중복을 허용하지 않는 조합이다. 선택한 바이러스를 퍼트리다. (BFS)4 방향으로 탐색을 하되, 빈 칸 또는 바이러스가 있는 곳이어야 한다. dist라는 배열에 시간을 저장한다.단, 모서리에 있는 바이러스에서 탐색이 끝난 경우 시간을 1 빼주어야 한다. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;int N, M, ans = 1e9;int map[50][50];int selected[10];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;vector&lt;pair&lt;int, int&gt;&gt; virus;void Spread() &#123; bool visit[50][50] = &#123; 0, &#125;; int dist[50][50] = &#123; 0, &#125;; queue&lt;pair&lt;int, int&gt;&gt; q; for (auto e : selected) &#123; if (e != -1) &#123; q.push(&#123; virus[e].first, virus[e].second &#125;); visit[virus[e].first][virus[e].second] = true; &#125; &#125; while (!q.empty()) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &lt; 0 || d_y &lt; 0 || d_x &gt;= N || d_y &gt;= N) continue; if (map[d_x][d_y] == 1 || visit[d_x][d_y]) continue; visit[d_x][d_y] = true; q.push(&#123; d_x, d_y &#125;); dist[d_x][d_y] = dist[x][y] + 1; &#125; &#125; int time = 0; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (dist[i][j] != 0 &amp;&amp; map[i][j] == 2) &#123; if (i == 0 || j == 0 || i == N - 1 || j == N - 1) dist[i][j]--; &#125; if (!visit[i][j] &amp;&amp; map[i][j] == 0) return; if (dist[i][j] &gt; time) time = dist[i][j]; &#125; &#125; if (ans &gt; time) ans = time;&#125;void SelectVirus(int idx, int cnt) &#123; if (cnt == M) &#123; Spread(); return; &#125; for (int i = idx; i &lt; virus.size(); ++i) &#123; selected[i] = i; SelectVirus(i+1, cnt + 1); selected[i] = -1; &#125;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M; bool no_zero = true; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; cin &gt;&gt; map[i][j]; if (map[i][j] == 2) virus.push_back(&#123; i, j &#125;); if (map[i][j] == 0) no_zero = false; &#125; &#125; if (no_zero) &#123; cout &lt;&lt; 0 &lt;&lt; \"\\n\"; &#125; else &#123; memset(selected, -1, sizeof(selected)); SelectVirus(0, 0); if (ans != 1e9) cout &lt;&lt; ans &lt;&lt; \"\\n\"; else cout &lt;&lt; -1 &lt;&lt; \"\\n\"; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 17140번 이차원 배열과 연산","slug":"Algorithm/BOJ/17140","date":"2020-01-25T08:04:30.000Z","updated":"2020-01-25T13:28:41.638Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17140/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17140/","excerpt":"","text":"#17140. 이차원 배열과 연산Problem 문제링크 Solution 시뮬레이션 문제이다. (항상 자료구조를 뭘 사용할지 잘 판단하자.) 여기서는 map과 priority queue를 사용하였다. map의 쓰임 &lt;수, 등장 횟수&gt;를 저장하기 위해 쓰인다. 처음에 1차원 배열로 cnt[수]=등장 횟수로 하려 했지만, 이렇게 되면 매번 100번 for문을 연산해야 한다고 느껴 map을 이용해 바로 접근이 가능하도록 하였다. priority queue의 쓰임 R연산 또는 C연산 중에 생성되는 정렬된 값들을 저장하기 위해 쓰인다. 연산자를 오버로딩하여 삽입 시 정렬 순위를 정해주었다.원래 우선순위 큐는 기본적으로 내림차순으로 정렬되어 있다. (pair라면 첫 번째 기준, 첫 번째 원소가 같다면 두 번째 원소 내림차순 정렬) 그렇기에 따로 정해주었는데 그럴 필요 없이 -를 붙여 저장하면 오름차순으로 정렬된다는 것을 깨닫고…(유레카!!) *아래 코드는 그러진 않았다. 해당 수를 카운트할 때 중요한 것은 카운트가 끝나면 해당 배열의 값을 0으로 바꾼다는 것이다. 그래야 행이나 열의 크기가 줄어들 때 영향을 받지 않고 연산을 정상적으로 수행할 수 있다. 그 외는 문제 그대로 구현하면 된다. 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;int r, c, k, total_r, total_c;int A[100][100]; // 1 ~ 100map&lt;int, int&gt; cnt;struct Info &#123; int num, count;&#125;;bool operator&lt;(const Info &amp;v1, const Info &amp;v2) &#123; if (v1.count == v2.count) return v1.num &gt; v2.num; return v1.count &gt; v2.count;&#125;void Input() &#123; cin &gt;&gt; r &gt;&gt; c &gt;&gt; k; total_r = total_c = 3; for (int i = 0; i &lt; total_r; ++i) &#123; for (int j = 0; j &lt; total_c; ++j) &#123; cin &gt;&gt; A[i][j]; &#125; &#125;&#125;void Task() &#123; for (int t = 0; t &lt;= 100; ++t) &#123; if (A[r - 1][c - 1] == k) &#123; cout &lt;&lt; t &lt;&lt; \"\\n\"; return; &#125; priority_queue&lt;Info&gt; pq; if (total_r &gt;= total_c) &#123; // R 연산 for (int i = 0; i &lt; total_r; ++i) &#123; for (int j = 0; j &lt; total_c; ++j) &#123; if (A[i][j] == 0) continue; if (cnt.count(A[i][j]) == 0) cnt[A[i][j]] = 1; else cnt[A[i][j]]++; A[i][j] = 0; &#125; for (auto e : cnt) &#123; pq.push(&#123; e.first, e.second &#125;); &#125; cnt.clear(); int len = pq.size() * 2; for (int j = 0; j &lt; len; j += 2) &#123; A[i][j] = pq.top().num; A[i][j + 1] = pq.top().count; pq.pop(); &#125; if (total_c &lt; len) total_c = len; &#125; &#125; else &#123; // C 연산 for (int i = 0; i &lt; total_c; ++i) &#123; for (int j = 0; j &lt; total_r; ++j) &#123; if (A[j][i] == 0) continue; if (cnt.count(A[j][i]) == 0) cnt[A[j][i]] = 1; else cnt[A[j][i]]++; A[j][i] = 0; &#125; for (auto e : cnt) &#123; pq.push(&#123; e.first, e.second &#125;); &#125; cnt.clear(); int len = pq.size() * 2; for (int j = 0; j &lt; len; j += 2) &#123; A[j][i] = pq.top().num; A[j + 1][i] = pq.top().count; pq.pop(); &#125; if (total_r &lt; len) total_r = len; &#125; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; \"\\n\";&#125;int main() &#123; Input(); Task(); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 17136번 색종이 붙이기","slug":"Algorithm/BOJ/17136","date":"2020-01-25T08:04:26.000Z","updated":"2020-01-25T13:28:41.643Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17136/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17136/","excerpt":"","text":"#17136. 색종이 붙이기Problem 문제링크 Solution DFS + BackTracking을 사용하여 푼다.(처음에 BFS+Greedy를 이용해 풀었다가 틀렸다…반례가 존재) 10 x 10 크기의 모든 배열에서 모든 지점을 탐색한다. 탐색 횟수가 100이라면 모든 지점을 탐색한 경우라 값을 갱신하고 종료한다. 행과 열은 0 → 100개의 원소들에 맞게 계산 이미 ans 가 지금까지 구한 개수(cnt) 보다 크면 종료 (BackTracking) 해당 지점이 1이면 색종이 크기가 큰 5부터 검사 시작 해당 크기가 가능하면 붙이고 다음 경우 탐색탐색이 끝난 경우 원래대로 돌려놓아야 모든 경우 탐색이 가능하다. 해당 지점이 0이면 다음 번째 원소 탐색 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;int ans = 100;int map[10][10];int type[5] = &#123;5, 5, 5, 5, 5 &#125;; // 1 2 3 4 5 종류void Update(int x, int y, int size, int status) &#123; for (int i = x; i &lt; x + size; ++i) &#123; for (int j = y; j &lt; y + size; ++j) &#123; map[i][j] = status; &#125; &#125;&#125;bool Check(int x, int y, int size) &#123; if (x + size &gt; 10 || y + size &gt; 10) return false; // 범위 밖 for (int i = x; i &lt; x + size; ++i) &#123; for (int j = y; j &lt; y + size; ++j) &#123; if (map[i][j] == 0) return false; &#125; &#125; return true;&#125;void DFS(int n, int cnt) &#123; if (n == 100) &#123; // 모든 경우를 탐색한 경우 (총 100개) if (ans &gt; cnt) ans = cnt; return; &#125; int x = n / 10; int y = n % 10; if (ans &lt;= cnt) return; // BackTracking if (map[x][y] == 1) &#123; for (int i = 5; i &gt; 0; --i) &#123; // 크기 5부터 시작 if (type[i-1] &gt; 0) &#123; if (Check(x, y, i)) &#123; type[i - 1]--; Update(x, y, i, 0); // 색종이 붙이기 DFS(n+1, cnt + 1); Update(x, y, i, 1); // 색종이 다시 때기 type[i - 1]++; &#125; &#125; &#125; &#125; else DFS(n + 1, cnt);&#125;int main() &#123; for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; 10; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; DFS(0, 0); if (ans == 100) ans = -1; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 17135번 캐슬 디펜스","slug":"Algorithm/BOJ/17135","date":"2020-01-25T08:04:21.000Z","updated":"2020-01-25T13:28:41.647Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17135/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17135/","excerpt":"","text":"#17135. 캐슬 디펜스Problem 문제링크 Solution 궁수 3명의 위치를 지정한다. (중복x, 오름차순 순열조합) 적이 사라질 때까지(=궁수가 0번째 행으로 이동할 때까지) 게임을 진행한다. 궁수는 가장 가까운 위치의 적을 공격해야 하며, 여럿이면 왼쪽의 적부터 공격한다. 또한 동시에 공격이 가능하다(=위의 조건을 만족하는 같은 적을 공격한다.) 공격이 끝나면 배열을 바꾸지 않고 궁수의 위치를 이동시킨다. (위로)step 변수를 두어 범위를 좁혀간다. 가까운 적을 먼저 찾아 공격하기 위해 BFS 탐색을 사용한다. 각 궁수별로 queue 를 만들어 자신의 위치를 저장하고 탐색 시작 (최대 D까지) 궁수가 적을 공격할 경우 다음 궁수에게 차례를 넘긴다. (즉, 공격하면 자신의 턴 끝=탐색 끝) check array를 사용해 공격한 적일 경우 해당 step + 1의 값을 준다. (step이 0부터 시작, check는 0으로 초기화 되어있기에) step을 이용해 check에 값을 준 이유는 다음 step에서 궁수의 위치가 이동될 때 이전 턴에서 공격 당해 제외된 적인지 아닌지를 판단하기 위함이다. (step의 값이 변하니까 중복되지 않게 탐색 가능) 1 Try 궁수는 가장 가까운 위치의 적을 공격, 가까운 적이 여럿이면 왼쪽 우선 그리고 동시에 공격 가능하다는 조건을 충족하지 못 했다. → BFS를 이용하기로 결정123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int N, M, D, ans;int map[16][16];bool check[16][16];int archer[3] = &#123; -1, -1, -1 &#125;;int getDistance(int a_x, int a_y, int b_x, int b_y) &#123; return abs(a_x - b_x) + abs(a_y - b_y);&#125;void Game() &#123; int step = 0, res = 0; memset(check, 0, sizeof(check)); while (true) &#123; int attack_cnt = 0; for (int i = N - step - 1; i &gt;= (N -step) - D &amp;&amp; i &gt;= 0; --i) &#123; for (int k = attack_cnt; k &lt; 3; ++k) &#123; // 3명의 궁수 for (int j = 0; j &lt; M; ++j) &#123; if (D &gt;= getDistance(i, j, N - step, archer[k]) &amp;&amp; map[i][j] == 1 &amp;&amp; !check[i][j]) &#123; // 공격 개시 res++; check[i][j] = true; attack_cnt++; break; // 한 번만 공격 가능 &#125; &#125; &#125; &#125; step++; if (N - step - 1 &lt; 0) break; &#125; if (ans &lt; res) ans = res;&#125;void SelectPosition(int n, int cnt) &#123; if (cnt == 3) &#123; Game(); return; &#125; for (int i = n; i &lt; M; ++i) &#123; if (archer[cnt] != -1) continue; archer[cnt] = i; SelectPosition(i + 1, cnt + 1); archer[cnt] = -1; &#125;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; D; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; SelectPosition(0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; 2 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int N, M, D, ans;int map[16][16];int check[16][16];int archer[3] = &#123; -1, -1, -1 &#125;;int dx[3] = &#123; 0, -1, 0 &#125;;int dy[3] = &#123; -1, 0, 1 &#125;;void Game() &#123; int step = 0, res = 0; // step은 1턴이 끝날 때 이동을 위함 memset(check, 0, sizeof(check)); while (true) &#123; for (int i = 0; i &lt; 3; ++i) &#123; // 궁수 각 3명에 대하여 queue&lt;pair&lt;int, int&gt; &gt; q; q.push(&#123; N - step, archer[i] &#125;); // 궁수 현재 위치부터 시작 for(int j = 0; j &lt; D; ++j) &#123; // 최대 D까지만큼만 탐색 int len = q.size(); bool end_flag = false; // 적을 공격했을 때 종료 flag for (int k = 0; k &lt; len; ++k) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 3; ++dir) &#123; // 왼 위 오 순서로 탐색 시작 int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; N - step &amp;&amp; d_y &lt; M) &#123; // N - step은 궁수 위치 if (d_x &lt; N - step - D) continue; // [N - step - D, N-step) 탐색 범위 if (map[d_x][d_y] == 1 &amp;&amp; check[d_x][d_y] == 0) &#123; // 처음 적을 공격한 경우 res++; check[d_x][d_y] = step + 1; // step을 옮겼을 때 중복 방지를 위함 end_flag = true; break; &#125; else if (map[d_x][d_y] == 1 &amp;&amp; check[d_x][d_y] == step + 1) &#123; // 동시에 적을 공격한 경우 end_flag = true; break; &#125; else &#123; // 적을 발견하지 못 한 경우 q.push(&#123; d_x, d_y &#125;); &#125; &#125; &#125; if (end_flag) break; &#125; if (end_flag) break; &#125; &#125; step++; if (N - step - 1 &lt; 0) break; &#125; if (ans &lt; res) ans = res;&#125;void SelectPosition(int n, int cnt) &#123; if (cnt == 3) &#123; Game(); return; &#125; for (int i = n; i &lt; M; ++i) &#123; if (archer[cnt] != -1) continue; archer[cnt] = i; SelectPosition(i + 1, cnt + 1); archer[cnt] = -1; &#125;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; D; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; SelectPosition(0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 17070번 파이프 옮기기 1","slug":"Algorithm/BOJ/17070","date":"2020-01-25T08:04:16.000Z","updated":"2020-01-25T13:28:41.649Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17070/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17070/","excerpt":"","text":"#17070. 파이프 옮기기 1문제링크 Problem 파이프는 2개의 연속된 칸을 차지 회전이 가능 (3가지: 수평선, 수직선, 대각선(4칸 차지)) Goal: (0, 0) 과 (0, 1)에 위치한 하나의 파이프를 (N, N)으로 옮기는 방법의 개수불가능한 경우 0 파이프 옮기기 오른쪽, 아래, 오른쪽 아래 대각선 방향으로 옮길 수 있음옮길 때 45도 회전 가능벽에 닿으면 안됨 가로(수평) → 오른쪽 or 오른쪽 아래 대각선 세로(수직) → 아래 or 오른쪽 아래 대각선 오른쪽 아래 대각선 → 3가지 모두 가능 입력 N: 3~16 빈칸 0 벽은 1 // 예제 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 -&gt; 0 맨 처음 파이프는 (0,0), (0,1) 즉 가로이기에 가능한 방향인 오른쪽, 오른쪽 아래 대각선으로 옮길 수 없다. Solution 현재 type 정보와 위치를 알고 있어야 한다. 현재 type에 따라 옮길 수 있는 방향이 다르다. 현재 type에 따라 옮길 수 있는지 check를 해주어야 한다. check12345678910111213가로: 오른쪽 1칸 검사세로: 아래 1칸 검사대각선: 오른쪽 1칸, 아래 1칸, 오른쪽 아래 1칸 검사// # 1.가로 -&gt; 가로 (자기 자신) -&gt; 대각선 // # 2.세로 -&gt; 세로 (자기 자신) -&gt; 대각선 // # 3.대각선 -&gt; 세로 -&gt; 가로 -&gt; 대각선 모두 자기 자신의 타입 그대로 옮길 수 있다. 대각선을 가기 위해서는 가로, 세로로 갈 수 있는 조건 역시 만족해야 한다. 위를 이용하여 탐색 코드를 구현한다.12345678void 탐색(현재 위치, 현재 타입) 도착했을 때 answer++후 리턴 for(3번) check할 위치(오른쪽, 아래, 오른쪽 아래) 경계확인 (벽이 아니고 자신과 같은 type)이거나(벽이 아니고 대각선) 탐색(옮길 위치, 가능한 타입) 모든 곳을 검사했을 때만 대각선 탐색 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#define MAX 16using namespace std;int n, answer;int map[MAX][MAX];bool check[MAX][MAX];// 오른쪽 1칸 검사, 아래 1칸 검사, 오른쪽 아래 1칸 검사int dx[3] = &#123; 0, 1, 1 &#125;; int dy[3] = &#123; 1, 0, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; n &amp;&amp; c &lt; n) return true; return false;&#125;// type 0 : 가로, 1 : 세로, 2 : 대각선void dfs(int r, int c, int type) &#123; if (r == n - 1 &amp;&amp; c == n - 1) &#123; answer++; return; &#125; // 현재 타입이 가로일 때 어차피 대각선 때문에 3칸 다 검사해야 한다. int x, y; bool flag = true; for (int i = 0; i &lt; 3; ++i) &#123; x = r + dx[i]; y = c + dy[i]; if (isBound(x, y)) &#123;// 같은 type일 경우 or 대각선일 경우, i==2이면 대각선 경우가 한 번 더 구해지는 꼴이다. if ((map[x][y] == 0 &amp;&amp; type == i || map[x][y] == 0 &amp;&amp; type == 2) &amp;&amp; i != 2) &#123; dfs(x, y, i); &#125; else if (map[x][y] != 0) flag = false; &#125; else flag = false; &#125; if (flag) &#123; dfs(x, y, 2); // 오른쪽 아래 대각선 &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); &#125; &#125; dfs(0, 1, 0); printf(\"%d\\n\", answer); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 16637번 괄호 추가하기","slug":"Algorithm/BOJ/16637","date":"2020-01-25T08:04:06.000Z","updated":"2020-01-25T13:28:41.644Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/16637/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/16637/","excerpt":"","text":"#16637. 괄호 추가하기Problem 문제링크 Solution 어느 연산자에 괄호를 넣을지 정해야 한다.괄호는 연산자 연속으로 넣을 수 없다. (1+(3)-2) → 말도 안되는 식그렇기에 이전 괄호의 위치를 알고 있어야 한다.괄호는 첫 번째에 넣을 필요는 없으며(op[i]≠1)이전 괄호의 위치와 2 차이가 나면 안된다. 괄호를 모두 지정했으면 각 경우에 맞게 식을 계산한다. 괄호가 등장하면 한 번에 계산하고 반환한다. Stack을 사용하여 연산자만 넣는다. Stack이 비어있지 않으면 꺼내어 연산자에 맞게 계산한다. 1 Try *(곱셈)은 괄호가 필요 없을 것이라 생각하여 괄호를 넣어주지 않았다.하지만 연산은 왼쪽에서부터 순서대로 진행되기에 곱셈도 괄호가 필요하다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;char expr[20];bool selected[20];int op[10];int N, ans, total_bracket;int TaskBracket(int start) &#123; int a = expr[start] - '0'; int b = expr[start+2] - '0'; char opr = expr[start + 1]; if (opr == '+') &#123; return a + b; &#125; else &#123; return a - b; &#125;&#125;void Calculate() &#123; int res = expr[0]-'0', tmp = 0, idx = 0; bool flag = false; stack&lt;char&gt; st; for (int i = 1; i &lt; N; ++i) &#123; if (i != N-1 &amp;&amp; selected[i+1]) &#123; tmp = TaskBracket(i); i+=2; flag = true; &#125; if (!st.empty()) &#123; if (st.top() == '+') &#123; if(flag) res += tmp; else res += int(expr[i] - '0'); &#125; else if (st.top() == '-') &#123; if(flag) res -= tmp; else res -= int(expr[i] - '0'); &#125; else &#123; if(flag) res *= tmp; else res *= int(expr[i] - '0'); &#125; st.pop(); flag = false; &#125; if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*') &#123; st.push(expr[i]); &#125; &#125; if (res &gt; ans) ans = res;&#125;void SelectBracket(int n, int cnt, int prior) &#123; if (cnt &lt;= total_bracket) &#123; Calculate(); &#125; for (int i = n; i &lt; total_bracket; ++i) &#123; if (selected[op[i]] || op[i] == 1) continue; if (op[i] - prior == 2) continue; selected[op[i]] = true; SelectBracket(i+1, cnt+1, op[i]); selected[op[i]] = false; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; expr[i]; if (expr[i] == '+' || expr[i] == '-') &#123; op[total_bracket++] = i; &#125; &#125; SelectBracket(0, 0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; 2 Try ans(정답)의 초기값을 0으로 설정해서 틀렸다. 정답은 (-2^31, 2^31)의 범위에 속한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;char expr[20];bool selected[20];int op[10];int N, total_bracket, ans;int TaskBracket(int start) &#123; int a = expr[start] - '0'; int b = expr[start+2] - '0'; char opr = expr[start + 1]; if (opr == '+') &#123; return a + b; &#125; else if(opr == '-') &#123; return a - b; &#125; else return a * b;&#125;void Calculate() &#123; int res = expr[0]-'0', tmp = 0, idx = 0; bool flag = false; stack&lt;char&gt; st; for (int i = 1; i &lt; N; ++i) &#123; if (i != N-1 &amp;&amp; selected[i+1]) &#123; tmp = TaskBracket(i); i+=2; flag = true; &#125; if (!st.empty()) &#123; if (st.top() == '+') &#123; if(flag) res += tmp; else res += int(expr[i] - '0'); &#125; else if (st.top() == '-') &#123; if(flag) res -= tmp; else res -= int(expr[i] - '0'); &#125; else &#123; if(flag) res *= tmp; else res *= int(expr[i] - '0'); &#125; st.pop(); flag = false; &#125; if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*') &#123; st.push(expr[i]); &#125; &#125; if (res &gt; ans) ans = res;&#125;void SelectBracket(int n, int cnt, int prior) &#123; if (cnt &lt;= total_bracket) &#123; Calculate(); &#125; for (int i = n; i &lt; total_bracket; ++i) &#123; if (selected[op[i]] || op[i] == 1) continue; if (op[i] - prior == 2) continue; selected[op[i]] = true; SelectBracket(i+1, cnt+1, op[i]); selected[op[i]] = false; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; expr[i]; if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*') &#123; op[total_bracket++] = i; &#125; &#125; SelectBracket(0, 0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; 3 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;limits&gt;#include &lt;stack&gt;using namespace std;char expr[20];bool selected[20];int op[10];int N, total_bracket, ans = numeric_limits&lt;int&gt;::min();int TaskBracket(int start) &#123; int a = expr[start] - '0'; int b = expr[start+2] - '0'; char opr = expr[start + 1]; if (opr == '+') &#123; return a + b; &#125; else if(opr == '-') &#123; return a - b; &#125; else return a * b;&#125;void Calculate() &#123; int res = expr[0]-'0', tmp = 0, idx = 0; bool flag = false; stack&lt;char&gt; st; for (int i = 1; i &lt; N; ++i) &#123; if (i != N-1 &amp;&amp; selected[i+1]) &#123; // 괄호인 경우 tmp = TaskBracket(i); // 한 번에 계산 i+=2; flag = true; &#125; if (!st.empty()) &#123; // 스택에 연산자가 있을 경우 if (st.top() == '+') &#123; if(flag) res += tmp; else res += int(expr[i] - '0'); &#125; else if (st.top() == '-') &#123; if(flag) res -= tmp; else res -= int(expr[i] - '0'); &#125; else &#123; if(flag) res *= tmp; else res *= int(expr[i] - '0'); &#125; st.pop(); flag = false; &#125; if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*') &#123; st.push(expr[i]); &#125; &#125; if (res &gt; ans) ans = res;&#125;void SelectBracket(int n, int cnt, int prior) &#123; if (cnt &lt;= total_bracket) &#123; Calculate(); &#125; for (int i = n; i &lt; total_bracket; ++i) &#123; if (selected[op[i]] || op[i] == 1) continue; // 첫 번째 연산자에 괄호는 필요 없다. if (op[i] - prior == 2) continue; // 연속적인 괄호는 불가능 selected[op[i]] = true; SelectBracket(i+1, cnt+1, op[i]); selected[op[i]] = false; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; expr[i]; if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*') &#123; op[total_bracket++] = i; &#125; &#125; SelectBracket(0, 0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 16236번 아기 상어","slug":"Algorithm/BOJ/16236","date":"2020-01-25T08:03:58.000Z","updated":"2020-01-25T13:16:42.342Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/16236/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/16236/","excerpt":"","text":"#16236. 아기 상어문제링크 Problem N x N 공간 물고기 M, 아기 상어 1마리 (1칸에 최대 1마리) 아기 상어 처음 크기 : 2, 물고기도 크기 존재 아기 상어 움직임 (1초마다 상하좌우)자신보다 큰 물고기 있는 칸은 못 감 나머진 이동 가능자신보다 작은 물고기만 먹을 수 있고, 크기가 같다면 지나가는건 가능 자신의 크기만큼 물고기를 먹어야 크기가 1 증가한다. 상어가 이동할 곳 결정 방법 더 이상 먹을 물고기가 없으면 종료 먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹는다. (여기부터 이동) 1마리보다 많다면, 거리가 가장 가까운 물고기부터 먹는다. 가장 가까운 물고기가 여럿이면 가장 위 그런 물고기가 또 여럿이면 가장 왼쪽에 있는 물고기를 먹는다. Goal: 종료되는 시간은? 입력 0: 빈 칸 1~6: 물고기 크기 9: 아기 상어 Solution 입력값 다루기 struct shark { int r, c, size, cnt= 0; }baby; 아기 상어의 위치, 크기, 먹은 수를 저장할 수 있도록 구조체를 만든다. 다음 작업이 반복된다. 먹이를 찾기 찾았다면 그 중 규칙에 따라 먹이 선택하기 먹이 찾기 탐색할 queue와 먹을 수 있는 물고기를 저장할 queue가 필요하다. 탐색 지점의 표시를 위해 check 배열이 필요하다. 아기 상어가 이동한 후 다음 먹이까지 찾아가는데 걸리는 시간을 따로 저장해야 한다. (part_time) 탐색할 지점은 경계를 넘지 않고 아기 상어 크기보다 작거나 같고 탐색표시가 안된 지점이다. 탐색이 가능할 때 탐색 표시를 하고 탐색 queue에 넣어준다. 아기 상어 크기보다 작은 물고기라면 먹이 queue에 넣어준다. 1초간 갈 수 있는 탐색이 끝나면 먹이 queue가 비어있는지를 판단한다. 먹이 queue에 먹이가 들어있으면 걸린 시간(part_time)을 더해준다. 먹이를 선택한다.123456789101112131415161718192021222324252627282930313233void findPrey(int row, int col) &#123; queue&lt;pair&lt;int, int&gt;&gt; q, prey; q.push(&#123; row, col &#125;); memset(check, 0, sizeof(check)); check[row][col] = true; int part_time = 0; while (!q.empty()) &#123; // 순회할 때마다 1초 증가 part_time++; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; baby.size &gt;= map[x][y] &amp;&amp; !check[x][y]) &#123; if (baby.size &gt; map[x][y] &amp;&amp; map[x][y] &gt; 0) &#123; prey.push(&#123; x, y &#125;); &#125; check[x][y] = true; q.push(&#123; x, y &#125;); &#125; &#125; &#125; if (!prey.empty()) &#123; selectPrey(prey); time += part_time; return; &#125; &#125; isEnd = true;&#125; 만약 탐색을 모두 했는데도 먹이가 없다면 isEnd는 true가 되므로 작업이 종료된다. 규칙에 따라 먹이 선택하기1234567891011121314151617181920212223242526void selectPrey(queue&lt;pair&lt;int, int&gt;&gt; &amp;prey) &#123; int prior_x = n, prior_y = n; while (!prey.empty()) &#123; int x = prey.front().first; int y = prey.front().second; prey.pop(); if (x &lt; prior_x) &#123; prior_x = x; prior_y = y; &#125; else if (x == prior_x) &#123; if (y &lt; prior_y) &#123; prior_y = y; &#125; &#125; &#125; map[baby.r][baby.c] = 0; map[prior_x][prior_y] = 9; baby.r = prior_x; baby.c = prior_y; baby.cnt++; if (baby.cnt == baby.size) &#123; baby.size++; baby.cnt = 0; &#125;&#125; 이 먹이 queue에 들어있는 (여럿이라면)물고기들은 모두 같은 거리이기에 문제의 규칙인 가장 위쪽 우선, 가장 왼쪽 우선을 따라 물고기를 선택한다. 먹을 물고기가 선택되면 아기 상어의 위치를 변경해준다. 크기 또한 먹은 수에 맞게 변경해준다. 1 Try 시간초과 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX 21using namespace std;int n, time;bool isEnd;int map[MAX][MAX];bool check[MAX][MAX];int dx[4] = &#123; -1, 0, 0, 1 &#125;;int dy[4] = &#123; 0, -1, 1, 0 &#125;;struct shark &#123; int r, c, size, cnt= 0;&#125;baby;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; n &amp;&amp; c &lt; n) return true; return false;&#125;void selectPrey(queue&lt;pair&lt;int, int&gt;&gt; &amp;prey, queue&lt;pair&lt;int, int&gt;&gt; &amp;q) &#123; int prior_x = n, prior_y = n; while (!prey.empty()) &#123; int x = prey.front().first; int y = prey.front().second; prey.pop(); if (x &lt; prior_x) &#123; prior_x = x; prior_y = y; &#125; else if (x == prior_x) &#123; if (y &lt; prior_y) &#123; prior_y = y; &#125; &#125; &#125; map[baby.r][baby.c] = 0; map[prior_x][prior_y] = 9; baby.r = prior_x; baby.c = prior_y; baby.cnt++; if (baby.cnt == baby.size) &#123; baby.size++; baby.cnt = 0; &#125; q.push(&#123; prior_x, prior_y &#125;);&#125;void findPrey(int row, int col) &#123; queue&lt;pair&lt;int, int&gt;&gt; q, prey; q.push(&#123; row, col &#125;); check[row][col] = true; int part_time = 0; while (!q.empty()) &#123; // 순회할 때마다 1초 증가 part_time++; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; baby.size &gt;= map[x][y] &amp;&amp; !check[x][y]) &#123; if (baby.size &gt; map[x][y] &amp;&amp; map[x][y] &gt; 0) &#123; prey.push(&#123; x, y &#125;); &#125; check[x][y] = true; q.push(&#123; x, y &#125;); &#125; &#125; &#125; if (!prey.empty()) &#123; while (!q.empty()) q.pop(); selectPrey(prey, q); time = part_time; memset(check, 0, sizeof(check)); &#125; &#125; isEnd = true;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); if (map[i][j] == 9) &#123; // 아기 상어 정보 baby.r = i; baby.c = j; baby.size = 2; &#125; &#125; &#125; while (!isEnd) &#123; findPrey(baby.r, baby.c); &#125; printf(\"%d\\n\", time); return 0;&#125; while (!q.empty()) q.pop(); 라인 때문에 시간초과가 걸린 것 같아 굳이 이럴 필요 없이 먹을 수 있는 물고기가 있다면 selectPrey() 를 호출하여 물고기를 선택하고 시간을 갱신해준 후 return하도록 하였다. 이러면 다시 findPrey() 를 호출하기에 업데이트 된 아기 상어 위치가 queue에 들어가고 작업을 수행한다. q를 비울 필요가 없어짐. 2 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX 21using namespace std;int n, time;bool isEnd;int map[MAX][MAX];bool check[MAX][MAX];// 상좌우하int dx[4] = &#123; -1, 0, 0, 1 &#125;;int dy[4] = &#123; 0, -1, 1, 0 &#125;;struct shark &#123; int r, c, size, cnt= 0;&#125;baby;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; n &amp;&amp; c &lt; n) return true; return false;&#125;void selectPrey(queue&lt;pair&lt;int, int&gt;&gt; &amp;prey) &#123; int prior_x = n, prior_y = n; while (!prey.empty()) &#123; int x = prey.front().first; int y = prey.front().second; prey.pop(); if (x &lt; prior_x) &#123; prior_x = x; prior_y = y; &#125; else if (x == prior_x) &#123; if (y &lt; prior_y) &#123; prior_y = y; &#125; &#125; &#125; map[baby.r][baby.c] = 0; map[prior_x][prior_y] = 9; baby.r = prior_x; baby.c = prior_y; baby.cnt++; if (baby.cnt == baby.size) &#123; baby.size++; baby.cnt = 0; &#125;&#125;void findPrey(int row, int col) &#123; queue&lt;pair&lt;int, int&gt;&gt; q, prey; q.push(&#123; row, col &#125;); memset(check, 0, sizeof(check)); check[row][col] = true; int part_time = 0; while (!q.empty()) &#123; // 순회할 때마다 1초 증가 part_time++; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; baby.size &gt;= map[x][y] &amp;&amp; !check[x][y]) &#123; if (baby.size &gt; map[x][y] &amp;&amp; map[x][y] &gt; 0) &#123; prey.push(&#123; x, y &#125;); &#125; check[x][y] = true; q.push(&#123; x, y &#125;); &#125; &#125; &#125; if (!prey.empty()) &#123; selectPrey(prey); time += part_time; return; &#125; &#125; isEnd = true;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); if (map[i][j] == 9) &#123; // 아기 상어 정보 baby.r = i; baby.c = j; baby.size = 2; &#125; &#125; &#125; while (!isEnd) &#123; findPrey(baby.r, baby.c); &#125; printf(\"%d\\n\", time); return 0;&#125; Debug 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX 21using namespace std;int n, time;bool isEnd;int map[MAX][MAX];bool check[MAX][MAX];// 상좌우하int dx[4] = &#123; -1, 0, 0, 1 &#125;;int dy[4] = &#123; 0, -1, 1, 0 &#125;;struct shark &#123; int r, c, size, cnt= 0;&#125;baby;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; n &amp;&amp; c &lt; n) return true; return false;&#125;void selectPrey(queue&lt;pair&lt;int, int&gt;&gt; &amp;prey, queue&lt;pair&lt;int, int&gt;&gt; &amp;q) &#123; int prior_x = n, prior_y = n; while (!prey.empty()) &#123; int x = prey.front().first; int y = prey.front().second; prey.pop(); if (x &lt; prior_x) &#123; prior_x = x; prior_y = y; &#125; else if (x == prior_x) &#123; if (y &lt; prior_y) &#123; prior_y = y; &#125; &#125; &#125; map[baby.r][baby.c] = 0; map[prior_x][prior_y] = 9; baby.r = prior_x; baby.c = prior_y; baby.cnt++; if (baby.cnt == baby.size) &#123; baby.size++; baby.cnt = 0; &#125; q.push(&#123; prior_x, prior_y &#125;); /*printf(\"change %d\\n\"); for (int k = 0; k &lt; n; ++k) &#123; for (int l = 0; l &lt; n; ++l) &#123; printf(\"%d \", map[k][l]); &#125; printf(\"\\n\"); &#125;*/&#125;void findPrey(int row, int col) &#123; queue&lt;pair&lt;int, int&gt;&gt; q, prey; q.push(&#123; row, col &#125;); check[row][col] = true; int part_time = 0; while (!q.empty()) &#123; // 순회할 때마다 1초 증가 part_time++; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; baby.size &gt;= map[x][y] &amp;&amp; !check[x][y]) &#123; if (baby.size &gt; map[x][y] &amp;&amp; map[x][y] &gt; 0) &#123; prey.push(&#123; x, y &#125;); &#125; check[x][y] = true; q.push(&#123; x, y &#125;); &#125; &#125; &#125; if (!prey.empty()) &#123; while (!q.empty()) q.pop(); selectPrey(prey, q); time = part_time; memset(check, 0, sizeof(check)); &#125; &#125; isEnd = true;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); if (map[i][j] == 9) &#123; // 아기 상어 정보 baby.r = i; baby.c = j; baby.size = 2; &#125; &#125; &#125; while (!isEnd) &#123; findPrey(baby.r, baby.c); &#125; printf(\"%d\\n\", time); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 16235번 나무 재테크","slug":"Algorithm/BOJ/16235","date":"2020-01-25T08:03:54.000Z","updated":"2020-01-25T13:16:42.339Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/16235/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/16235/","excerpt":"","text":"#16235. 나무 재테크Problem 문제링크 Solution 시뮬레이션 문제이다. 봄, 여름, 가을, 겨울에 맞게 작업을 수행하면 된다. 단 한 칸에 여러 개의 나무가 존재할 수 있다는 점에 주목하자. 처음에 3차원 벡터로 해당 칸에 나무 정보를 저장하였지만 계절마다 작업을 수행할 때 상당히 비효율적이라 시간초과가 떴다. → 문제의 조건을 잘 보면 답이 보인다. (항상 느끼는 거지만 어떤 자료구조를 선택할지가 중요) 나이가 어린 나무부터 양분을 먹는다. (해당 칸에 있는 나무 정보를 순회할 때 어린 나무부터 접근해야 한다.) 나무 정보를 처음에 입력받을 때 한 칸에 하나씩만 받는다. 나무가 추가될 때 나이가 1인 나무가 추가된다. 나이가 클수록 먼저 죽음(나이만큼 양분을 먹기 때문이다.) 위 조건을 도합하면 deque 가 가장 적합하다. deque&lt;int&gt; tree[10][10]나이가 어린 나무가 앞에 즉, 오름차순으로 정렬되어 있어야 하는데, 처음에 각 칸에 하나씩 입력 받고 추가될 때 앞부분에 나무를 추가해주면 되기 때문이다. 죽는건 앞에서부터 탐색을 하다가 죽는 나무가 생기면 그 뒤부터 이미 죽은 나무가 되기에 죽을 나무 개수만 카운트하고 뒤에서부터 개수만큼 pop하면 되기 때문이다. 1 Try code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int N, M, K, ans, diff;int land[10][10];int A[10][10];int dx[8] = &#123; -1, -1, 0, 1, 1, 1, 0, -1 &#125;;int dy[8] = &#123; 0, -1, -1, -1, 0, 1, 1, 1 &#125;;vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; v;void Input() &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; for (int i = 0; i &lt; N; ++i) &#123; v.resize(N); for (int j = 0; j &lt; N; ++j) &#123; v[i].resize(N); cin &gt;&gt; A[i][j]; land[i][j] = 5; &#125; &#125; for (int i = 0; i &lt; M; ++i) &#123; int r, c, age; cin &gt;&gt; r &gt;&gt; c &gt;&gt; age; v[r-1][c-1].push_back(age); &#125;&#125;void Task() &#123; // 봄, 여름 for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (v[i][j].size() &gt; 1) sort(v[i][j].begin(), v[i][j].end()); int sum = 0; for (int k = 0; k &lt; v[i][j].size(); ++k) &#123; if (v[i][j][k] == 0) continue; if (land[i][j] - v[i][j][k] &lt; 0) &#123; sum += v[i][j][k] / 2; v[i][j][k] = 0; // 죽은 표시 diff++; &#125; else &#123; land[i][j] -= v[i][j][k]; v[i][j][k]++; &#125; &#125; land[i][j] += sum; &#125; &#125; // 가을, 겨울 for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; for (int k = 0; k &lt; v[i][j].size(); ++k) &#123; if (v[i][j][k] == 0) continue; if (v[i][j][k] % 5 == 0) &#123; for (int dir = 0; dir &lt; 8; ++dir) &#123; int r = i + dx[dir]; int c = j + dy[dir]; if (r &lt;= -1 || c &lt;= -1 || r &gt;= N || c &gt;= N) continue; v[r][c].push_back(1); &#125; &#125; &#125; land[i][j] += A[i][j]; &#125; &#125;&#125;int main() &#123; Input(); while (K--) &#123; Task(); &#125; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; ans += v[i][j].size(); &#125; &#125; ans -= diff; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; 시간초과 2 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;int N, M, K, ans;int land[10][10];int A[10][10];int dx[8] = &#123; -1, -1, 0, 1, 1, 1, 0, -1 &#125;;int dy[8] = &#123; 0, -1, -1, -1, 0, 1, 1, 1 &#125;;deque&lt;int&gt; tree[10][10];void Input() &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; ans = M; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; cin &gt;&gt; A[i][j]; land[i][j] = 5; &#125; &#125; for (int i = 0; i &lt; M; ++i) &#123; int r, c, age; cin &gt;&gt; r &gt;&gt; c &gt;&gt; age; tree[r - 1][c - 1].push_back(age); &#125;&#125;void Task() &#123; // 봄, 여름 for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (tree[i][j].empty()) continue; int sum = 0, dead_num = 0; for (auto iter = tree[i][j].begin(); iter != tree[i][j].end(); ++iter) &#123; if (land[i][j] - *iter &lt; 0) &#123; sum += (*iter) / 2; dead_num++; ans--; &#125; else &#123; land[i][j] -= (*iter); (*iter)++; &#125; &#125; for (int k = 0; k &lt; dead_num; ++k) tree[i][j].pop_back(); land[i][j] += sum; &#125; &#125; // 가을, 겨울 for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; for (auto iter = tree[i][j].begin(); iter != tree[i][j].end(); ++iter) &#123; if ((*iter) % 5 == 0) &#123; for (int dir = 0; dir &lt; 8; ++dir) &#123; int r = i + dx[dir]; int c = j + dy[dir]; if (r &lt;= -1 || c &lt;= -1 || r &gt;= N || c &gt;= N) continue; tree[r][c].push_front(1); ans++; &#125; &#125; &#125; land[i][j] += A[i][j]; &#125; &#125;&#125;int main() &#123; Input(); while (K--) &#123; Task(); &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 16234번 인구 이동","slug":"Algorithm/BOJ/16234","date":"2020-01-25T08:03:51.000Z","updated":"2020-01-25T13:16:42.331Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/16234/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/16234/","excerpt":"","text":"#16234. 인구 이동Problem 문제링크 Solution BFS N x N 크기의 배열을 전부 탐색하면서 check표시가 되어있지 않은 부분은 인구 이동이 가능한지 확인 작업이 수행된다. 작업 동안 누적 합과 연합에 포함된 나라 수를 계산해야 한다. queue가 비어있을 때까지 다음을 수행한다. 현재 위치에서 4방향 탐색 → 범위체크, 탐색할 위치가 미탐색인지 확인 탐색 가능하면 누적 합, 나라 수 계산, 종료되지 않게 flag 갱신, queue에 넣어준다. 만약 나라 수가 1보다 크면 누적합과 사람 수를 따로 저장한다. 위 작업이 끝나면 이제 따로 저장한 누적합과 사람 수를 이용해 N x N 크기의 배열을 바꿔준다. (실질적 인구 이동) 만약 flag가 false 즉, 인구이동이 없다면 종료한다. DFS BFS보다 훨씬 빠르고 깔끔하며 명료하다. 처음에 BFS로 할 생각을 했던 것은 N x N 크기의 배열 값을 미리 바꾸면 인구 이동에 영향을 미치게 된다는 생각에 코드를 작성했었는데 생각해보니 한 번 탐색이 끝나면(BFS든 DFS든) check 표시 되어 있기에 영향을 주지 않고 한 번 탐색할 때 위치만 미리 벡터에 저장해주면 된다. BFS 1 Try code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;tuple&gt; using namespace std;int N, L, R, idx, ans;bool no_end;int map[51][51];int check[51][51]; // 1, 2, 3int val[1251][2]; // 값, 사람 수int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; N &amp;&amp; y &lt; N) return true; return false;&#125;void movePeople(int r, int c) &#123; idx++; int sum = map[r][c], cnt = 1; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123; r, c &#125;); check[r][c] = idx; while (!q.empty()) &#123; int x, y; tie(x, y) = q.front(); q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (isBound(d_x, d_y) &amp;&amp; check[d_x][d_y] == 0) &#123; if (abs(map[x][y] - map[d_x][d_y]) &gt;= L &amp;&amp; abs(map[x][y] - map[d_x][d_y]) &lt;= R) &#123; check[d_x][d_y] = idx; q.push(&#123; d_x, d_y &#125;); no_end = true; cnt++; sum += map[d_x][d_y]; &#125; &#125; &#125; &#125; if (cnt &gt; 1) &#123; val[idx][0] = sum; val[idx][1] = cnt; &#125; else &#123; check[r][c] = 0; idx--; &#125;&#125;void changePeople() &#123; bool no_move = true; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (check[i][j] == 0) continue; map[i][j] = val[check[i][j]][0] / val[check[i][j]][1]; check[i][j] = 0; no_move = false; &#125; &#125; if (!no_move) ans++;&#125;int main() &#123; scanf(\"%d %d %d\", &amp;N, &amp;L, &amp;R); for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); &#125; &#125; do &#123; idx = 0; no_end = false; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (check[i][j] &gt; 0) continue; movePeople(i, j); &#125; &#125; changePeople(); &#125; while (no_end); printf(\"%d\\n\", ans); return 0;&#125; DFS 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int N, L, R, sum, ans;int map[51][51];bool check[51][51]; vector&lt;pair&lt;int, int&gt; &gt; v; // 위치 정보int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; N &amp;&amp; y &lt; N) return true; return false;&#125;void dfs(int x, int y) &#123; sum += map[x][y]; v.push_back(&#123; x, y &#125;); check[x][y] = true; for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (isBound(d_x, d_y) &amp;&amp; !check[d_x][d_y]) &#123; if (abs(map[x][y] - map[d_x][d_y]) &gt;= L &amp;&amp; abs(map[x][y] - map[d_x][d_y]) &lt;= R) &#123; dfs(d_x, d_y); &#125; &#125; &#125;&#125;bool task() &#123; bool change = false; memset(check, 0, sizeof(check)); for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (check[i][j]) continue; sum = 0; v.clear(); dfs(i, j); if (v.size() == 1) continue; for (auto e : v) &#123; map[e.first][e.second] = sum / v.size(); &#125; change = true; &#125; &#125; return change;&#125;int main() &#123; scanf(\"%d %d %d\", &amp;N, &amp;L, &amp;R); for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); &#125; &#125; while (task()) &#123; ans++; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 15686번 치킨 배달","slug":"Algorithm/BOJ/15686","date":"2020-01-25T08:03:46.000Z","updated":"2020-01-25T13:16:42.344Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/15686/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/15686/","excerpt":"","text":"#15686. 치킨 배달문제링크 Problem N x N 도시 0: 빈 칸, 1: 집, 2: 치킨 집 도시의 치킨 거리는 모든 집의 치킨 거리의 합 치킨 거리 ( 집: (r1, c1) 치킨집: (r2, c2) )집과 가장 가까운 치킨집 사이의 거리를 말한다. |r_1-r_2| +|c_1-c_2|Goal: 치킨집 중에서 최대 M개를 골랐을 때 도시의 치킨 거리 최솟값 Solution 치킨 집을 M개 고르는 모든 조합 구하기 해당 집을 고르면 배열에 넣고 아니면 넣지 않음1234567891011void combination(int idx) &#123; if (select_idx == m) &#123; BFS 이용하여 치킨 거리 구하기 return; &#125; if (idx == total_chicken) return; combination(idx + 1); // 선택하지 않기 select[select_idx++] = idx; combination(idx + 1); // 선택하기 select_idx--; // 다른 경우의 수를 위해 인덱스 빼주기 (중요)&#125;중요라고 되어있는 부분을 작성하지 않으면 모든 경우의 수를 구할 수 없다. 경우의 수가 꼬여버림. 4개 중에 2개를 고른다고 하면12345678comb(0) comb(1) comb(2) comb(3) ... 이런식으로 호출이 이루어지기에 (3, 2) 경우가 먼저 완성된다. 완성되고 BFS이용하여 치킨 거리 구하고 return되면 select_idx를 빼준다. 그럼 2자리에 다른 경우가 넣어질 수 있다. (3, 1) 각 조합에 대한 최소한의 치킨 거리 구하기 BFS를 이용하여 한 칸씩 갈 때 1초 증가 그러다 1을 만나면 해당 초를 더 해준다.BFS를 이용하면 동시에 1을 만나기에 time만 더해주어서는 안된다.동시에 발견한 집의 수만큼 time을 더해주어야 한다. 모든 1을 만났으면 종료123456789101112131415161718192021222324252627282930void bfs() &#123; int time = 0, house = 0, dist = 0; memset(check, 0, sizeof(check)); queue&lt;pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; select_idx; ++i) &#123; q.push(&#123; chicken[select[i]].r, chicken[select[i]].c &#125;); while (!q.empty()) &#123; time++; int cnt = 0; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); check[r][c] = true; for (int i = 0; i &lt; 4; ++i) &#123; int x = r + dx[i]; int y = c + dy[i]; if (isBound(x, y) &amp;&amp; !check[x][y]) &#123; check[x][y] = true; if (city[x][y] == 1) &#123; house++; cnt++; &#125; q.push(&#123; x, y &#125;); &#125; &#125; &#125; dist += time * cnt; // 해당 초에 만난 집의 수 만큼 이동거리 더해주기 &#125;&#125; 이 중 가장 최소인 치킨 거리 구하기 12345dist += time * cnt; // 해당 초에 만난 집의 수 만큼 이동거리 더해주기if (total_house == house) &#123; answer = answer &gt; dist ? dist : answer; return;&#125; 1 Try 컴파일 에러 (index라는 변수명은 기피하자…) select_idx로 변경 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX 51using namespace std;int n, m, total_chicken, total_house, index, answer;int city[MAX][MAX];bool check[MAX][MAX];int select[13];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;struct INFO &#123; int r, c;&#125;chicken[13];bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; n &amp;&amp; c &lt; n) return true; return false;&#125;void bfs() &#123; int time = 0, house = 0, dist = 0; memset(check, 0, sizeof(check)); queue&lt;pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; index; ++i) &#123; q.push(&#123; chicken[select[i]].r, chicken[select[i]].c &#125;); // 선택한 치킨집 queue에 저장 &#125; while (!q.empty()) &#123; time++; int cnt = 0; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); check[r][c] = true; for (int i = 0; i &lt; 4; ++i) &#123; int x = r + dx[i]; int y = c + dy[i]; if (isBound(x, y) &amp;&amp; !check[x][y]) &#123; check[x][y] = true; if (city[x][y] == 1) &#123; house++; cnt++; &#125; q.push(&#123; x, y &#125;); &#125; &#125; &#125; dist += time * cnt; // 해당 초에 만난 집의 수 만큼 이동거리 더해주기 if (total_house == house) &#123; answer = answer &gt; dist ? dist : answer; return; &#125; &#125;&#125;void combination(int idx) &#123; // M개를 선택하는 모든 경우의 수 구하기 if (index == m) &#123; bfs(); return; &#125; if (idx == total_chicken) return; combination(idx + 1); select[index++] = idx; combination(idx + 1); index--;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;city[i][j]); if (city[i][j] == 2) &#123; // 치킨집 정보 저장 chicken[total_chicken].r = i; chicken[total_chicken++].c = j; &#125; else if (city[i][j] == 1) total_house++; &#125; &#125; answer = 1e9; combination(0); printf(\"%d\\n\", answer); return 0;&#125; 2 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX 51using namespace std;int n, m, total_chicken, total_house, select_idx, answer;int city[MAX][MAX];bool check[MAX][MAX];int select[13];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;struct INFO &#123; int r, c;&#125;chicken[13];bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; n &amp;&amp; c &lt; n) return true; return false;&#125;void bfs() &#123; int time = 0, house = 0, dist = 0; memset(check, 0, sizeof(check)); queue&lt;pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; select_idx; ++i) &#123; q.push(&#123; chicken[select[i]].r, chicken[select[i]].c &#125;); // 선택한 치킨집 queue에 저장 &#125; while (!q.empty()) &#123; time++; int cnt = 0; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); check[r][c] = true; for (int i = 0; i &lt; 4; ++i) &#123; int x = r + dx[i]; int y = c + dy[i]; if (isBound(x, y) &amp;&amp; !check[x][y]) &#123; check[x][y] = true; if (city[x][y] == 1) &#123; house++; cnt++; &#125; q.push(&#123; x, y &#125;); &#125; &#125; &#125; dist += time * cnt; // 해당 초에 만난 집의 수 만큼 이동거리 더해주기 if (total_house == house) &#123; answer = answer &gt; dist ? dist : answer; return; &#125; &#125;&#125;void combination(int idx) &#123; // M개를 선택하는 모든 경우의 수 구하기 if (select_idx == m) &#123; bfs(); return; &#125; if (idx == total_chicken) return; combination(idx + 1); select[select_idx++] = idx; combination(idx + 1); select_idx--;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;city[i][j]); if (city[i][j] == 2) &#123; // 치킨집 정보 저장 chicken[total_chicken].r = i; chicken[total_chicken++].c = j; &#125; else if (city[i][j] == 1) total_house++; &#125; &#125; answer = 1e9; combination(0); printf(\"%d\\n\", answer); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 15685번 드래곤 커브","slug":"Algorithm/BOJ/15685","date":"2020-01-25T08:03:41.000Z","updated":"2020-01-25T13:16:42.337Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/15685/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/15685/","excerpt":"","text":"#15685. 드래곤 커브문제링크 Problem 좌표 평면 3가지 속성 시작 점 시작 방향0: x 좌표 증가 → 방향1: y 좌표 감소 ↑ 방향2: x 좌표 감소 ← 방향3: y 좌표 증가 ↓ 방향 세대 0세대: 길이가 1인 선분 1세대: 0세대 드래곤 커브 끝 점을 기준으로 시계 방향 90도 회전시켜 0세대 끝 점에 붙인 것 2세대: 1세대를 이용하여 1세대를 만든 것처럼 만든다. N세대: N-1세대 커브를 끝 점 기준으로 90도 시계 방향 회전시킨 것을 붙인 것 입력 드래곤 커브 개수 N (~20) x, y (드래곤 커브 시작 점) ~100 d (시작 방향) g (세대) ~10 드래곤 커브는 서로 겹칠 수 있다. Goal: 만들어진 드래곤 커브에서 정사각형 4개의 꼭짓점이 모두 드래곤 커브의 일부인 것의 개수를 구하기 (모양이 정사각형이 아니어도 4개의 꼭짓점만 만족하면 된다.) Solution 끝점을 기준으로 시계방향 90도를 했을 때 각 방향의 이동은 다음과 같다. 0 → 1 1 → 2 2 → 3 3 → 0 아래 그림 참고. 드래곤 커브를 그려주는 건 check 배열로 수행한다.(겹쳐도 되니까 초기화할 필요 없다.) 방향만 배열에 저장해주면 된다. 끝점에서 이동을 수행하니 위치 좌표는 끝점만 알면된다. 12345// input : 3 3 0 1(3, 3) : 처음 시작 위치(4, 3) : 0세대 // 위치 좌표: (4, 3) 방향 0(4, 2) : 1세대 // 위치 좌표: (4, 2) 방향 0, 1(3, 2), (3, 1) : 2세대 // 위치 좌표: (3, 2) -&gt; (3,1) 방향 0, 1, 2, 1 2세대 설명: 1세대에서 방향이 [0, 1]로 저장되어 있다. 끝점부터 시작하기에 방향 1이 시계방향으로 90도 회전하면 방향 2가 된다. [0, 1, 2]이후 0이 시계방향으로 90도 회전하면 방향 1이된다. [0, 1, 2, 1] 드래곤 커브 위의 규칙대로 그리기 0세대 까지 그려놓고 (0세대가 아니라면) 1세대부터 그린다. direction 배열에 위의 [0, 1, 2, 1]과 같은 값이 들어간다.123456789101112131415161718int clockwise[4] = &#123; 1, 2, 3, 0 &#125;;void draw(int x, int y, int d, int g) &#123; int idx = 0; check[y][x] = true; direction[idx++] = d; while(g--) &#123; int len = idx; for (int i = len-1; i &gt;= 0; --i) &#123; d = clockwise[direction[i]]; x += dx[d]; y += dy[d]; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; MAX &amp;&amp; y &lt; MAX) &#123; check[y][x] = true; &#125; direction[idx++] = d; &#125; &#125;&#125; 4개의 꼭짓점 확인 배열은 최대 100 x 100의 크기를 가지기에 0~99까지 check 값이 존재할 수 있다. (사실상 98까지만 확인하면 된다.) 1 1 (0, 0)을 기준으로 오른쪽, 아래, 오른쪽 아래 대각선만 확인하면 된다. 1 1 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#define MAX 101using namespace std;bool check[MAX][MAX];int clockwise[4] = &#123; 1, 2, 3, 0 &#125;;int dx[4] = &#123;1, 0, -1, 0&#125;;int dy[4] = &#123; 0, -1, 0, 1 &#125;;int direction[MAX*MAX];void draw(int x, int y, int d, int g) &#123; int idx = 0; check[y][x] = true; direction[idx++] = d; while(g--) &#123; int len = idx; for (int i = len-1; i &gt;= 0; --i) &#123; d = clockwise[direction[i]]; x += dx[d]; y += dy[d]; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; MAX &amp;&amp; y &lt; MAX) &#123; check[y][x] = true; &#125; direction[idx++] = d; &#125; &#125;&#125;int main() &#123; int n, x, y, d, g, answer = 0; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%d %d %d %d\", &amp;x, &amp;y, &amp;d, &amp;g); check[y][x] = true; x += dx[d]; y += dy[d]; draw(x, y, d, g); &#125; for (int i = 0; i &lt;= 99; ++i) &#123; for (int j = 0; j &lt;= 99; ++j) &#123; if (check[i][j]) &#123; if (check[i + 1][j] &amp;&amp; check[i][j + 1] &amp;&amp; check[i + 1][j + 1]) answer++; &#125; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 15684번 사다리 조작","slug":"Algorithm/BOJ/15684","date":"2020-01-25T08:03:38.000Z","updated":"2020-01-25T13:10:46.907Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/15684/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/15684/","excerpt":"","text":"#15684. 사다리 조작Problem 문제링크 Solution 처음에 감이 안잡혀서 어떻게 풀지 막막했었다. 입력값을 보고 사다리 정보를 어떤 식으로 저장할건지가 첫 스타트이자 포인트다.이렇게 data가 보여야 조합도 어떤식으로 구성할지 생각나기 때문이다. 작업은 2개로 나뉜다. 조합 구하기 사다리 타기 조합 구하기 조합을 구하기 전에 입력값이 어떻게 들어오나 확인해보자. a b가 입력되면 a행에 b열 사다리와 b+1열 사다리가 연결된다.이를 array[a][b] = 1(사다리 있음)으로 표시하면 b+1로 갈 수 있다는 뜻이다.반대로 b+1지점에서 array[a][b]값이 1인걸 확인하면 b로 갈 수 있다는 뜻이다. 이를 활용하여 조합을 구해보자. 모든 행의 1열부터 N-1열까지 탐색해야 한다.단, 현재 위치뿐만 아니라 자신의 왼쪽, 오른쪽도 확인해야 한다. (연속으로 설치하지 못하기 때문)123456789101112131415161행 1열 선택 시 다음 가능한 경우 (N에 표시하는 것은 의미 X - 입력값 생각) 1행 - 1(x), 2(x), 3 ... N-1 2행 - 1, 2, 3 ... N-1 ... H행 - 1, 2, 3 ... N-1for (int i = idx; i &lt;= H; ++i) &#123; for (int j = 1; j &lt; N; ++j) &#123; if (visit[i][j]) continue; // 현재 확인 if (j &gt; 1 &amp;&amp; visit[i][j - 1]) continue; // 왼쪽 확인 if (visit[i][j + 1]) continue; // 오른쪽 확인 visit[i][j] = true; // 선택 표시 selectAll(i, cnt + 1); // 다음 선택 visit[i][j] = false; &#125;&#125; 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;using namespace std;int N, M, H, ans;bool visit[31][11];void Input() &#123; ans = 4; cin &gt;&gt; N &gt;&gt; M &gt;&gt; H; for (int i = 0; i &lt; M; ++i) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; visit[a][b] = true; // a행 b - b+1 사다리 &#125;&#125;bool Check() &#123; for (int j = 1; j &lt;= N; ++j) &#123; int current_num = j; for (int i = 1; i &lt;= H; ++i) &#123; if (visit[i][current_num]) &#123; // 오른쪽 사다리로 이동 current_num++; &#125; else if (current_num &gt; 1 &amp;&amp; visit[i][current_num -1]) &#123; // 왼쪽 사다리로 이동 current_num--; &#125; &#125; if (current_num != j) return false; &#125; return true;&#125;void selectAll(int idx, int cnt) &#123; if (cnt &gt; ans) return; if (cnt == 4) &#123; return; &#125; if (Check()) &#123; if (ans &gt; cnt) ans = cnt; return; &#125; for (int i = idx; i &lt;= H; ++i) &#123; for (int j = 1; j &lt; N; ++j) &#123; // 5번 사다리는 확인할 필요 없다. (입력값 생각) if (visit[i][j]) continue; if (j &gt; 1 &amp;&amp; visit[i][j - 1]) continue; if (visit[i][j + 1]) continue; visit[i][j] = true; selectAll(i, cnt + 1); visit[i][j] = false; &#125; &#125;&#125;void Solve() &#123; Input(); selectAll(1, 0); if (ans == 4) ans = -1; cout &lt;&lt; ans &lt;&lt; \"\\n\";&#125;int main() &#123; Solve(); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 15683번 감시","slug":"Algorithm/BOJ/15683","date":"2020-01-25T08:03:35.000Z","updated":"2020-01-25T13:10:46.898Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/15683/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/15683/","excerpt":"","text":"#15683. 감시Problem 문제링크 Solution 설치된 CCTV 위치정보, 번호 얻기 설치된 CCTV 방향 정하기 (상하좌우: 0123)1번 cctv: 0, 1, 2, 32번 cctv: (0, 1), (2, 3)3번 cctv: (0, 3), (1, 3), (0, 2), (1, 2)4번 cctv: (2, 0, 3), (0, 3, 1), (2, 1, 3), (0, 2, 1)5번 cctv: (0, 1, 2, 3)묶음을 왼쪽에서부터 0, 1, 2, 3이라고 정하고 (여기서 5번은 0만 갖게된다.)selected 배열에 넣어준다.123456789101112131415161718void selectDirection(int idx, int cnt) &#123; if (cnt == cctv.size()) &#123; task(); // 방향대로 감시 시작 return; &#125; int type = cctv[idx].type; for (int i = 0; i &lt; 4; ++i) &#123; if (type == 2) &#123; // 2번 cctv는 최대 1 값만 가능 if (i == 2) break; &#125; if(type == 5) &#123; // 5번 cctv는 최대 0만 가능 if (i == 1) break; &#125; selected[idx] = i; selectDirection(idx + 1, cnt + 1); selected[idx] = -1; &#125;&#125; 선택된 방향대로 감시 시작 범위를 벗어나거나 벽을 만나면 감시를 중단한다. 그전까지는 정해진 방향대로 계속 check 표시를 한다. check는 check되어 있지 않고 맵의 값이 0인 경우에만 진행한다.탐색된 곳의 개수를 구하기 위해서이다. 전체 칸의 개수 - 탐색된 곳의 개수 - 벽의 개수 - cctv 개수 = 사각지대 개수 사각지대가 최소가 되도록 갱신한다. 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, m, wall_cnt, ans;int room[9][9];int selected[9];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;int type_two[2][2] = &#123;&#123;0, 1&#125;, &#123;2, 3&#125;&#125;;int type_three[4][2] = &#123; &#123;0, 3&#125;, &#123;1, 3&#125;, &#123;0, 2&#125;, &#123;1, 2&#125; &#125;;int type_four[4][3] = &#123; &#123;2, 0, 3&#125;, &#123;0, 3, 1&#125;, &#123;2, 1, 3&#125;, &#123;0, 2, 1&#125; &#125;;struct INFO &#123; int x, y, type;&#125;;vector&lt;INFO&gt; cctv;void init() &#123; for (int i = 0; i &lt; 9; ++i) selected[i] = -1; ans = 1e9; wall_cnt = 0;&#125;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; n &amp;&amp; y &lt; m) return true; return false;&#125;void task() &#123; bool check[9][9] = &#123; 0, &#125;; int type, res = 0; for (int i = 0; i &lt; cctv.size(); ++i) &#123; int dir = selected[i]; int x = cctv[i].x, y = cctv[i].y; int d_x, d_y; if (cctv[i].type == 1) &#123; d_x = x + dx[dir]; d_y = y + dy[dir]; while (isBound(d_x, d_y) &amp;&amp; room[d_x][d_y] != 6) &#123; if (!check[d_x][d_y] &amp;&amp; room[d_x][d_y] == 0) &#123; check[d_x][d_y] = true; res++; &#125; d_x += dx[dir]; d_y += dy[dir]; &#125; &#125; else if (cctv[i].type == 2) &#123; for (int j = 0; j &lt; 2; ++j) &#123; d_x = x + dx[type_two[dir][j]]; d_y = y + dy[type_two[dir][j]]; while (isBound(d_x, d_y) &amp;&amp; room[d_x][d_y] != 6) &#123; if (!check[d_x][d_y] &amp;&amp; room[d_x][d_y] == 0) &#123; check[d_x][d_y] = true; res++; &#125; d_x += dx[type_two[dir][j]]; d_y += dy[type_two[dir][j]]; &#125; &#125; &#125; else if (cctv[i].type == 3) &#123; for (int j = 0; j &lt; 2; ++j) &#123; d_x = x + dx[type_three[dir][j]]; d_y = y + dy[type_three[dir][j]]; while (isBound(d_x, d_y) &amp;&amp; room[d_x][d_y] != 6) &#123; if (!check[d_x][d_y] &amp;&amp; room[d_x][d_y] == 0) &#123; check[d_x][d_y] = true; res++; &#125; d_x += dx[type_three[dir][j]]; d_y += dy[type_three[dir][j]]; &#125; &#125; &#125; else if (cctv[i].type == 4) &#123; for (int j = 0; j &lt; 3; ++j) &#123; d_x = x + dx[type_four[dir][j]]; d_y = y + dy[type_four[dir][j]]; while (isBound(d_x, d_y) &amp;&amp; room[d_x][d_y] != 6) &#123; if (!check[d_x][d_y] &amp;&amp; room[d_x][d_y] == 0) &#123; check[d_x][d_y] = true; res++; &#125; d_x += dx[type_four[dir][j]]; d_y += dy[type_four[dir][j]]; &#125; &#125; &#125; else if (cctv[i].type == 5) &#123; for (int j = 0; j &lt; 4; ++j) &#123; d_x = x + dx[j]; d_y = y + dy[j]; while (isBound(d_x, d_y) &amp;&amp; room[d_x][d_y] != 6) &#123; if (!check[d_x][d_y] &amp;&amp; room[d_x][d_y] == 0) &#123; check[d_x][d_y] = true; res++; &#125; d_x += dx[j]; d_y += dy[j]; &#125; &#125; &#125; &#125; res = (n * m) - res - wall_cnt - cctv.size(); if (res &lt; ans) ans = res;&#125;void selectDirection(int idx, int cnt) &#123; if (cnt == cctv.size()) &#123; task(); return; &#125; int type = cctv[idx].type; for (int i = 0; i &lt; 4; ++i) &#123; if (type == 2) &#123; if (i == 2) break; &#125; if(type == 5) &#123; if (i == 1) break; &#125; selected[idx] = i; selectDirection(idx + 1, cnt + 1); selected[idx] = -1; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; init(); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; room[i][j]; if (room[i][j] &gt;= 1 &amp;&amp; room[i][j] &lt;= 5) &#123; cctv.push_back(&#123; i, j, room[i][j] &#125;); &#125; else if (room[i][j] == 6) wall_cnt++; &#125; &#125; selectDirection(0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 14891번 톱니바퀴","slug":"Algorithm/BOJ/14891","date":"2020-01-25T08:03:29.000Z","updated":"2020-01-25T13:10:46.906Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14891/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14891/","excerpt":"","text":"#14891. 톱니바퀴Problem 문제링크 Solution SWEA 모의 SW 역량 테스트 [특이한 자석](https://www.notion.so/doyuni/4013-e51a7fc5e88b4e2b999dba66b24f358b#ffc1b4f8b7b140a2a1f2e12a9f953f5b) 와 동일하다. 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;int magnatic[4][8];map&lt;int, int&gt; task;void rotate(int n, int dir) &#123; if (dir == 1) &#123; // 시계 방향 int first_ele = magnatic[n][7]; for (int i = 6; i &gt;= 0; --i) &#123; magnatic[n][i + 1] = magnatic[n][i]; &#125; magnatic[n][0] = first_ele; &#125; else if (dir == -1) &#123; // 반시계 방향 int last_ele = magnatic[n][0]; for (int i = 1; i &lt; 8; ++i) &#123; magnatic[n][i - 1] = magnatic[n][i]; &#125; magnatic[n][7] = last_ele; &#125;&#125;void checkRotate(int current_num, int prior_num, int dir) &#123; int count_dir = dir &gt; 0 ? -1 : 1; task.insert(&#123; current_num, dir &#125;); if (current_num == 0) &#123; if (prior_num != 1) &#123; if (magnatic[current_num][2] != magnatic[current_num + 1][6]) &#123; checkRotate(current_num + 1, current_num, count_dir); &#125; &#125; &#125; else if (current_num == 1) &#123; if (prior_num != 0) &#123; if (magnatic[current_num - 1][2] != magnatic[current_num][6]) &#123; checkRotate(current_num - 1, current_num, count_dir); &#125; &#125; if (prior_num != 2) &#123; if (magnatic[current_num][2] != magnatic[current_num + 1][6]) &#123; checkRotate(current_num + 1, current_num, count_dir); &#125; &#125; &#125; else if (current_num == 2) &#123; if (prior_num != 1) &#123; if (magnatic[current_num - 1][2] != magnatic[current_num][6]) &#123; checkRotate(current_num - 1, current_num, count_dir); &#125; &#125; if (prior_num != 3) &#123; if (magnatic[current_num][2] != magnatic[current_num + 1][6]) &#123; checkRotate(current_num + 1, current_num, count_dir); &#125; &#125; &#125; else if (current_num == 3) &#123; if (prior_num != 2) &#123; if (magnatic[current_num - 1][2] != magnatic[current_num][6]) &#123; checkRotate(current_num - 1, current_num, count_dir); &#125; &#125; &#125;&#125;int getScore() &#123; int ans = 0, score = 1; for (int n = 0; n &lt; 4; ++n) &#123; if (magnatic[n][0] == 1) &#123; ans += score; &#125; score *= 2; &#125; return ans;&#125;int main() &#123; for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 8; ++j) &#123; scanf(\"%1d\", &amp;magnatic[i][j]); &#125; &#125; int k; scanf(\"%d\", &amp;k); for (int i = 0; i &lt; k; ++i) &#123; int number, dir; scanf(\"%d %d\", &amp;number, &amp;dir); checkRotate(number - 1, -1, dir); for (auto e : task) &#123; rotate(e.first, e.second); &#125; task.clear(); &#125; printf(\"%d\\n\", getScore()); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 14890번 경사로","slug":"Algorithm/BOJ/14890","date":"2020-01-25T08:03:20.000Z","updated":"2020-01-25T13:10:46.916Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14890/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14890/","excerpt":"","text":"#14890. 경사로문제링크 Problem N x N 지도, 각 칸의 높이가 적힘 길은 한 행 또는 한 열 → 길에 속한 모든 칸의 높이가 모두 같아야 지나갈 수 있음 또는 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있음( 경사로 높이 1, 길이 L), 경사로 개수는 매우 많음 경사로 놓을 수 있는 경우 낮은 칸과 높은 칸의 차이가 1인 경우 L개의 칸이 같은 높이로 연속되게 있어야 한다. Solution한 행 맨 왼쪽에서부터 오른쪽으로 탐색한다. (첫 번째 원소부터 마지막 원소 바로 이전까지) 현재 탐색한 원소와 바로 다음 원소와의 차이를 구한다. +1인 경우다음 원소부터 경사로 길이만큼 오른쪽으로 탐색을 시작한다.탐색하면서 다음 경우를 확인한다.범위를 벗어날 경우(n이상) or 경사로 길이만큼 같은 높이가 아닐 때 종료그게 아니면 경사로를 놓는다. -1인 경우현재 원소부터 경사로 길이만큼 왼쪽으로 탐색을 시작한다.탐색하면서 다음 경우를 확인한다.범위를 벗어날 경우(0미만) or 경사로 길이만큼 같은 높이가 아닐 때 or 경사로가 놓여있을 때 종료그게 아니면 경사로를 놓는다. 차이가 1 초과 -1 미만인 경우 종료 그게 아니라면 성공 왼쪽에서 오른쪽으로 탐색하기에 한 열 또한 위와 마찬가지로 구현한다. 1 Try 하…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, len, ans;int map[101][101];bool check[101][101];bool checkRow(int row) &#123; for (int j = 0; j &lt; n - 1; ++j) &#123; if (map[row][j] - map[row][j + 1] == 1) &#123; for (int start = j + 1; start &lt;= j + len; ++start) &#123; if (start &gt;= n) return false; // 범위를 벗어나는 경우 if (map[row][j + 1] != map[row][start]) return false; // 칸의 높이가 같지 않을 때 check[row][start] = true; // 경사로 놓기 &#125; &#125; else if (map[row][j] - map[row][j + 1] == -1) &#123; for (int start = j; start &gt; j - len; --start) &#123; if (start &lt; 0) return false; // 범위를 벗어나는 경우 if (map[row][j] != map[row][start]) return false; if (check[row][start]) return false; check[row][start] = true; &#125; &#125; else if (map[row][j] - map[row][j + 1] &gt; 1 || map[row][j] - map[row][j + 1] &lt; -1) return false; &#125; return true;&#125;bool checkCol(int col) &#123; for (int i = 0; i &lt; n - 1; ++i) &#123; if (map[i][col] - map[i + 1][col] == 1) &#123; for (int start = i + 1; start &lt;= i + len; ++start) &#123; if (start &gt;= n) return false; if (map[i + 1][col] != map[start][col]) return false; check[start][col] = true; &#125; &#125; else if (map[i][col] - map[i + 1][col] == -1) &#123; for (int start = i; start &gt; i - len; --start) &#123; if (start &lt; 0) return false; if (map[i][col] != map[start][col]) return false; if (check[start][col]) return false; check[start][col] = true; &#125; &#125; else if (map[i][col] - map[i + 1][col] &gt; 1 || map[i][col] - map[i + 1][col] &lt; -1) return false; &#125;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;len); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); &#125; &#125; for (int row = 0; row &lt; n; ++row) &#123; if(checkRow(row)) ans++; &#125; memset(check, 0, sizeof(check)); for (int col = 0; col &lt; n; ++col) &#123; if (checkCol(col)) ans++; &#125; printf(\"%d\\n\", ans); return 0;&#125; checkCol 함수에 return true 즉 반환값을 넣어주지 않았기에 틀렸다고 나왔다. bool 함수는 반드시 true와 false 둘 다 반환해주자. 이걸 몰라서 계속 문제만 주구장창 봤음…ㅠ 2 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, len, ans;int map[101][101];bool check[101][101];bool checkRow(int row) &#123; for (int j = 0; j &lt; n - 1; ++j) &#123; if (map[row][j] - map[row][j + 1] == 1) &#123; for (int start = j + 1; start &lt;= j + len; ++start) &#123; if (start &gt;= n) return false; // 범위를 벗어나는 경우 if (map[row][j + 1] != map[row][start]) return false; // 칸의 높이가 같지 않을 때 check[row][start] = true; // 경사로 놓기 &#125; &#125; else if (map[row][j] - map[row][j + 1] == -1) &#123; for (int start = j; start &gt; j - len; --start) &#123; if (start &lt; 0) return false; if (map[row][j] != map[row][start]) return false; if (check[row][start]) return false; // 경사로가 이미 놓여진 경우 check[row][start] = true; &#125; &#125; else if (map[row][j] - map[row][j + 1] &gt; 1 || map[row][j] - map[row][j + 1] &lt; -1) return false; &#125; return true;&#125;bool checkCol(int col) &#123; for (int i = 0; i &lt; n - 1; ++i) &#123; if (map[i][col] - map[i + 1][col] == 1) &#123; for (int start = i + 1; start &lt;= i + len; ++start) &#123; if (start &gt;= n) return false; if (map[i + 1][col] != map[start][col]) return false; check[start][col] = true; &#125; &#125; else if (map[i][col] - map[i + 1][col] == -1) &#123; for (int start = i; start &gt; i - len; --start) &#123; if (start &lt; 0) return false; if (map[i][col] != map[start][col]) return false; if (check[start][col]) return false; check[start][col] = true; &#125; &#125; else if (map[i][col] - map[i + 1][col] &gt; 1 || map[i][col] - map[i + 1][col] &lt; -1) return false; &#125; return true;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;len); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); &#125; &#125; for (int row = 0; row &lt; n; ++row) &#123; if (checkRow(row)) ans++; &#125; memset(check, 0, sizeof(check)); for (int col = 0; col &lt; n; ++col) &#123; if (checkCol(col)) ans++; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 14889번 스타트와 링크","slug":"Algorithm/BOJ/14889","date":"2020-01-25T08:03:12.000Z","updated":"2020-01-25T13:10:46.915Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14889/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14889/","excerpt":"","text":"#14889. 스타트와 링크문제링크 Problem 총 N명 중 N/2명으로 두 팀을 만든다. (N은 짝수) Sij + Sji = 능력치 ( i번과 j번 사람이 같은 팀에 속했을 때) Goal: 두 팀의 능력치의 차이의 최솟값 Solution 먼저 두 팀을 나눠야 한다.1~N 중에 N/2를 골라 만들어야 하는데 중복X + 오름차순이어야 한다.12345678910111213void selectTeam(int idx, int cnt) &#123; if (cnt == n / 2) &#123; // 성공 조건 // 능력치 계산 &#125; if (idx &gt; n) return; // 실패 조건 for (int i = idx; i &lt;= n; ++i) &#123; if (selected[i] == 0) &#123; selected[i] = i; selectTeam(i+1, cnt + 1); selected[i] = 0; &#125; &#125;&#125; 1~20개의 번호를 담을 수 있는 selected 배열을 만든다. 선택 되면 선택된 번호의 값을 갖는다. 선택되지 않으면 0값을 갖는다. 중복 안되고, 오름차 순이기에 for문의 시작 조건을 위와 같이 한다. N/2 만큼 선택하면 능력치를 계산한다. 능력치 계산 링크팀: 0, 3, 5-&gt; 능력치(0, 3) (0, 5)(3, 0) (3, 5)(5, 0) (5, 3) 그렇기에 선택된 숫자를 기준으로 나머지 선택된 숫자 하나만 고르면 된다.123456i는 앞에 선택된 숫자 (i, j)for (int j = 1; j &lt;= n; ++j) &#123; if (selected[j] == 0 &amp;&amp; i != j) &#123; team_start += ability[i-1][j-1]; &#125;&#125; 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int n, ans;int ability[21][21];int selected[21];void getDifference() &#123; int team_start = 0; int team_link = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (selected[i] == 0) &#123; // 선택되지 않은 넘버가 다른 팀 for (int j = 1; j &lt;= n; ++j) &#123; if (selected[j] == 0 &amp;&amp; i != j) &#123; team_start += ability[i-1][j-1]; &#125; &#125; &#125; else &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (selected[j] != 0 &amp;&amp; i != j) &#123; team_link += ability[i - 1][j - 1]; &#125; &#125; &#125; &#125; unsigned int diff = abs(team_start - team_link); if (ans &gt; diff) ans = diff;&#125;void selectTeam(int idx, int cnt) &#123; if (cnt == n / 2) &#123; getDifference(); &#125; if (idx &gt; n) return; for (int i = idx; i &lt;= n; ++i) &#123; if (selected[i] == 0) &#123; selected[i] = i; selectTeam(i+1, cnt + 1); selected[i] = 0; &#125; &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;ability[i][j]); &#125; &#125; ans = 1e9; selectTeam(1, 0); printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 14503번 로봇 청소기","slug":"Algorithm/BOJ/14503","date":"2020-01-25T08:03:07.000Z","updated":"2020-01-25T13:10:46.913Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14503/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14503/","excerpt":"","text":"#14503. 로봇 청소기문제링크 Problem N x M 크기, 벽 또는 빈칸, 모든 외곽은 벽 청소기는 바라보는 방향이 있음(상하좌우) 작동 현재 위치 청소 현재 방향을 기준으로 왼쪽부터 탐색왼쪽에 청소하지 않은 공간이 있으면 그 방향으로 회전, 1칸 전진, 1번 진행없다면, 그 방향으로 회전 2번 진행상하좌우 모두 청소 되어 있거나 벽이라면, 방향 유지한 채 한 칸 후진 후 2번 진행 ( 현재 위치에서 4방향 다 청소나 벽일 때 현재 방향 유지한 채 후진)바로 위의 경우에서 뒤쪽이 벽이라 후진도 못 하는 경우 작동 종료 Goal: 로봇 청소기가 청소하는 칸의 개수 출력 방향: 0 → 위, 1 → 우, 2 → 아래, 3 → 왼 Solution시뮬레이션 문제이다. 각 순서에 맞게 잘 구현하면 된다. 현재 탐색 지점의 값이 0이라면 청소하는 칸의 개수 1 증가 후 2로 표시 최대 5번 방향을 바꾸게 된다. (자신으로 돌아오는 것까지 포함) 0(위쪽) → 3(왼쪽) 1(오른쪽) → 0(위쪽) 2(아래쪽) → 1(오른쪽) 3(왼쪽) → 2(아래쪽) 위는 현재 방향에 따른 왼쪽 방향(다음 탐색 방향)이다. 현재 방향을 토대로 다음 방향을 결정하고 다음 방향에 맞는 좌표를 구한다. 탐색 가능하면(값이 0이면) 현재 방향을 이 방향으로 바꾸고 좌표를 바꾸고 반복문 종료 탐색 불가능하면 현재 방향만 이 방향으로 바꾼다. 처음 방향과 같게 나오면(5번째일 경우) 후진이 가능한지 조사한다.가능하면 좌표만 바꿔주고 아니면 시뮬레이션을 종료한다.12345678910111213141516171819202122for (int i = 0; i &lt; 5; ++i) &#123; int next_dir = left_dir[current_dir]; if (i == 4) &#123; int back_x = x + dx[back_dir[dir]]; int back_y = y + dy[back_dir[dir]]; if (map[back_x][back_y] == 1) return; else &#123; x = back_x; y = back_y; break; &#125; &#125; int d_x = x + dx[next_dir]; int d_y = y + dy[next_dir]; if (map[d_x][d_y] == 0) &#123; dir = next_dir; x = d_x; y = d_y; break; &#125; else &#123; current_dir = next_dir; &#125;&#125; 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;int n, m, ans;int map[51][51];int left_dir[4] = &#123; 3, 0, 1, 2 &#125;;int back_dir[4] = &#123; 2, 3, 0, 1 &#125;;int dx[4] = &#123; -1, 0, 1, 0 &#125;;int dy[4] = &#123; 0, 1, 0, -1 &#125;;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; n &amp;&amp; y &lt; m) return true; return false;&#125;void cleanMap(int x, int y, int dir) &#123; while (true) &#123; if (map[x][y] == 0) ans++; map[x][y] = 2; int current_dir = dir; for (int i = 0; i &lt; 5; ++i) &#123; int next_dir = left_dir[current_dir]; if (i == 4) &#123; int back_x = x + dx[back_dir[dir]]; int back_y = y + dy[back_dir[dir]]; if (map[back_x][back_y] == 1) return; else &#123; x = back_x; y = back_y; break; &#125; &#125; int d_x = x + dx[next_dir]; int d_y = y + dy[next_dir]; if (map[d_x][d_y] == 0) &#123; dir = next_dir; x = d_x; y = d_y; break; &#125; else &#123; current_dir = next_dir; &#125; &#125; &#125;&#125;int main() &#123; int start_x, start_y, dir; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; start_x &gt;&gt; start_y &gt;&gt; dir; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; cleanMap(start_x, start_y, dir); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 14502번 연구소","slug":"Algorithm/BOJ/14502","date":"2020-01-25T08:03:04.000Z","updated":"2020-01-25T13:10:46.910Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14502/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14502/","excerpt":"","text":"#14502. 연구소문제링크 Problem N x M 크기, 빈 칸(0), 벽(1), 바이러스(2) 존재 바이러스는 상하좌우 빈칸으로만 움직임 벽을 꼭 3개 세워야 한다. Goal: 벽을 3개 세운 뒤, 얻을 수 있는 안전 영역 크기의 최댓값안전 영역은 벽 3개 세운 뒤 0의 개수 Solution 벽을 3개 세우는 경우의 수를 모두 구한다. (브루트 포스 - 재귀) 1234567891011void buildWall(int idx, int cnt) &#123; if (cnt == 3) &#123; spreadVirus(); return; &#125; if (idx == zero_point.size()) return; buildWall(idx + 1, cnt); wall[cnt].x = zero_point[idx].first; wall[cnt].y = zero_point[idx].second; buildWall(idx + 1, cnt+1);&#125; 0인 지점을 저장해놓은 벡터에서 3개를 선택하도록 한다. 원래의 map은 보존해야 하므로 새로운 배열에 복사를 해놓고 위에서 구한 경우의 수에 맞게 벽을 세운다.1234copyMap(); // 새로운 배열(tmp)에 복사for (int i = 0; i &lt; 3; ++i) &#123; tmp[wall[i].x][wall[i].y] = 1;&#125; 벽을 세운 새로운 map에서 바이러스가 퍼지도록 한다. (BFS) 123456789101112131415161718192021222324252627void spreadVirus() &#123; // 2번째 작업 // 아래부터 3번째 작업 queue&lt;pair&lt;int, int&gt; &gt; q; for (int i = 0; i &lt; total_virus; ++i) &#123; q.push(&#123; virus[i].x, virus[i].y &#125;); &#125; int minus_safe_area = 3; while (!q.empty()) &#123; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (isBound(d_x, d_y) &amp;&amp; tmp[d_x][d_y] == 0) &#123; q.push(&#123; d_x, d_y &#125;); tmp[d_x][d_y] = 2; minus_safe_area++; &#125; &#125; &#125; &#125; if (ans &lt; safe_area - minus_safe_area) ans = safe_area - minus_safe_area;&#125; BFS 탐색이 끝나면 queue가 비워지게 되므로, 다음 탐색을 위해 바이러스 위치를 저장해놓을 배열이 필요하다는 것에 주의한다. 안전영역 크기 = 원래 map의 0의 개수 - 벽 3개 - 모두 퍼진 바이러스 수 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int n, m, ans, safe_area, total_virus;int tmp[9][9];vector&lt;vector&lt;int&gt; &gt; map;vector&lt;pair&lt;int, int&gt; &gt; zero_point;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;struct INFO &#123; int x, y;&#125;wall[3], virus[10];bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; n &amp;&amp; y &lt; m) return true; return false;&#125;void copyMap() &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; tmp[i][j] = map[i][j]; &#125; &#125;&#125;void spreadVirus() &#123; copyMap(); for (int i = 0; i &lt; 3; ++i) &#123; tmp[wall[i].x][wall[i].y] = 1; &#125; queue&lt;pair&lt;int, int&gt; &gt; q; for (int i = 0; i &lt; total_virus; ++i) &#123; q.push(&#123; virus[i].x, virus[i].y &#125;); &#125; int minus_safe_area = 3; while (!q.empty()) &#123; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (isBound(d_x, d_y) &amp;&amp; tmp[d_x][d_y] == 0) &#123; q.push(&#123; d_x, d_y &#125;); tmp[d_x][d_y] = 2; minus_safe_area++; &#125; &#125; &#125; &#125; if (ans &lt; safe_area - minus_safe_area) ans = safe_area - minus_safe_area;&#125;void buildWall(int idx, int cnt) &#123; if (cnt == 3) &#123; spreadVirus(); return; &#125; if (idx == zero_point.size()) return; buildWall(idx + 1, cnt); wall[cnt].x = zero_point[idx].first; wall[cnt].y = zero_point[idx].second; buildWall(idx + 1, cnt+1);&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; map.resize(n); for (int i = 0; i &lt; n; ++i) &#123; map[i].resize(m); for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; map[i][j]; if (map[i][j] == 0) zero_point.push_back(&#123; i, j &#125;); else if (map[i][j] == 2) &#123; virus[total_virus].x = i; virus[total_virus++].y = j; &#125; &#125; &#125; safe_area = zero_point.size(); buildWall(0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 14499번 주사위 굴리기","slug":"Algorithm/BOJ/14499","date":"2020-01-25T08:02:56.000Z","updated":"2020-01-25T13:10:46.912Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14499/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14499/","excerpt":"","text":"#14499. 주사위 굴리기문제링크 Problem N x M 지도 위에 주사위 하나 오른쪽(동), 위쪽(북) 주사위 위치는 (x, y) 모든 면에 0 적혀 있음 지도에는 정수가 쓰여있고주사위가 이동한 칸에 쓰여 있는 수가 0이면 주사위 바닥면 수가 지도로 복사0이 아니면 지도위에 쓰여 있는 수가 주사위 바닥면으로 복사, 지도에 쓰여 있는 수는 0이 된다. Goal: 주사위가 이동했을 때마다 주사위의 윗 면에 쓰여 있는 수를 출력범위를 벗어나는 명령이면 움직이지 않고 출력도 하지 않는다. 1: 오른쪽, 2: 왼쪽, 3: 위쪽, 4: 아래쪽으로 이동한다. Solution 주사위 6면의 정보를 가지고 있어야 한다.12345struct INFO &#123; int up = 0, down = 0, front = 0, back = 0, left = 0, right = 0; int x, y;&#125;dice;// 윗면, 아랫면, 앞면, 뒷면, 왼면, 오른면 주사위를 움직일 때 6면의 정보가 방향에 맞게 업데이트 되어야 한다. 먼저 범위를 검사하고 검사한 후에 주사위 위치를 변경해준다. 오른쪽 이동위 → 오른 → 아래 → 왼 → 위 왼쪽 이동위 → 왼 → 아래 → 오른 → 위 위쪽 이동위 → 뒤 → 아래 → 앞 → 위 아래쪽 이동위 → 앞 → 아래 → 뒤 → 위 값을 제대로 업데이트 하기 위해서 사이클이 시작되기 전 값을 저장해놓고 순서대로 덮어씌우는 방식으로 값을 갱신한다.1234567891011121314151617181920212223242526272829303132333435void moveDice(int dir) &#123; int d_x = dice.x + dx[dir - 1]; int d_y = dice.y + dy[dir - 1]; if (isBound(d_x, d_y)) &#123; dice.x = d_x; dice.y = d_y; int tmp = 0; if (dir == 1) &#123; // right tmp = dice.left; dice.left = dice.down; dice.down = dice.right; dice.right = dice.up; dice.up = tmp; &#125; else if (dir == 2) &#123; // left tmp = dice.right; dice.right = dice.down; dice.down = dice.left; dice.left = dice.up; dice.up = tmp; &#125; else if (dir == 3) &#123; // up tmp = dice.front; dice.front = dice.down; dice.down = dice.back; dice.back = dice.up; dice.up = tmp; &#125; else if (dir == 4) &#123; // down tmp = dice.back; dice.back = dice.down; dice.down = dice.front; dice.front = dice.up; dice.up = tmp; &#125;&#125; 움직였을 때 지도의 칸이 0이면, 주사위 바닥면 수 → 지도 지도의 칸이 0이 아니면, 지도 → 주사위 바닥면 수 &amp; 0 → 지도123456if (map[dice.x][dice.y] == 0) map[dice.x][dice.y] = dice.down;else &#123; dice.down = map[dice.x][dice.y]; map[dice.x][dice.y] = 0;&#125;cout &lt;&lt; dice.up &lt;&lt; \"\\n\"; // 윗면 출력 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, m;vector&lt;vector&lt;int&gt; &gt; map;int dx[4] = &#123; 0, 0, -1, 1 &#125;;int dy[4] = &#123; 1, -1, 0, 0 &#125;;struct INFO &#123; int up = 0, down = 0, front = 0, back = 0, left = 0, right = 0; int x, y;&#125;dice;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; n &amp;&amp; y &lt; m) return true; return false;&#125;void moveDice(int dir) &#123; int d_x = dice.x + dx[dir-1]; int d_y = dice.y + dy[dir-1]; if (isBound(d_x, d_y)) &#123; dice.x = d_x; dice.y = d_y; int tmp = 0; if (dir == 1) &#123; // right tmp = dice.left; dice.left = dice.down; dice.down = dice.right; dice.right = dice.up; dice.up = tmp; &#125; else if (dir == 2) &#123; // left tmp = dice.right; dice.right = dice.down; dice.down = dice.left; dice.left = dice.up; dice.up = tmp; &#125; else if (dir == 3) &#123; // up tmp = dice.front; dice.front = dice.down; dice.down = dice.back; dice.back = dice.up; dice.up = tmp; &#125; else if (dir == 4) &#123; // down tmp = dice.back; dice.back = dice.down; dice.down = dice.front; dice.front = dice.up; dice.up = tmp; &#125; if (map[dice.x][dice.y] == 0) map[dice.x][dice.y] = dice.down; else &#123; dice.down = map[dice.x][dice.y]; map[dice.x][dice.y] = 0; &#125; cout &lt;&lt; dice.up &lt;&lt; \"\\n\"; &#125;&#125;int main() &#123; int start_x, start_y, k, dir; cin &gt;&gt; n &gt;&gt; m &gt;&gt; start_x &gt;&gt; start_y &gt;&gt; k; dice.x = start_x; dice.y = start_y; map.resize(n); for (int i = 0; i &lt; n; ++i) &#123; map[i].resize(m); for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; for (int i = 0; i &lt; k; ++i) &#123; cin &gt;&gt; dir; moveDice(dir); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 14226번 이모티콘","slug":"Algorithm/BOJ/14226","date":"2020-01-25T08:02:49.000Z","updated":"2020-01-25T13:10:46.908Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14226/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14226/","excerpt":"","text":"#14226. 이모티콘Problem 문제링크 Solution 화면에 있는 이모티콘 모두 클립보드에 저장 클립보드에 있는 이모티콘 화면에 붙여넣기 화면에 있는 이모티콘 하나 삭제 클립보드에 이모티콘이 하나라도 있어야 2번 작업 가능 화면에 이모티콘이 하나라도 있어야 3번 작업 가능 1번 작업은 언제나 수행 가능 2번 작업은 화면에 있는 이모티콘 + 클립보드 이모티콘이 목표(만들어야 할 이모티콘 수)이하여야 한다. 3번 작업은 화면에 있는 이모티콘 - 1이 0이상이어야 한다. (목표 이모티콘 최소 수가 2이기에 1이상이어도 상관 없다.) 각 작업은 1초로 동일한 시간이 걸리기에 BFS로 해결한다. queue에는 &lt;화면에 있는 이모티콘 수, 클립보드에 있는 이모티콘 수&gt;가 저 중복되지 않도록 dist라는 배열에 [화면][클립보드] 첨자를 이용해 시간을 저장한다. 1 Try123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;tuple&gt;using namespace std;queue&lt;pair&lt;int, int&gt;&gt; q;int dist[1001][1001];int main() &#123; int n; cin &gt;&gt; n; q.push(&#123; 1, 0 &#125;); while (!q.empty()) &#123; int s, c; tie(s, c) = q.front(); q.pop(); if (dist[s][s] == 0) &#123; // 화면에 있는 이모티콘 클립보드에 복사 dist[s][s] = dist[s][c] + 1; q.push(&#123; s, s &#125;); &#125; if (s+c &lt;= n &amp;&amp; dist[s+c][c] == 0) &#123; // 클립보드 화면에 붙여넣기 dist[s + c][c] = dist[s][c] + 1; q.push(&#123; s + c, c &#125;); &#125; if (s - 1 &gt;= 0 &amp;&amp; dist[s - 1][c] == 0) &#123; // 화면에 있는 이모티콘 -1 dist[s - 1][c] = dist[s][c] + 1; q.push(&#123; s - 1, c &#125;); &#125; &#125; int ans = 1e9; for (int i = 0; i &lt;= n; ++i) &#123; // 최솟값 찾기 if (ans &gt; dist[n][i] &amp;&amp; dist[n][i] != 0) ans = dist[n][i]; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 13913번 숨바꼭질 4","slug":"Algorithm/BOJ/13913","date":"2020-01-25T08:02:43.000Z","updated":"2020-01-25T13:10:46.904Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/13913/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/13913/","excerpt":"","text":"#13913. 숨바꼭질 4Problem 문제링크 Solution BFS 탐색을 하되, 경로를 알고 있어야 하기에 path[to] = from 을 사용한다. 즉, 5→6→8→10 이라면 path[10]에는 8, path[8]에는 6이 저장되어 있다. 경로를 출력하기 위해 재귀함수를 사용한다. 1234(5, 10) 4. 출력 (5, 8) 3. 출력 (5, 6) 2. 출력 (5, 5) 1. 출력 1 Try code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define MAX 100000using namespace std;int N, K;bool end_flag;int dist[MAX+1];vector&lt;int&gt; path;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void Input() &#123; cin &gt;&gt; N &gt;&gt; K;&#125;void PrintPath() &#123; for (auto e : path) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; \"\\n\";&#125;void BFS() &#123; queue&lt;int&gt; q; q.push(N); while (!q.empty()) &#123; int n = q.front(); q.pop(); if (n == K) return; if (n &gt; 0 &amp;&amp; dist[n - 1] == 0) &#123; dist[n - 1] = dist[n] + 1; q.push(n - 1); &#125; if (n &lt; MAX &amp;&amp; dist[n + 1] == 0) &#123; dist[n + 1] = dist[n] + 1; q.push(n + 1); &#125; if (2 * n &lt;= MAX &amp;&amp; dist[2 * n] == 0) &#123; dist[2 * n] = dist[n] + 1; q.push(2 * n); &#125; &#125;&#125;void DFS(int n, int cnt) &#123; if (end_flag == true) return; if (dist[K] == cnt &amp;&amp; n == K) &#123; cout &lt;&lt; dist[K] &lt;&lt; \"\\n\"; PrintPath(); end_flag = true; return; &#125; if (dist[K] == cnt) return; if (n &gt; 0) &#123; path.push_back(n - 1); DFS(n - 1, cnt + 1); path.pop_back(); &#125; if (n &lt; MAX) &#123; path.push_back(n +1); DFS(n + 1, cnt + 1); path.pop_back(); &#125; if (2 * n &lt;= MAX) &#123; path.push_back(2 * n); DFS(2 * n, cnt + 1); path.pop_back(); &#125;&#125;void Solve() &#123; BFS(); path.push_back(N); DFS(N, 0);&#125;int main() &#123; Input(); Solve(); return 0;&#125; BFS + DFS로 구하니 시간초과 (BFS로 depth를 구하고 그 depth만큼 DFS를 수행하도록 하였다.) 2 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define MAX 100000using namespace std;int N, K;int dist[MAX + 1];int path[MAX + 1];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void Input() &#123; cin &gt;&gt; N &gt;&gt; K;&#125;void PrintPath(int from, int to) &#123; if (from != to) &#123; PrintPath(from, path[to]); &#125; cout &lt;&lt; to &lt;&lt; \" \";&#125;void BFS() &#123; queue&lt;int&gt; q; q.push(N); while (!q.empty()) &#123; int n = q.front(); q.pop(); if (n == K) return; if (n &gt; 0 &amp;&amp; dist[n - 1] == 0) &#123; dist[n - 1] = dist[n] + 1; path[n - 1] = n; q.push(n - 1); &#125; if (n &lt; MAX &amp;&amp; dist[n + 1] == 0) &#123; dist[n + 1] = dist[n] + 1; path[n + 1] = n; q.push(n + 1); &#125; if (2 * n &lt;= MAX &amp;&amp; dist[2 * n] == 0) &#123; dist[2 * n] = dist[n] + 1; path[2 * n] = n; q.push(2 * n); &#125; &#125;&#125;void Solve() &#123; BFS(); cout &lt;&lt; dist[K] &lt;&lt; \"\\n\"; PrintPath(N, K);&#125;int main() &#123; Input(); Solve(); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 13460번 구슬 탈출 2","slug":"Algorithm/BOJ/13460","date":"2020-01-25T08:02:37.000Z","updated":"2020-01-25T12:56:58.640Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/13460/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/13460/","excerpt":"","text":"#13460. 구슬 탈출 2Problem 문제링크 Solution 시뮬레이션 문제이다. 어떤 방향으로 기울일지 정해야 한다. (모든 경우를 구해야 한다. - 재귀 사용)이전 방향과 반대되는 방향으로 이동할 필요는 없다. 맵을 갱신할 필요는 없고 구슬의 위치만 변경하면 된다. 각 경우마다 구슬의 위치를 다음 작업에 넘겨주어야 한다. (재귀 함수 인자로 넘기기) 기울이기 재귀함수123456789101112131415161718Move(이동 횟수, 이전 방향, 빨간 구슬 위치, 파란 구슬 위치) if 이동 횟수 &gt; 10 return if 파란 구슬이 구멍에 들어간 경우 return if 빨간 구슬만 구멍에 들어간 경우 최솟값 갱신 return 4 방향 이동 벽이 아닐 때까지, 구멍 일 때까지 이동 // 빨간 구슬 이동 // 파란 구슬 이동 이동이 끝나면 if 위치가 겹칠 때 if 구멍이면 Move(이동 횟수 + 1, 방향, 위치) else 같은 행일 때 같은 열일 때 위치 이동 Move(이동횟수 +1, 방향, 위치) else Move(이동횟수 +1, 방향, 위치) 빨간 구슬이 방향에 맞게 이동하고, 그 후 파란 구슬이 이동한다. 구멍에 들어갔거나 같은 행이거나 같은 열이면 위치가 같게 된다. 이때 방향과 처음 위치에 맞게 방향을 바꿔준다. 갱신이 끝났으면 재귀함수를 호출해준다. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;using namespace std;int N, M, ans = 1e9;int g_x, g_y;char board[11][11];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;int count_dir[4] = &#123; 1, 0, 3, 2 &#125;;struct Red &#123; int x, y;&#125;;struct Blue &#123; int x, y;&#125;;void Move(int cnt, int prior_dir, Red r, Blue b) &#123; if (cnt &gt; 10) return; if (b.x == g_x &amp;&amp; b.y == g_y) return; // 파란 구슬 구멍 통과 if (r.x == g_x &amp;&amp; r.y == g_y) &#123; // 빨간 구슬만 구멍 통과 if (ans &gt; cnt) ans = cnt; return; &#125; for (int dir = 0; dir &lt; 4; ++dir) &#123; Red nr = &#123; r.x, r.y &#125;; Blue nb = &#123; b.x, b.y &#125;; // next if (prior_dir != -1 &amp;&amp; count_dir[prior_dir] == dir) continue; while (true) &#123; if (board[nr.x + dx[dir]][nr.y + dy[dir]] == '#') break; nr.x += dx[dir]; nr.y += dy[dir]; if (board[nr.x][nr.y] == 'O') break; &#125; while (true) &#123; if (board[nb.x + dx[dir]][nb.y + dy[dir]] == '#') break; nb.x += dx[dir]; nb.y += dy[dir]; if (board[nb.x][nb.y] == 'O') break; &#125; if (nr.x == nb.x &amp;&amp; nr.y == nb.y) &#123; // 겹칠 때 if (board[nr.x][nr.y] == 'O') Move(cnt + 1, dir, nr, nb); else &#123; if (r.x == b.x) &#123; // 같은 행 if (r.y &lt; b.y) &#123; // R B if (dir == 2) nb.y++; else if (dir == 3) nr.y--; &#125; else &#123; // B R if (dir == 2) nr.y++; else if (dir == 3) nb.y--; &#125; &#125; else if (r.y == b.y) &#123; // 같은 열 if (r.x &lt; b.x) &#123; // R이 B보다 위 if (dir == 0) nb.x++; else if (dir == 1) nr.x--; &#125; else &#123; // R이 B보다 아래 if (dir == 0) nr.x++; else if (dir == 1) nb.x--; &#125; &#125; Move(cnt + 1, dir, nr, nb); &#125; &#125; else &#123; Move(cnt + 1, dir, nr, nb); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M; Red r; Blue b; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; cin &gt;&gt; board[i][j]; if (board[i][j] == 'O') &#123; g_x = i; g_y = j; &#125; else if (board[i][j] == 'R') &#123; r.x = i; r.y = j; &#125; else if (board[i][j] == 'B') &#123; b.x = i; b.y = j; &#125; &#125; &#125; Move(0, -1, r, b); if (ans == 1e9) cout &lt;&lt; -1 &lt;&lt; \"\\n\"; else cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; 문제 풀고나서 찾아본 깔끔한 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;int n, m;int rx, ry, bx, by;char a[11][11];int ans = 11;void go(int rx, int ry, int bx, int by, int mx, int my, int cnt)&#123; if (cnt &gt;= ans) return; int rm = 0, bm = 0; if (mx != my)&#123; while (a[bx + mx][by + my] - '#')&#123; bx += mx; by += my; bm++; if (!(a[bx][by] - 'O')) return; &#125; while (a[rx + mx][ry + my] - '#')&#123; rx += mx; ry += my; rm++; if (!(a[rx][ry] - 'O'))&#123; ans = ans &lt; cnt ? ans : cnt; return; &#125; &#125; &#125; if (rx == bx &amp;&amp; ry == by) if (rm &lt; bm) bx -= mx, by -= my; else rx -= mx, ry -= my; if (mx == 0)&#123; go(rx, ry, bx, by, 1, 0, cnt + 1); go(rx, ry, bx, by, -1, 0, cnt + 1); &#125; if (my == 0)&#123; go(rx, ry, bx, by, 0, 1, cnt + 1); go(rx, ry, bx, by, 0, -1, cnt + 1); &#125;&#125;int main()&#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf(\"%s\", a[i]); for (int i = 1; i &lt; n - 1; i++)&#123; for (int j = 1; j &lt; m - 1; j++)&#123; if (a[i][j] == 'R') rx = i, ry = j; if (a[i][j] == 'B') bx = i, by = j; &#125; &#125; go(rx, ry, bx, by, 0, 0, 0); printf(\"%d\", ans &lt; 11 ? ans : -1);&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 12851번 숨바꼭질 2","slug":"Algorithm/BOJ/12851","date":"2020-01-25T08:02:32.000Z","updated":"2020-01-25T12:55:53.699Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/12851/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/12851/","excerpt":"","text":"#12851. 숨바꼭질 2Problem 문제링크 Solution 방법의 수를 구하는 것이 추가가 되었다. 이는 DP를 활용하여 구한다. 방문하지 않은 경로라면 방법의 수는 그대로 유지 방문한 경우 + 거리 차이가 1인 경우에만 방법의 수+1거리 차이가 1인 경우에만 최소비용을 만족하는 경로이기 때문이다. 1 Try1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;queue&gt;#define MAX 100000using namespace std;int N, K;queue&lt;int&gt; q;bool visit[MAX+1];int dist[MAX + 1];int cnt[MAX + 1];void BFS() &#123; q.push(N); visit[N] = true; dist[N] = 0; cnt[N] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int next : &#123;x - 1, x + 1, x * 2&#125;) &#123; if (0 &lt;= next &amp;&amp; next &lt;= MAX) &#123; if (!visit[next]) &#123; visit[next] = true; dist[next] = dist[x] + 1; cnt[next] = cnt[x]; q.push(next); &#125; else if (dist[next] == dist[x] + 1) &#123; cnt[next] += cnt[x]; &#125; &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; K; BFS(); cout &lt;&lt; dist[K] &lt;&lt; \"\\n\" &lt;&lt; cnt[K] &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 12100번 2048(Easy)","slug":"Algorithm/BOJ/12100","date":"2020-01-25T08:02:27.000Z","updated":"2020-01-25T12:50:39.911Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/12100/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/12100/","excerpt":"","text":"#12100. 2048(Easy)문제링크 Problem N x N 크기의 보드판 한 번의 이동 : 보드판에 있는 모든 블록 상하좌우 중 한 방향으로 쭉 이동단순히 한 칸이 아닌 해당 방향 이동할 수 있는 곳 끝까지 같은 값을 가진 블록이 충돌하면 하나로 합쳐짐(한 번 합쳐지면 다시 합칠 수 없음 → 한 번 이동할 때 연속으로 합쳐질 수 없음 2개 → 1개인 경우만 존재)블록이 합쳐지면 해당 블록의 숫자를 더한 값이 된다. Goal: 최대 5번 이동해서 만들 수 있는 가장 큰 블록의 값 구하기 입력 N: ~20 0: 빈칸 2^i(i= 1, 2…10): 블록 // 적어도 하나 주어짐 Solution 최대 5번 이동이니 한 번 이동하면서 최대 블록 값을 갱신해주어야 한다.(꼭 안그래도 되겠지만) 5번 이동하는 조합을 구한다. 그 이동에 맞게 블록을 이동시킨다. 해당 번째의 방향을 저장할 배열을 이용해 5개의 방향을 저장해놓고, 모두 저장했을 때 보드판을 움직이도록 한다.1234567891011121314151617void dfs(int idx) &#123; if (idx == 5) &#123; // 방향 5개가 저장되었을 때 for (int i = 0; i &lt; n; ++i) &#123; // 입력값인 temp를 board로 옮기고 작업을 수행한다. for (int j = 0; j &lt; n; ++j) &#123; board[i][j] = temp[i][j]; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; moveBlock(해당 방향); &#125; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; direction[idx] = i; dfs(idx+1); &#125;&#125; moveBlock() 블럭 이동 움직이는 방향이 좌우면 한 행의 열이 바뀌면서 board위의 블럭들이 바뀐다.이때 좌로 이동하면 오른쪽부터 탐색, 우로 이동하면 왼쪽부터 탐색해야 한다. 움직이는 방향이 상하일 때도 위와 같은 방식이다. 이를 잘 구분해주어 update할 때 행, 열의 인덱스를 반영한다. update() 아래 코드는 좌우로 이동할 때 블럭들을 갱신하는 함수다.12345678910111213141516171819202122232425void updateCol(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[i][j] == 0) &#123; // 0의 위치 zero.push(j); &#125; else if (board[i][j] != 0 &amp;&amp; board[i][j] == value) &#123; // 블럭 값이 같을 때 value = 0; // 한 번에 한 번만 합치도록 0으로 초기화 board[i][value_idx] *= 2; answer = max(answer, board[i][value_idx]); board[i][j] = 0; zero.push(j); &#125; else if (board[i][j] != 0) &#123; value_idx = j; value = board[i][j]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[i][j] = 0; board[i][zero_idx] = value; zero.push(j); value_idx = zero_idx; // 변경 &#125; &#125;&#125; 3가지 경우를 확인하고 각 작업을 수행한다. 블럭이 없는 빈 곳: queue에 해당 위치를 넣어준다. (블럭을 옮길 때 쓰임) 합칠 대상이 되는 블럭: 이전에 저장해놓은 블럭 값과 같으면 합칠 수 있다.이전에 저장해놓은 블럭의 값을 2배로 하고 합칠 대상이 되는 블럭은 0으로 바꾼뒤 이 위치를 queue에 넣어준다. 합쳐질 가능성이 있는 블럭: 이 값은 나중에 합쳐질 수 있으므로 해당 값과 위치를 저장해 놓는다.단, queue가 비어있지 않다면 이 블럭의 위치를 옮겨주어야 하기에 queue에서 pop한 0의 위치로 해당 블럭 값을 넣어준다.이렇게 되면 바뀌기 전 블럭은 0이 되고 이 위치를 다시 queue에 넣어주어야 한다.마지막으로 위치가 바뀐 지점을 갱신해주면 된다. 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define MAX 20using namespace std;int n, value, value_idx, zero_idx, answer = 2;int board[MAX][MAX];int temp[MAX][MAX];int direction[5]; // 방향 조합 0:상, 1:하, 2:좌, 3:우void updateCol(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[i][j] == 0) &#123; // 0의 위치 zero.push(j); &#125; else if (board[i][j] != 0 &amp;&amp; board[i][j] == value) &#123; // 블럭 값이 같을 때 value = 0; // 한 번에 한 번만 합치도록 0으로 초기화 board[i][value_idx] *= 2; answer = max(answer, board[i][value_idx]); board[i][j] = 0; if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[i][zero_idx] = value; &#125; zero.push(j); &#125; else if (board[i][j] != 0) &#123; value_idx = j; value = board[i][j]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[i][j] = 0; board[i][zero_idx] = value; zero.push(j); &#125; &#125;&#125;void updateRow(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[j][i] == 0) &#123; // 0의 위치 zero.push(j); &#125; else if (board[j][i] != 0 &amp;&amp; board[j][i] == value) &#123; // 블럭 값이 같을 때 value = 0; // 한 번에 한 번만 합치도록 0으로 초기화 board[value_idx][i] *= 2; answer = max(answer, board[value_idx][i]); board[j][i] = 0; if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[zero_idx][i] = value; &#125; zero.push(j); &#125; else if (board[j][i] != 0) &#123; value_idx = j; value = board[j][i]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[j][i] = 0; board[zero_idx][i] = value; zero.push(j); &#125; &#125;&#125;void moveBlock(int move) &#123; for (int i = 0; i &lt; n; ++i) &#123; queue&lt;int&gt; zero; value = 0; value_idx = 0; zero_idx = 0; if (move % 2 == 0) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (move == 0) &#123; updateRow(i, j, zero); &#125; else &#123; updateCol(i, j, zero); &#125; &#125; &#125; else &#123; for (int j = n-1; j &gt;= 0; --j) &#123; if (move == 1) &#123; updateRow(i, j, zero); &#125; else &#123; updateCol(i, j, zero); &#125; &#125; &#125; &#125;&#125;void dfs(int idx) &#123; if (idx == 5) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; board[i][j] = temp[i][j]; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; moveBlock(direction[i]); &#125; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; direction[idx] = i; dfs(idx+1); &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;temp[i][j]); &#125; &#125; dfs(0); printf(\"%d\\n\", answer); return 0;&#125; 위의 코드가 틀린 Test case 7 2 2 2 2 2 2 2 2 0 2 2 2 2 2 2 0 2 2 2 2 2 2 0 2 2 2 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 0 2 2 2 2 2 2 0 -&gt; 32 // output 디버깅용 코드를 보면 알겠지만 방향을 3(오른쪽)으로 했을 때 board의 블럭들을 확인해보니실제로 잘 합쳐지지 않았던 것이다. (solution에는 정답 코드를 반영) 위 코드의 빨간 줄을 없애주었다. 합쳐지면 0이 있는 곳을 찾아 넣는 작업을 하면 안되기 때문이다. 이 블럭은 합쳐졌고, 이 위치는 0으로 채우고 이 인덱스를 queue에 넣어주기만 하면 된다. queue가 비어있지 않다면 해당 지점에 블럭을 놓는 작업이 있는데이때, value_idx = zero_idx 를 추가해주어야 해당 블럭의 바뀐 위치도 알 수 있다.이를 추가하지 않으면 바뀌기 전 위치가 남아있어 합쳐지지 않는다. Debug 코드 보기123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define MAX 20using namespace std;int n, value, value_idx, zero_idx, answer = 2;int board[MAX][MAX];int temp[MAX][MAX];int direction[5]; // 방향 조합 0:상, 1:하, 2:좌, 3:우void updateCol(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[i][j] == 0) &#123; // 0의 위치 zero.push(j); &#125; else if (board[i][j] != 0 &amp;&amp; board[i][j] == value) &#123; // 블럭 값이 같을 때 value = 0; // 한 번에 한 번만 합치도록 0으로 초기화 board[i][value_idx] *= 2; answer = max(answer, board[i][value_idx]); board[i][j] = 0; zero.push(j); &#125; else if (board[i][j] != 0) &#123; value_idx = j; value = board[i][j]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[i][j] = 0; board[i][zero_idx] = value; zero.push(j); value_idx = zero_idx; // 변경 &#125; &#125; //printf(\"%d-%d번재: \\n\", i, j); //for (int i = 0; i &lt; n; ++i) &#123; // for (int j = 0; j &lt; n; ++j) &#123; // printf(\"%d \", board[i][j]); // &#125; // printf(\"\\n\"); //&#125;&#125;void updateRow(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[j][i] == 0) &#123; // 0의 위치 zero.push(j); &#125; else if (board[j][i] != 0 &amp;&amp; board[j][i] == value) &#123; // 블럭 값이 같을 때 value = 0; // 한 번에 한 번만 합치도록 0으로 초기화 board[value_idx][i] *= 2; answer = max(answer, board[value_idx][i]); board[j][i] = 0; zero.push(j); &#125; else if (board[j][i] != 0) &#123; value_idx = j; value = board[j][i]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[j][i] = 0; board[zero_idx][i] = value; zero.push(j); value_idx = zero_idx; // 변경 &#125; &#125;&#125;void moveBlock(int move) &#123; for (int i = 0; i &lt; n; ++i) &#123; queue&lt;int&gt; zero; value = 0; value_idx = 0; zero_idx = 0; if (move % 2 == 0) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (move == 0) &#123; updateRow(i, j, zero); &#125; else &#123; updateCol(i, j, zero); &#125; &#125; &#125; else &#123; for (int j = n-1; j &gt;= 0; --j) &#123; if (move == 1) &#123; updateRow(i, j, zero); &#125; else &#123; updateCol(i, j, zero); &#125; &#125; &#125; &#125;&#125;void dfs(int idx) &#123; if (idx == 5) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; board[i][j] = temp[i][j]; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; moveBlock(direction[i]); &#125; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; direction[idx] = i; dfs(idx+1); &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;temp[i][j]); &#125; &#125; //dfs(0); direction[0] = 3; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; board[i][j] = temp[i][j]; &#125; &#125; moveBlock(direction[0]) printf(\"\\n\"); printf(\"%d\\n\", answer); return 0;&#125; 2 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define MAX 20using namespace std;int n, value, value_idx, zero_idx, answer = 2;int board[MAX][MAX];int temp[MAX][MAX];int direction[5]; // 방향 조합 0:상, 1:하, 2:좌, 3:우void updateCol(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[i][j] == 0) &#123; // 0의 위치 zero.push(j); &#125; else if (board[i][j] != 0 &amp;&amp; board[i][j] == value) &#123; // 블럭 값이 같을 때 value = 0; // 한 번에 한 번만 합치도록 0으로 초기화 board[i][value_idx] *= 2; answer = max(answer, board[i][value_idx]); board[i][j] = 0; zero.push(j); &#125; else if (board[i][j] != 0) &#123; value_idx = j; value = board[i][j]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[i][j] = 0; board[i][zero_idx] = value; zero.push(j); value_idx = zero_idx; // 변경 &#125; &#125;&#125;void updateRow(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[j][i] == 0) &#123; // 0의 위치 zero.push(j); &#125; else if (board[j][i] != 0 &amp;&amp; board[j][i] == value) &#123; // 블럭 값이 같을 때 value = 0; // 한 번에 한 번만 합치도록 0으로 초기화 board[value_idx][i] *= 2; answer = max(answer, board[value_idx][i]); board[j][i] = 0; zero.push(j); &#125; else if (board[j][i] != 0) &#123; value_idx = j; value = board[j][i]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[j][i] = 0; board[zero_idx][i] = value; zero.push(j); value_idx = zero_idx; // 변경 &#125; &#125;&#125;void moveBlock(int move) &#123; for (int i = 0; i &lt; n; ++i) &#123; queue&lt;int&gt; zero; value = 0; value_idx = 0; zero_idx = 0; if (move % 2 == 0) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (move == 0) &#123; updateRow(i, j, zero); &#125; else &#123; updateCol(i, j, zero); &#125; &#125; &#125; else &#123; for (int j = n-1; j &gt;= 0; --j) &#123; if (move == 1) &#123; updateRow(i, j, zero); &#125; else &#123; updateCol(i, j, zero); &#125; &#125; &#125; &#125;&#125;void dfs(int idx) &#123; if (idx == 5) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; board[i][j] = temp[i][j]; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; moveBlock(direction[i]); &#125; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; direction[idx] = i; dfs(idx+1); &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;temp[i][j]); &#125; &#125; dfs(0); printf(\"%d\\n\", answer); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 11729번 하노이 탑 이동 순서","slug":"Algorithm/BOJ/11729","date":"2020-01-25T08:02:10.000Z","updated":"2020-01-25T12:47:56.227Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/11729/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/11729/","excerpt":"","text":"#11729. 하노이 탑 이동 순서Problem N개의 원판 첫 번째 장대 → 세 번째 장대 한 번에 한 개의 원판만 다른 탑으로 이동 가능 원판 위 &lt; 원판 아래 원판 이동 순서 최소화 Solution굳이 이를 최소화시키는 방법을 생각하기보다 컴퓨터가 알아서 최소의 방법을 계산하도록 하자. → 하노이 탑도 알고리즘이 존재 먼저 하나의 원판만 있을 때를 생각해보자 보조 기둥 필요없이 바로 목표 기둥으로 이동하면 된다.1234567// recursive framevoid move(원반 개수, 시작, 보조, 목표) &#123; &#125;if(원반의 개수 == 1) &#123; 시작-&gt;목표 return;&#125;원반의 개수가 1보다 클때는 어떻게 해야 할까? 가장 큰 원반을 제외한 모든 원반이 보조 기둥에 있어야 한다. → 이게 포인트 12// 맨 아래에 있는 원반을 제외한 모든 원반을 보조 기둥으로 옮긴다.move(원반개수-1, 시작, 목표, 보조); // 시작 -&gt; 보조그러면 가장 큰 원반은 이 부분이 적용된다.1234if(원반의 개수 == 1) &#123; 시작-&gt;목표 return;&#125;가장 큰 원반이 목표 기둥으로 이동하였고, 이제 이 원반은 없는 것으로 보아도 무방하다. 나머지 원반들이 모든 기둥을 이동할 수 있기 때문이다. 그러면 이제 다시 n-1개의 원반을 가지고 위와 같은 작업을 진행한다.이때는 원래 보조 기둥을 시작 기둥으로, 시작 기둥을 보조 기둥으로 생각해야 한다. 1move(원반개수-1, 보조, 시작, 목표);Recursive frame의 내용을 완성해보자.123456789void move(int count, int start, int temp, int goal) &#123; if(count == 1) &#123; // start -&gt; goal return; &#125; move(count-1, start, goal, temp); // start-&gt;temp // start -&gt; goal move(count-1, temp, start, goal); // temp-&gt;goal&#125;주석으로 되어 있는 부분은 실질적으로 어떤 기둥에서 어떤 기둥으로 원반이 움직였는지를 나타내는 부분이다. 좀 더 깊은 이해를 위해 원반의 개수가 3개일 때 재귀함수 호출 순서를 작성하였다.1234567891011121314move(3, 1, 2, 3) move(2, 1, 3, 2) // 1, 2번 원반이 2번 기둥으로 가는 과정 move(1, 1, 2, 3) 1에서 3으로 이동 (1번 원반) 1에서 2로 이동 (2번 원반) move(1, 3, 1, 2) 3에서 2로 이동(1번 원반) 1에서 3으로 이동(3번 원반) move(2, 2, 1, 3) // 1, 2번 원반이 3번 기둥으로 가는 과정 move(1, 2, 3, 1) 2에서 1로 이동(1번 원반) 2에서 3으로 이동(2번 원반) move(1, 1, 2, 3) 1에서 3으로 이동 (1번 원반) 전체 코드123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; answer;void move(int count, int start, int temp, int goal) &#123; if(count == 1) &#123; answer.push_back(make_pair(start, goal)); return; &#125; move(count-1, start, goal, temp); // start-&gt;temp answer.push_back(make_pair(start, goal)); move(count-1, temp, start, goal); // temp-&gt;goal&#125;int main() &#123; int n; cin &gt;&gt; n; move(n, 1, 2, 3); cout &lt;&lt; answer.size() &lt;&lt; \"\\n\"; for(auto v : answer) &#123; cout &lt;&lt; v.first &lt;&lt; \" \" &lt;&lt; v.second &lt;&lt; \"\\n\"; &#125; return 0;&#125; 이동 횟수부터 출력해야 하므로, pair를 만들어 vector에 넣어주었다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 11651번 좌표 정렬하기 2","slug":"Algorithm/BOJ/11651","date":"2020-01-25T08:02:05.000Z","updated":"2020-01-25T12:42:24.520Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/11651/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/11651/","excerpt":"","text":"#11651. 좌표 정렬하기 2Problem 2차원 평면 위의 점 N개 y좌표 증가 순으로 정렬 같다면 x좌표 증가 순으로 정렬 즉, y좌표 오름차순(같다면 x좌표 오름차순)으로 정렬하는 문제이다. Solution 2차원 vector에 (y, x)를 담는다. → 정렬 때문 sort함수를 사용 (위 문제 조건처럼 정렬된다.) 출력은 거꾸로 한다. iostream 헤더 파일의 cin과 cout을 쓰면 시간초과 되기에 cstdio를 사용하였다.1234567891011121314151617181920212223#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; positions;int main() &#123; int n, x, y; scanf(\" %d\", &amp;n); positions.resize(n); for(int i = 0; i &lt; n; ++i) &#123; scanf(\" %d %d\", &amp;x, &amp;y); positions[i].push_back(y); positions[i].push_back(x); &#125; sort(positions.begin(), positions.end()); for(auto v : positions) &#123; for(int i = v.size()-1; i &gt;= 0; --i) &#123; printf(\"%d \", v[i]); &#125; printf(\"\\n\"); &#125; return 0;&#125; 92ms가 상당히 빠른 것은 아니기에 다른 최적의 정렬 방법이 있을지도 모른다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 11650번 좌표 정렬하기","slug":"Algorithm/BOJ/11650","date":"2020-01-25T08:01:58.000Z","updated":"2020-01-25T12:33:43.318Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/11650/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/11650/","excerpt":"","text":"#11650. 좌표 정렬하기문제링크 Problem 2차원 평면 (x, y) x 오름차순 정렬 x가 같다면 y 오름차순 정렬 Solution 를 pair를 사용하여 저장한다. pair를 사용하여 정렬하면 위 문제의 조건대로 정렬된다. 1 Try12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n, x, y; vector&lt;pair&lt;int, int&gt; &gt; answer; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; answer.push_back(make_pair(x, y)); &#125; sort(answer.begin(), answer.end()); for(auto ans : answer) &#123; cout &lt;&lt; ans.first &lt;&lt; \" \" &lt;&lt; ans.second &lt;&lt; '\\n'; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 11559번 Puyo Puyo","slug":"Algorithm/BOJ/11559","date":"2020-01-25T04:30:32.000Z","updated":"2020-01-25T08:58:11.135Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/11559/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/11559/","excerpt":"","text":"#11559. Puyo Puyo문제링크 Problem 뿌요는 바닥이나 다른 뿌요가 있을 때까지 아래로 떨어짐 뿌요가 놓여지고 같은 색 뿌요가 4개 이상 상하좌우로 연결되어 있으면연결된 같은 색 뿌요들이 모두 사라진다. 위 과정이 반복되면 1연쇄씩 늘어난다. (터지는 그룹이 동시에 여럿이라도 1연쇄) 입력 12*6의 문자 .은 빈공간 이외 뿌요 색깔 R, G, B, P, Y 뿌요들이 전부 아래로 떨어진 뒤의 상태가 주어짐 Goal: 몇 연쇄가 되는지 출력, 안터지면 0 출력 Solution다음과 같은 과정이 일어난다. 현재 map에서 터뜨릴 수 있는 것들 터뜨리기 아래로 떨어뜨리기 위 과정 반복하기(더이상 터뜨릴 수 없는 경우 종료) 터뜨리기 BFS를 활용하여 4개 이상 연속인지 확인을 한다. void bfs(현재 위치) 탐색용도 queue와 지울(터뜨릴)용도 queue 선언 현재 위치 넣어주고, check 탐색용도 queue를 전부 비울 때까지 탐색 탐색이 끝나면(더이상 갈 때가 없는 것) 지울 용도의 queue 크기가 4이상이면 터뜨리기 bfs 탐색이 끝나면 다음과 같이 4개 연속인 것들 터뜨리기 12345678void changeMap(queue&lt;pair&lt;int, int&gt;&gt; &amp;erase) &#123; while (!erase.empty()) &#123; int r = erase.front().first; int c = erase.front().second; erase.pop(); map[r][c] = '.'; &#125;&#125; 이 과정이 모든 map의 각 행과 열에서 이루어지면 그때 아래로 떨어뜨린다.(모든 위치에서 BFS탐색이 끝난 경우) 아래로 떨어뜨리기 Queue를 이용하여 맨 아래에서 부터 위로 탐색을 시작하여 . 인 지점을 순서대로 넣어준다. . 이 아니라면 queue에 들어간 순서대로 위치를 교환한다.1234567891011121314151617void update() &#123; for (int i = 0; i &lt; 6; ++i) &#123; queue&lt;pair&lt;int, int&gt;&gt; point; for (int j = 11; j &gt;= 0; --j) &#123; if (map[j][i] == '.') point.push(&#123; j, i &#125;); else &#123; if (point.empty()) continue; int x = point.front().first; int y = point.front().second; point.pop(); map[x][y] = map[j][i]; map[j][i] = '.'; point.push(&#123; j, i &#125;); &#125; &#125; &#125;&#125; 1 Try 틀린 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;char map[12][6];bool check[12][6];int answer, len;bool flag, loop = true;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; 12 &amp;&amp; c &lt; 6) return true; return false;&#125;void update() &#123; for (int i = 0; i &lt; 6; ++i) &#123; queue&lt;pair&lt;int, int&gt;&gt; point; for (int j = 11; j &gt;= 0; --j) &#123; if (map[j][i] == '.') point.push(&#123; j, i &#125;); else &#123; if (point.empty()) continue; int x = point.front().first; int y = point.front().second; point.pop(); map[x][y] = map[j][i]; map[j][i] = '.'; point.push(&#123; j, i &#125;); &#125; &#125; &#125;&#125;void changeMap(queue&lt;pair&lt;int, int&gt;&gt; erase) &#123; while (!erase.empty()) &#123; int r = erase.front().first; int c = erase.front().second; erase.pop(); map[r][c] = '.'; &#125;&#125;void dfs(int r, int c, queue&lt;pair&lt;int, int&gt;&gt; erase) &#123; check[r][c] = true; erase.push(&#123; r, c &#125;); bool flag = false; for (int i = 0; i &lt; 4; ++i) &#123; int x = r + dx[i]; int y = c + dy[i]; if (isBound(x, y) &amp;&amp; !check[x][y] &amp;&amp; map[x][y] == map[r][c] &amp;&amp; map[r][c] != '.') &#123; check[x][y] = true; flag = true; erase.push(&#123; x, y &#125;); len++; dfs(x, y, erase); &#125; &#125; if (!flag &amp;&amp; len &gt;= 4) &#123; loop = true; changeMap(erase); &#125;&#125;int main() &#123; for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; scanf(\" %c\", &amp;map[i][j]); &#125; &#125; queue&lt;pair&lt;int, int&gt;&gt; erase; while (loop) &#123; loop = false; memset(check, 0, sizeof(check)); for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; if (map[i][j] != '.' &amp;&amp; !check[i][j]) &#123; len = 1; dfs(i, j, erase); &#125; &#125; &#125; if (loop) &#123; update(); answer++; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; DFS로 하니까 map에서 연속인 것들을 제대로 지우지 못 한다는 것을 깨닫고(실제 값 확인해보면 erase queue에 연속적으로 못 넣고 return하게 됨) BFS를 사용하여 쉽게 풀었다..(진작에 할걸) 2 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;char map[12][6];bool check[12][6];bool loop = true;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; 12 &amp;&amp; c &lt; 6) return true; return false;&#125;void update() &#123; for (int i = 0; i &lt; 6; ++i) &#123; queue&lt;pair&lt;int, int&gt;&gt; point; for (int j = 11; j &gt;= 0; --j) &#123; if (map[j][i] == '.') point.push(&#123; j, i &#125;); else &#123; if (point.empty()) continue; int x = point.front().first; int y = point.front().second; point.pop(); map[x][y] = map[j][i]; map[j][i] = '.'; point.push(&#123; j, i &#125;); &#125; &#125; &#125;&#125;void changeMap(queue&lt;pair&lt;int, int&gt;&gt; &amp;erase) &#123; while (!erase.empty()) &#123; int r = erase.front().first; int c = erase.front().second; erase.pop(); map[r][c] = '.'; &#125;&#125;void bfs(int r, int c)&#123; queue&lt;pair&lt;int, int&gt;&gt; q, erase; q.push(&#123; r, c &#125;); erase.push(&#123; r, c &#125;); check[r][c] = true; while (!q.empty()) &#123; int length = q.size(); for (int i = 0; i &lt; length; ++i) &#123; r = q.front().first; c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; !check[x][y] &amp;&amp; map[x][y] == map[r][c] &amp;&amp; map[x][y] != '.') &#123; check[x][y] = true; q.push(&#123; x, y &#125;); erase.push(&#123; x, y &#125;); &#125; &#125; &#125; &#125; if (erase.size() &gt;= 4) &#123; loop = true; changeMap(erase); &#125;&#125;int main() &#123; for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; scanf(\" %c\", &amp;map[i][j]); &#125; &#125; int answer = 0; while (loop) &#123; loop = false; memset(check, 0, sizeof(check)); for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; if (map[i][j] != '.' &amp;&amp; !check[i][j]) &#123; bfs(i, j); &#125; &#125; &#125; if (loop) &#123; update(); answer++; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; Debug 디버깅용 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;char map[12][6];bool check[12][6];int answer;bool loop = true;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; 12 &amp;&amp; c &lt; 6) return true; return false;&#125;void update() &#123; for (int i = 0; i &lt; 6; ++i) &#123; queue&lt;pair&lt;int, int&gt;&gt; point; for (int j = 11; j &gt;= 0; --j) &#123; if (map[j][i] == '.') point.push(&#123; j, i &#125;); else &#123; if (point.empty()) continue; int x = point.front().first; int y = point.front().second; point.pop(); map[x][y] = map[j][i]; map[j][i] = '.'; point.push(&#123; j, i &#125;); &#125; &#125; &#125; /*printf(\"start\\n\"); for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; printf(\"%c\", map[i][j]); &#125; printf(\"\\n\"); &#125;*/&#125;void changeMap(queue&lt;pair&lt;int, int&gt;&gt; &amp;erase) &#123; //printf(\"erase\\n\"); while (!erase.empty()) &#123; int r = erase.front().first; int c = erase.front().second; //printf(\"%d %d\\n\", r, c); erase.pop(); map[r][c] = '.'; &#125;&#125;void bfs(int r, int c)&#123; queue&lt;pair&lt;int, int&gt;&gt; q, erase; q.push(&#123; r, c &#125;); erase.push(&#123; r, c &#125;); check[r][c] = true; while (!q.empty()) &#123; int length = q.size(); for (int i = 0; i &lt; length; ++i) &#123; r = q.front().first; c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; !check[x][y] &amp;&amp; map[x][y] == map[r][c] &amp;&amp; map[x][y] != '.') &#123; check[x][y] = true; q.push(&#123; x, y &#125;); erase.push(&#123; x, y &#125;); &#125; &#125; &#125; &#125; if (erase.size() &gt;= 4) &#123; loop = true; changeMap(erase); &#125;&#125;int main() &#123; for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; scanf(\" %c\", &amp;map[i][j]); &#125; &#125; while (loop) &#123; loop = false; memset(check, 0, sizeof(check)); for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; if (map[i][j] != '.' &amp;&amp; !check[i][j]) &#123; bfs(i, j); &#125; &#125; &#125; if (loop) &#123; update(); answer++; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; 디버깅용 Test case 1. output : 14Y..... B..... R.R... G.R... YG.... YBR..Y RR...Y YYRBRB YRBGBB GBRBGR GBRBGR GBRBGR 2. output : 1...... ...... ...... ...... ...... ...... ...... ...... R..... ...... RRYYGG RRYYGG 3. output: 2...... ..R... ..R.GG ...GG. ..R... ...... ..R... ...... R..... ....G. RRY..G RRYYGG","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 11047번 동전 0","slug":"Algorithm/BOJ/11047","date":"2020-01-25T04:23:59.000Z","updated":"2020-01-25T08:58:11.151Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/11047/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/11047/","excerpt":"","text":"#11047. 동전 0문제링크 Problem 동전의 종류 N 동전을 적절히 사용해 합을 K로 만드려고 한다. Goal: K를 만드는데 필요한 동전 개수의 최솟값 구하기 Solution 동전의 가치는 오름차순으로 주어지고이전 가치보다 항상 몇 배 더 크다. 4200 1000 4 100 2 6개 4790 4000 4 790 500 1 290 100 2 90 50 1 40 10 * 4 12개 12 1, 3, 4, 5 5 2 2 1 2 4개 하지만 4 * 3 3개 위와 같은 상황이 일어날까?동전의 가치가 이전 가치의 배수이기에 일어날 수 없을 것이다. 1 Try123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; costs;int main()&#123; int i, n, goal, answer = 0; cin &gt;&gt; n &gt;&gt; goal; costs.resize(n); for(i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; costs[i]; &#125; while(goal != 0) &#123; if(goal &gt;= costs[i-1]) &#123; goal -= costs[i-1]; answer++; &#125; else i--; &#125; cout &lt;&lt; answer &lt;&lt; '\\n'; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 10989번 수 정렬하기 3","slug":"Algorithm/BOJ/10989","date":"2020-01-25T04:21:51.000Z","updated":"2020-01-25T08:58:11.156Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/10989/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/10989/","excerpt":"","text":"#10989. 수 정렬하기 3문제링크 Problem 시간 제한 3초 메모리 제한 8MB Goal : 주어진 수를 오름차순으로 정렬하기 Solution 메모리 제한이 8MB라는 점에 주의한다. 주어진 수는 최대 천만수의 최댓값은 최대 만 int 형 배열을 천만개 크기로 만들면10000000 * 4 = 4천만 byte = 38…MB(이미 초과 하지만 10001 크기의 배열만으로 문제를 풀 수 있다.40004 = 0.038..MB(충분히 통과) 위의 크기만 가지고 문제를 푸려면 counting sort가 적절하다. 입력으로 받은 수를 각각 세어준다. → 끝 ??? 진짜 끝이다. 남은건 해당 숫자만큼 차례대로 카운트한 횟수만큼 출력해주면 된다. 1 Try12345678910111213141516171819#include &lt;cstdio&gt;#define MAX 10000using namespace std; // 이거 안써도 된다...int cnt[MAX+1];int main()&#123; int n, input; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;input); cnt[input]++; &#125; for(int i = 1; i &lt;= MAX; ++i) &#123; for(int j = 0; j &lt; cnt[i]; j++) &#123; printf(\"%d\\n\", i); &#125; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 10814번 나이순 정렬","slug":"Algorithm/BOJ/10814","date":"2020-01-25T04:21:45.000Z","updated":"2020-01-25T08:58:11.129Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/10814/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/10814/","excerpt":"","text":"#10814. 나이순 정렬문제링크 Problem 나이와 이름이 입력으로 주어진다. 나이순으로 정렬 나이가 같다면 가입한 순서로 정렬(입력 순으로) Solution 으로 key가 중복될 수 있으니 multimap을 사용한다. map 자체가 key가 오름차순을 유지하도록 data를 넣어준다.같다면 입력순으로 된다. 1 Try12345678910111213141516171819#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;int main()&#123; int n, age; string name; multimap&lt;int, string&gt; answer; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; age &gt;&gt; name; answer.insert(make_pair(age, name)); &#125; for(auto ans : answer) &#123; cout &lt;&lt; ans.first &lt;&lt; \" \" &lt;&lt; ans.second &lt;&lt; '\\n'; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 9019번 DSLR","slug":"Algorithm/BOJ/9019","date":"2020-01-25T04:21:38.000Z","updated":"2020-01-25T08:58:11.154Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/9019/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/9019/","excerpt":"","text":"#9019. DSLRProblem 문제링크 Solution 이 문제는 명령어 ‘L’과 ‘R’을 어떻게 수행하느냐가 제일 중요하다. 처음에 deque를 사용하여 숫자를 배열로 나누고 합치고 이러다가 시간초과… 사실 사칙연산만 사용하면 위 명령어를 수행할 수 있다. L 명령어 Next = (Now % 1000 * 10) + (Now / 1000) R 명령어 Next = (Now / 10) + (Now % 10 * 1000) 주의해야 할 사항 테스트 케이스를 여러 번 수행하는 문제이므로 초기화가 필요한 변수나 배열은 초기화를 해줘야 한다. 명령어를 저장하고 있어야 하므로, 해당 숫자를 어떻게 만들었는지 경로를 저장할 배열을, 그 숫자를 만들 때 쓴 명령어가 무엇인지 저장할 배열을 만든다. from[a] = b a를 만들기 이전 숫자 b how[a] = &#39;b&#39; a를 만들 때 수행된 명령어 b 1 Try code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define MAX 10000using namespace std;char cmd[4] = &#123; 'D', 'S', 'L', 'R' &#125;;bool check[MAX];int from[MAX];char how[MAX];int A, B;void Init() &#123; memset(check, 0, sizeof(check));&#125;void PrintCmd(int a, int b) &#123; if (a != b) &#123; PrintCmd(a, from[b]); cout &lt;&lt; how[b]; &#125; &#125;void BFS() &#123; queue&lt;int&gt; q; q.push(A); check[A] = true; while (!q.empty()) &#123; int a = q.front(); q.pop(); if (a == B) &#123; PrintCmd(A, B); cout &lt;&lt; \"\\n\"; return; &#125; int d = a * 2 &gt; MAX - 1 ? a * 2 % MAX : a * 2; if (!check[d]) &#123; check[d] = true; how[d] = 'D'; from[d] = a; q.push(d); &#125; int s = a == 0 ? MAX - 1 : a - 1; if (!check[s]) &#123; check[s] = true; how[s] = 'D'; from[s] = a; q.push(s); &#125; int cur = a; deque&lt;int&gt; ld, rd; for (int i = 0, div = 1000; i &lt; 4; ++i, div /= 10) &#123; int num = cur / div; cur %= div; ld.push_back(num); rd.push_back(num); &#125; int tmp = ld.front(); ld.pop_front(); ld.push_back(tmp); tmp = rd.back(); rd.pop_back(); rd.push_front(tmp); int l = 0, r = 0; for (int i = 0, div = 1; i &lt; 4; ++i, div *= 10) &#123; l += ld.back() * div; r += rd.back() * div; ld.pop_back(); rd.pop_back(); &#125; if (!check[l]) &#123; check[l] = true; how[l] = 'L'; from[l] = a; q.push(l); &#125; if (!check[r]) &#123; check[r] = true; how[r] = 'R'; from[r] = a; q.push(r); &#125; &#125;&#125;int main() &#123; int T; cin &gt;&gt; T; for (int t = 0; t &lt; T; ++t) &#123; Init(); cin &gt;&gt; A &gt;&gt; B; BFS(); &#125; return 0;&#125; 시간초과 2 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define MAX 10000using namespace std;char cmd[4] = &#123; 'D', 'S', 'L', 'R' &#125;;bool check[MAX];int from[MAX];char how[MAX];int A, B;void Init() &#123; memset(check, 0, sizeof(check));&#125;void PrintCmd(int a, int b) &#123; if (a != b) &#123; PrintCmd(a, from[b]); cout &lt;&lt; how[b]; &#125; &#125;void BFS() &#123; queue&lt;int&gt; q; q.push(A); check[A] = true; while (!q.empty()) &#123; int a = q.front(); q.pop(); if (a == B) &#123; PrintCmd(A, B); cout &lt;&lt; \"\\n\"; return; &#125; int d = a * 2 % MAX; if (!check[d]) &#123; check[d] = true; how[d] = 'D'; from[d] = a; q.push(d); &#125; int s = a == 0 ? MAX - 1 : a - 1; if (!check[s]) &#123; check[s] = true; how[s] = 'S'; from[s] = a; q.push(s); &#125; int l = (a % 1000 * 10) + (a / 1000); if (!check[l]) &#123; check[l] = true; how[l] = 'L'; from[l] = a; q.push(l); &#125; int r = (a / 10) + (a % 10 * 1000); if (!check[r]) &#123; check[r] = true; how[r] = 'R'; from[r] = a; q.push(r); &#125; &#125;&#125;int main() &#123; int T; cin &gt;&gt; T; for (int t = 0; t &lt; T; ++t) &#123; Init(); cin &gt;&gt; A &gt;&gt; B; BFS(); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 3190번 뱀","slug":"Algorithm/BOJ/3190","date":"2020-01-25T04:21:13.000Z","updated":"2020-01-25T08:58:11.149Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/3190/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/3190/","excerpt":"","text":"#3190. 뱀문제링크 Problem N x N 보드판 양 끝 모서리에 벽이 있음 뱀의 길이 1, 시작 위치 (1, 1), 방향: → 매 초마다 이동 머리를 다음 칸에 위치 이동한 칸에 사과가 있으면 사과 먹고 꼬리 움직이지 않음(몸길이 늘어남) 꼬리 움직인다. (몸길이 그대로) Goal: 사과의 위치와 뱀의 이동경로가 주어질 때 게임이 몇 초만에 끝나는지 계산 게임은 벽이나 자기자신의 몸과 부딪히면 끝난다. 뱀의 이동 경로는 (왼쪽 오른쪽 으로 90도 방향 회전) 입력 방향 변환 정보에서 주어진 초는 게임 시작 시간으로부터 X초가 끝난 뒤를 말한다. Solution 주어진 문제대로 구현하면 된다. (시뮬레이션) 방향전환 시간은 오름차순으로 주어지기에 queue에 저장 사과가 있는 곳은 -1로 표시 뱀이 있는 곳은 1부터~현재 길이까지 표시 (머리가 가장 큰 수) 머리를 기준으로 현재 방향에 맞게 움직인다. 머리가 움직였을 때 그곳이 벽이거나 자신의 몸인지 확인한다.필자는 다음과 같은 경우에 뱀이 동시에 움직일거라 생각하여 게임이 안끝난다고 생각했다. // 4가 머리이고 머리가 위쪽으로 가는 경우일 때 1 2 -&gt; 4 1 4 3 3 2 하지만 동시에 움직이지 않고 머리부터 움직여서 꼬리가 따라온다. 그렇기에 위와 같은 경우는 게임이 종료된다. 방향 전환 시간인지 확인한다.해당 경우에 맞게 방향을 변경한다. 사과가 있는지 확인한다.사과가 있으면 길이가 1 늘어나고 이동하지 않는다. 이동한다.이동방법: 머리에서부터 시작해서 자신보다 1 적은 수를 찾는다. 찾으면 그 값을 넣는다. 이를 총 길이-1만큼 반복하고(머리를 제외하기 때문) 다음 탐색 부분에 머리를, 원래 꼬리 부분을 0으로 변경해준다. 1 2 3 4 —&gt; 1 1 2 3 —&gt; 0 1 2 3 5 4 5 4 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt; #include &lt;queue&gt;using namespace std;int n, k, l;int board[101][101];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;int d_left[4] = &#123; 2, 3, 1, 0 &#125;; // 'L'int d_right[4] = &#123; 3, 2, 0, 1 &#125;; // 'D'queue&lt;pair&lt;int, char&gt; &gt; direction;bool isWall(int x, int y) &#123; // 벽이면 true if (x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; n) return true; return false;&#125;bool isBound(int x, int y) &#123; if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &lt;= n) return true; return false;&#125;int game() &#123; int x = 1; int y = 1; // 시작위치 int dir = 3; // 시작방향: 오른쪽 int len = 1; // 뱀의 길이 int time = 0; // 게임 시작 시간 board[x][y] = 1; while (true) &#123; int convert = 0; if (!direction.empty()) &#123; convert = direction.front().first; &#125; time++; // 현재 방향에 맞는 한 칸 이동 int d_x = x + dx[dir]; int d_y = y + dy[dir]; // 벽인지 자신의 몸인지 확인 if (isWall(d_x, d_y) || board[d_x][d_y] &gt; 0) return time; // 방향 전환 시간인지 확인 if (time == convert) &#123; if (direction.front().second == 'D') &#123; dir = d_right[dir]; &#125; else &#123; dir = d_left[dir]; &#125; direction.pop(); &#125; // 사과 있는지 확인 if (board[d_x][d_y] == -1) &#123; board[d_x][d_y] = ++len; x = d_x; y = d_y; continue; &#125; // 이동 int tmp_x = x, tmp_y = y; for (int i = 1; i &lt; len; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; int d_tmp_x = tmp_x + dx[j]; int d_tmp_y = tmp_y + dy[j]; if (isBound(d_tmp_x, d_tmp_y)) &#123; if (board[d_tmp_x][d_tmp_y] == board[tmp_x][tmp_y] - 1) &#123; board[tmp_x][tmp_y] = board[d_tmp_x][d_tmp_y]; tmp_x = d_tmp_x; tmp_y = d_tmp_y; break; &#125; &#125; &#125; &#125; board[d_x][d_y] = len; board[tmp_x][tmp_y] = 0; x = d_x; y = d_y; &#125;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;k); for (int i = 0; i &lt; k; ++i) &#123; int r, c; scanf(\"%d %d\", &amp;r, &amp;c); board[r][c] = -1; &#125; scanf(\"%d\", &amp;l); for (int i = 0; i &lt; l; ++i) &#123; int x; char dir; scanf(\"%d %c\", &amp;x, &amp;dir); direction.push(&#123; x, dir &#125;); &#125; printf(\"%d\\n\", game()); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 3055번 탈출","slug":"Algorithm/BOJ/3055","date":"2020-01-25T04:18:12.000Z","updated":"2020-01-25T08:58:11.137Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/3055/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/3055/","excerpt":"","text":"#3055. 탈출Problem 문제링크 Solution 조건 중에 “물이 찰 예정인 칸에 고슴도치가 움직일 수 없다.“에 집중하였다. 물이 이동할 queue와 고슴도치가 이동할 queue를 따로 두어 탐색을 시작한다. 단, 물이 먼저 이동해야 한다.(위 조건 때문에) 모든 탐색은 BFS로 이루어지며, 물은 이동할 때마다 map을 갱신한다. 고슴도치는 갱신 안한다. 고슴도치가 ‘D’에 도착하지 못 하고 탐색할 지점이 없을 때 -1을 리턴하여 도착할 수 없다는 것을 표시한다. ‘D’에 도착하면 그때 시간을 바로 출력하도록 한다. 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;tuple&gt;#include &lt;queue&gt;using namespace std;int R, C;char map[51][51];bool visit[50][50];queue&lt;pair&lt;int, int&gt;&gt; q;queue&lt;pair&lt;int, int&gt;&gt; water;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void Input() &#123; scanf(\"%d %d\", &amp;R, &amp;C); for (int i = 0; i &lt; R; ++i) &#123; for (int j = 0; j &lt; C; ++j) &#123; scanf(\" %c\", &amp;map[i][j]); if (map[i][j] == 'S') &#123; q.push(&#123; i, j &#125;); visit[i][j] = true; &#125; else if (map[i][j] == '*') water.push(&#123; i, j &#125;); &#125; &#125;&#125;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; R &amp;&amp; y &lt; C) return true; return false;&#125;int BFS() &#123; int time = 0; while (!q.empty()) &#123; // 고슴도치가 탐색할 지점이 없을 때까지 진행 int w_len = water.size(); for (int i = 0; i &lt; w_len; ++i) &#123; // 물의 이동 int water_x, water_y; tie(water_x, water_y) = water.front(); water.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_w_x = water_x + dx[dir]; int d_w_y = water_y + dy[dir]; if (isBound(d_w_x, d_w_y)) &#123; if (map[d_w_x][d_w_y] == '.' || map[d_w_x][d_w_y] == 'S') &#123; map[d_w_x][d_w_y] = '*'; water.push(&#123; d_w_x, d_w_y &#125;); &#125; &#125; &#125; &#125; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; // 고슴도치 이동 int x, y; tie(x, y) = q.front(); q.pop(); if (map[x][y] == 'D') return time; // 목적지 도착하면 시간 리턴 for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (isBound(d_x, d_y) &amp;&amp; !visit[d_x][d_y]) &#123; if (map[d_x][d_y] != 'X' &amp;&amp; map[d_x][d_y] != '*') &#123; visit[d_x][d_y] = true; q.push(&#123; d_x, d_y &#125;); &#125; &#125; &#125; &#125; time++; &#125; return -1;&#125;void Solve() &#123; int ans = BFS(); if (ans == -1) printf(\"KAKTUS\\n\"); else printf(\"%d\\n\", ans);&#125;int main() &#123; Input(); Solve(); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2869번 달팽이는 올라가고 싶다","slug":"Algorithm/BOJ/2869","date":"2020-01-25T04:11:45.000Z","updated":"2020-01-25T08:58:11.145Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2869/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2869/","excerpt":"","text":"#2869. 달팽이는 올라가고 싶다Problem높이 V미터인 나무막대 낮에 A미터 올라감 밤에 B미터 내려감 정상에서는 안내려감 나무 막대 모두 올라가는데 걸리는 일 수 하루에 +A -B B &lt; A ≤ V ≤ 10억 어차피 값은 10억을 넘을 수 없으니 int 사용해도 무방 Ex. input 2 1 5 output 4 설명 1일: 0+2 = 2 2일: 2-1+2 =3 3일: 3-1+2 = 4 4일: 4-1+2 = 5 하지만 제한시간이 0.15초이기에 이런 단계로 풀면 안된다.하루는 무조건 A가 되고 그 후는 -B+A가 반복이니 다음이 성립한다. V = A + (A-B)xx \\ge \\frac {V-A}{A-B}하지만 x는 정수이므로 위와 같은 부등호를 붙여주어야 한다. 3 1 6 1일: 3 2일: 3-1+3 = 5 3일: 5-1+3 = 7 공식: x ≥ 1.xx 따라서 x는 2, 총 일 수는 2+1 = 3일이된다. 근데 이 공식 적용하면 V가 되었다가 다시 줄어드는 경우가 있어서 답에 영향을 주나? → NO ceil() 때문에 피연산자는 double형으로, 결과값은 int형으로 두었다.(결과값을 double로 설정하면 출력값이 큰 경우 부동소수점 방식으로 출력되어 틀린 답이 된다.)12345678910111213#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; double a, b, v; int day = 1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; v; double ans = (v-a) / (a-b); ans = ceil(ans); day += ans; cout &lt;&lt; day &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2798번 블랙잭","slug":"Algorithm/BOJ/2798","date":"2020-01-25T04:11:38.000Z","updated":"2020-01-25T08:58:11.147Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2798/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2798/","excerpt":"","text":"#2798. 블랙잭 N장의 카드 M : 목표 N장의 카드 중 3개 선택 3개의 숫자 합이 M에 최대한 가깝도록(M을 넘어서면 안됨) N은 최대 100이기에 100장 중 3장을 선택하는 경우의 수 100 x 99 x 98 = 970,200‬가 최대이다.그러므로 충분히 모든 경우의 수를 구해 답을 찾아낼 수 있는 문제이다. 재귀나 for문을 이용하여 풀 수 있을 것이다. 필자는 재귀를 사용하였다. M은 최대 300000이기에 MAX 값으로 두었고 재귀의 내용은 다음과 같다. 매개변수 numbers : N개의 숫자를 담을 vector goal : M ans : 숫자 합 index : numbers의 인덱스 selected : 남은 카드 선택 횟수 실패 조건 숫자 합이 M보다 클 때 index가 numbers의 크기를 넘었을 때 성공 조건 3번을 뽑았을 경우, goal과 ans의 차이가 최소인 값 재귀함수 카드를 선택하지 않을 때 카드를 선택했을 때ans에 선택한 카드가 더해짐12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;#define MAX 300000;using namespace std;int min_diff = MAX;vector&lt;int&gt; numbers;void doCombination(vector&lt;int&gt; numbers, int goal, int ans, int index, int selected) &#123; if(ans &gt; goal) return; if(selected == 0) &#123; min_diff = min_diff &gt; goal-ans ? goal-ans : min_diff; return; &#125; if(index &gt;= numbers.size()) &#123; return; &#125; doCombination(numbers, goal, ans, index+1, selected); // not selected ans += numbers[index]; doCombination(numbers, goal, ans, index+1, selected-1); // selected&#125;int main() &#123; int n, m, answer = 0; cin &gt;&gt; n &gt;&gt; m; numbers.resize(n); for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; numbers[i]; &#125; doCombination(numbers, m, 0, 0, 3); answer = m - min_diff; cout &lt;&lt; answer &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2748번 피보나치 수 2","slug":"Algorithm/BOJ/2748","date":"2020-01-25T04:11:30.000Z","updated":"2020-01-25T08:58:11.143Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2748/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2748/","excerpt":"","text":"#2748. 피보나치 수 2문제링크 Problem Goal : n번째 피보나치 수를 구하여라 condition 최대 90번째 피보나치 수를 구할 수 있어야 함 시간 제한 1초 SolutionF_n = F_{n-1} + F_{n-2}수식 그대로 DP를 적용한다.12// dp[n]은 n번째 피보나치 수dp[n] = dp[n-1] + dp[n-2]; 1 Try1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;long long dp[91]; long long fibo(int n)&#123; dp[0] = 0, dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125;int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; fibo(n) &lt;&lt; endl; return 0;&#125; 주의할 점은 90번째 피보나치 수(10의 18승보다 큼)를 담으려면 long long을 써야 한다는 점이다.(long은 안된다.)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2468번 안전 영역","slug":"Algorithm/BOJ/2468","date":"2020-01-25T04:11:03.000Z","updated":"2020-01-25T08:58:11.158Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2468/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2468/","excerpt":"","text":"#2468. 안전 영역Problem 문제링크 Solution 높이 1부터 최대 높이까지 작업을 진행한다. → set에 높이 정보를 담고 오름차순으로 정렬하면 더 빠를듯 각 높이마다 모든 영역을 탐색한다. (말이 모든 영역이지 이미 높이보다 같거나 작은 영역이나 방문한 영역이면 탐색을 하지 않는다.)탐색은 BFS로 안전영역을 표시한다. 탐색이 끝나면 안전 영역의 수를 1증가한다. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;int N, max_height, ans = 1;int arr[100][100];bool visited[100][100];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void BFS(int x, int y, int h) &#123; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123; x, y &#125;); visited[x][y] = true; while (!q.empty()) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int nx = x + dx[dir]; int ny = y + dy[dir]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= N) continue; if (visited[nx][ny] || arr[nx][ny] &lt;= h) continue; visited[nx][ny] = true; q.push(&#123; nx, ny &#125;); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++)&#123; for (int j = 0; j &lt; N; j++)&#123; cin &gt;&gt; arr[i][j]; if (max_height &lt; arr[i][j]) max_height = arr[i][j]; &#125; &#125; for (int h = 1; h &lt;= max_height; ++h) &#123; int area = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; if (visited[i][j] || arr[i][j] &lt;= h) continue; BFS(i, j, h); area++; &#125; &#125; if (ans &lt; area) ans = area; memset(visited, false, sizeof(visited)); &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2251번 물통","slug":"Algorithm/BOJ/2251","date":"2020-01-25T04:10:51.000Z","updated":"2020-01-25T08:58:11.148Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2251/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2251/","excerpt":"","text":"#2251. 물통Problem 문제링크 Solution 첫 시작은 C 물통만 가득 차 있으니 전체 합은 C의 물통이다. 물을 옮기는 경우는 총 6경우로 0을 A, 1을 B, 2를 C라고 했을 때 다음과 같은 경우가 존재한다.1230 -&gt; 1, 0 -&gt; 21 -&gt; 0, 1 -&gt; 22 -&gt; 0, 2 -&gt; 1 경우의 수가 중복되지 않도록 표시해주는 배열은 2차원으로도 해결 가능하다. (전체 양은 일정하니 A, B만 알아도 C를 알 수 있기 때문이다.) 처음 A, B, C의 부피를 저장한다. 시작은 (0, 0)에서 시작하고, ans[C 물의 양]이 true임을 표시해 A가 0일 때 C의 물의양임을 나타낸다. BFS 탐색을 시작한다. 각 경우에서 계속해서 나아가는 방식이기에 적합하다. (경우의 수도 많지 않음) 물을 옮기는 건 2가지 경우가 존재한다. from x → to y x + y ≤ Yx + y의 값이 y를 가진 물통의 부피(Y)이하일 때x를 다 옮길 수 있으므로 x를 가졌던 물통의 물의 양은 0이 된다.y를 가진 물통의 물의 양은 x+y가 된다. x + y &gt; Yx + y의 값이 Y보다 클 때 x를 다 옮길 수 없으므로x를 가졌던 물통의 물의 양은 x + y - Y가된다.y를 가졌던 물통의 물의 양은 Y가 된다. check와 A의 물의 양이 0인지 판단하여 BFS 탐색을 한다. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int bucket[3]; // 물통 부피bool check[201][201]; // A, B만 알아도 C를 알 수 있음bool ans[201]; // A가 비어있을 때 C의 물의 양queue&lt;pair&lt;int, int&gt;&gt; q;int from[6] = &#123; 0, 0, 1, 1, 2, 2 &#125;; // 0: A, 1: B, 2: Cint to[6] = &#123; 1, 2, 0, 2, 0, 1 &#125;;void Output() &#123; for (int i = 0; i &lt;= 200; ++i) &#123; if (ans[i]) cout &lt;&lt; i &lt;&lt; \" \"; &#125; cout &lt;&lt; \"\\n\";&#125;void BFS() &#123; int sum = bucket[2]; q.push(&#123; 0, 0 &#125;); check[0][0]= true; ans[sum] = true; while (!q.empty()) &#123; int cur[3]; cur[0] = q.front().first; cur[1] = q.front().second; cur[2] = sum - cur[0] - cur[1]; q.pop(); for (int i = 0; i &lt; 6; ++i) &#123; int next[3] = &#123; cur[0], cur[1], cur[2] &#125;; if (next[from[i]] + next[to[i]] &lt;= bucket[to[i]]) &#123; next[to[i]] += next[from[i]]; next[from[i]] = 0; &#125; else &#123; // 옮긴 물의 양이 해당 물통 부피보다 클 때 next[from[i]] += next[to[i]] - bucket[to[i]]; next[to[i]] = bucket[to[i]]; &#125; if (!check[next[0]][next[1]]) &#123; check[next[0]][next[1]] = true; q.push(&#123; next[0], next[1] &#125;); if (next[0] == 0) ans[next[2]] = true; &#125; &#125; &#125; &#125;int main() &#123; for (int i = 0; i &lt; 3; ++i) cin &gt;&gt; bucket[i]; BFS(); Output(); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2231번 분해합","slug":"Algorithm/BOJ/2231","date":"2020-01-25T04:10:46.000Z","updated":"2020-01-25T08:58:11.160Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2231/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2231/","excerpt":"","text":"#2231. 분해합문제링크 Problem 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합 245의 분해합 : 245+2+4+5 = 256245는 256의 생성자 생성자는 없을 수도 여러 개일 수도 있음 없다면 0 출력 Goal: N이 주어졌을 때 N의 가장 작은 생성자 출력 Solution 1부터 최대 N-1까지 분해합을 구하면서 풀어보면 어떻게 될까? 1부터 분해합을 구하다가 N이 되었을 때 종료하면 가장 작은 생성자를 출력할 수 있다. 분해합 구하기1234567891011121314151617181920212223242526272829303132212의 분해합 구하기212 자릿수 3// #1.212 / 10^2 = 2 -&gt; 212+2212 - 2*10^2 = 12// #2.12 / 10^1 = 1 -&gt; 212+2+112 - 1*10^1 = 2 -&gt; 212+2+1+211의 분해합 구하기11 자릿수 2div = 10 (10의 제곱 수)sum = 11 (분해합)// #1.temp = 11 / 10 = 1 (계산 용도)num = 11 - 10 = 1sum = 11 + 1 = 12div = 1// #2.temp = 1 / 1 = 1num = 1 - 1 = 0sum = 12 + 1 = 13div = 0그냥 더 간단한 방법이 생각났다. (2 Try 참고)sum, temp = 11sum = 11 + 11 % 10temp = 11 / 10 = 1sum = 12 + 1 % 10 = 13즉, sum += temp % 10temp /= 10 1 Try12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;// 자릿 수 체크int getLength(int num) &#123; int count = 0; do &#123; count++; &#125;while(num/=10); return count;&#125;// 분해합 게산 int distributeSum(int num) &#123; int length = getLength(num); int div = pow(10, length-1); int sum = num; int temp; for(int i = 0; i &lt; length; ++i) &#123; temp = num / div; num = num - temp * div; sum += temp; div /= 10; &#125; return sum;&#125;int main()&#123; int n, i; cin &gt;&gt; n; for(i = 1; i &lt; n; ++i) &#123; if(n == distributeSum(i)) &#123; cout &lt;&lt; i &lt;&lt; '\\n'; break; &#125; &#125; if(i == n) cout &lt;&lt; 0 &lt;&lt; '\\n'; return 0;&#125; 108ms 2 Try12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int distributeSum(int num) &#123; int sum, temp; sum = temp = num; do &#123; sum += temp % 10; &#125;while(temp /= 10); return sum;&#125;int main() &#123; int n, i; cin &gt;&gt; n; for(i = 1; i &lt; n; ++i) &#123; if(n == distributeSum(i)) &#123; cout &lt;&lt; i &lt;&lt; '\\n'; break; &#125; &#125; if(i == n) cout &lt;&lt; 0 &lt;&lt; '\\n'; return 0;&#125; 8ms","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2206번 벽 부수고 이동하기","slug":"Algorithm/BOJ/2206","date":"2020-01-25T04:10:43.000Z","updated":"2020-01-25T08:58:11.132Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2206/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2206/","excerpt":"","text":"#2206. 벽 부수고 이동하기문제링크 Problem N x M 크기의 맵 0은 이동가능 1은 벽을 나타냄 (0, 0) → (N-1, M-1)까지 이동 (상하좌우) 벽을 1개까지 부수고 이동 가능 Goal: (0, 0)에서 (N-1, M-1)까지 이동하는데 걸리는 경로 중 최단 경로 구하기 Solution 이동하기 시작지점(0, 0)에서부터 상하좌우로 갈 수 있는 방향을 탐색한다.도착지점까지 모든 곳을 탐색해야 하며, 이때 BFS를 사용한다.현재 지점에서 상하좌우로 가는데 걸리는 비용이 동일하기 때문이다. 벽을 부수었는지 여부를 경로를 갱신할 때마다 가지고 있어야 한다. 탐색할 때 이미 값이 있다면 이미 지나온 경로이므로 다른 지점을 탐색해야 한다. 그외는 다음을 확인하고 경로를 갱신한다. 탐색할 지점이 0이라면 경로 갱신 탐색할 지점이 1인데 이전까지 벽을 부수지 않았다면 경로 갱신 위와 같은 작업으로 문제를 해결할 수 있다. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;queue&gt;#define MAX 1001using namespace std;int n, m;int map[MAX][MAX];int path[MAX][MAX][2]; // 벽을 안부순 경로, 벽을 부순 경로int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;struct INFO &#123; int r, c; bool break_wall = false;&#125;;int bfs() &#123; queue&lt;INFO&gt; q; q.push(&#123; 0, 0, false &#125;); path[0][0][0] = 1; while (!q.empty()) &#123; int r = q.front().r; int c = q.front().c; bool bw = q.front().break_wall; q.pop(); if (r == n - 1 &amp;&amp; c == m - 1) return path[r][c][bw]; for (int i = 0; i &lt; 4; ++i) &#123; int x = r + dx[i]; int y = c + dy[i]; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; n &amp;&amp; y &lt; m) &#123; if (path[x][y][bw]) continue; if (map[x][y] == 0) &#123; path[x][y][bw] = path[r][c][bw] + 1; q.push(&#123; x, y, bw &#125;); &#125; else if(map[x][y] == 1 &amp;&amp; bw == 0) &#123; path[x][y][1] = path[r][c][bw] + 1; q.push(&#123; x, y, true &#125;); &#125; &#125; &#125; &#125; return -1;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; scanf(\"%1d\", &amp;map[i][j]); &#125; &#125; printf(\"%d\\n\", bfs()); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2146번 다리 만들기","slug":"Algorithm/BOJ/2146","date":"2020-01-25T04:10:23.000Z","updated":"2020-01-25T08:58:11.152Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2146/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2146/","excerpt":"","text":"2146. 다리 만들기Problem 문제링크 Solution 각 섬의 id를 매긴다. → DFS 이용 가장 짧은 다리의 길이를 구한다. → BFS 이용 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int map[100][100];bool visited[100][100];int N, ans =1e9;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void DFS(int x, int y, int idx) &#123; visited[x][y] = true; map[x][y] = idx; for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; N &amp;&amp; d_y &lt; N) &#123; if (map[d_x][d_y] == 0 || visited[d_x][d_y]) continue; DFS(d_x, d_y, idx); &#125; &#125;&#125;int BFS(int x, int y) &#123; memset(visited, false, sizeof(visited)); queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123; x, y &#125;); int temp = map[x][y]; int res = 0; while (int len = q.size()) &#123; while(len--) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; N &amp;&amp; d_y &lt; N) &#123; if (map[d_x][d_y] != 0 &amp;&amp; map[d_x][d_y] != temp) return res; if (map[d_x][d_y] == 0 &amp;&amp; !visited[d_x][d_y]) &#123; visited[d_x][d_y] = true; q.push(&#123; d_x, d_y &#125;); &#125; &#125; &#125; &#125; res++; &#125; return ans;&#125;int main() &#123; cin &gt;&gt; N; int idx = 1; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; // 각 섬에 번호 매기기 for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (visited[i][j] || map[i][j] == 0) continue; DFS(i, j, idx++); &#125; &#125; // 가장 짧은 다리 길이 구하기 for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (map[i][j] == 0) continue; ans = min(ans, BFS(i, j)); &#125; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 1938번 통나무 옮기기","slug":"Algorithm/BOJ/1938","date":"2020-01-25T04:09:53.000Z","updated":"2020-01-25T06:28:02.580Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/1938/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/1938/","excerpt":"","text":"#1938. 통나무 옮기기Problem 문제링크 Solution 통나무 중점 좌표를 토대로 BFS 탐색을 하였다.중심을 기준으로 그대로(회전), 상, 하, 좌, 우로 이동하면 각각 작동횟수 + 1이기에BFS로 탐색하는게 최적이다.중복 탐색을 막기 위해 3차원 방문 배열을 두어 중점 좌표의 각 모양(타입)에 따라 표시를 하였다. 중점 좌표로 이동하다보니 이동 후 다음을 꼭 확인해야 한다. 평지 범위를 벗어나지 않는지세 좌표 모두 범위를 벗어나지 않도록 확인해야한다. 방문한 지점인지 움직일 수 있는지상하좌우 → 움직인 세 좌표에 ‘1’이 없는지 확인회전 → 움직인 중점좌표 기준으로 3x3dp ‘1’이 없는지 확인 도착 지점에 도착하면 종료 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define endl \"\\n\"#define MAX 50using namespace std;int N, ans = 1e9;char land[MAX + 1][MAX + 1];bool visited[MAX + 1][MAX + 1][2];vector&lt;pair&lt;int, int&gt;&gt; start_point;vector&lt;pair&lt;int, int&gt;&gt; end_point;int dr[5] = &#123; 0, -1, 1, 0, 0 &#125;;int dc[5] = &#123; 0, 0, 0, -1, 1 &#125;;struct Log &#123; int type; // 0 : 가로, 1 : 세로 int r, c; // 중점 좌표&#125;;bool isIn(int r, int c, int type) &#123; // 통나무가 평지 범위인지 if (type == 0) c--; else r--; for (int i = 0; i &lt; 3; ++i) &#123; if (r &lt; 0 || c &lt; 0 || r &gt; N - 1 || c &gt; N - 1) return false; if (type == 0) c++; else r++; &#125; return true;&#125;bool isEnd(int r, int c, int type) &#123; // EEE에 도착했는지 if (type == 0) c--; else r--; for (int i = 0; i &lt; end_point.size(); i++) &#123; if (end_point[i].first != r || end_point[i].second != c) return false; if (type == 0) c++; else r++; &#125; return true;&#125;bool Check(int r, int c, int type) &#123; // 이동이 가능한지 if (type == 0) c--; else r--; for (int i = 0; i &lt; 3; ++i) &#123; if (land[r][c] == '1') return false; if (type == 0) c++; else r++; &#125; return true;&#125;bool CheckRotate(int r, int c, int type) &#123; // 회전이 가능한지 int sr = r - 1, sc = c - 1; for (int i = sr; i &lt; sr + 3; ++i) &#123; for (int j = sc; j &lt; sc+ 3; ++j) &#123; if (land[i][j] == '1') return false; &#125; &#125; return true;&#125;void BFS() &#123; queue&lt;Log&gt; q; int type, r, c; if (start_point[0].first == start_point[1].first) &#123; type = 0; r = start_point[0].first; c = start_point[1].second; &#125; else &#123; type = 1; c = start_point[0].second; r = start_point[1].first; &#125; q.push(&#123; type, r, c &#125;); visited[r][c][type] = true; int cnt = 0; while (int s = q.size()) &#123; while (s--) &#123; int r = q.front().r, c = q.front().c; int type = q.front().type; if (isEnd(r, c, type)) &#123; ans = cnt; return; &#125; q.pop(); for (int dir = 0; dir &lt; 5; ++dir) &#123; if (dir == 0 || dir == 1) type = (type+1) % 2; // 회전 후 타입 원래대로 int nr = r + dr[dir]; int nc = c + dc[dir]; if (!isIn(nr, nc, type)) continue; if (visited[nr][nc][type]) continue; if (dir == 0) if (!CheckRotate(nr, nc, type)) continue; // 3 x 3 확인 후 회전 if (Check(nr, nc, type)) &#123; visited[nr][nc][type] = true; q.push(&#123; type, nr, nc &#125;); &#125; &#125; &#125; cnt++; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; cin &gt;&gt; land[i][j]; if (land[i][j] == 'B') start_point.push_back(&#123; i, j &#125;); else if (land[i][j] == 'E') end_point.push_back(&#123; i, j &#125;); &#125; &#125; BFS(); if (ans == 1e9) ans = 0; cout &lt;&lt; ans &lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 1932번 정수 삼각형","slug":"Algorithm/BOJ/1932","date":"2020-01-25T04:09:30.000Z","updated":"2020-01-25T06:54:13.895Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/1932/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/1932/","excerpt":"","text":"#1932. 정수 삼각형문제링크 Problem 맨 위층부터 시작 → 맨 아래 층선택된 수들을 합하면서 내려옴 현재 층에서 선택된 수의 대각선(왼 or 오)만 가능 condition 층은 최대 500 수의 범위 0~9999 Goal : 합이 최대가 되는 수 Solution 입력을 보면 알겠지만 자기 자신 바로 아래와 오른쪽만 가능123456&#x2F;&#x2F; input73 88 1 02 7 4 44 5 2 6 5 그냥 재귀함수를 쓰면 반복되는 호출이 많이 일어난다.DP를 사용해야 함을 알 수 있다.12345678910&#x2F;&#x2F; #07&#x2F;&#x2F; #17+3 &#x2F; 7+8&#x2F;&#x2F; #27+3+8, 7+3+1 &#x2F; 7+8+1, 7+8+0&#x2F;&#x2F; #37+3+8+2, 7+3+8+7 &#x2F; 7+3+1+7, 7+3+1+4 &#x2F; 7+8+1+7, 7+8+1+4 &#x2F; 7+8+0+4, 7+8+0 +4&#x2F;&#x2F; #420+4, 20+5 &#x2F; 25+5, 25+2 &#x2F; 18+5, 18+2 &#x2F; 14+2, 14+6 &#x2F; 23+5, 23+2 &#x2F; ... 경우의 수는 1→2→4→8→16으로 늘어난다. 500일 때 최대 500^2 = 250000(25만)의 경우의 수가 나온다. 물론 재귀함수를 사용하면 이보다 더 많은 함수 호출이 일어나 시간초과가 발생할 것이다. 6개월 전에 풀었던 것을 다시 풀어보려니…생각이 안난다. dp[a][b] 1 Try (6개월 전 코드)1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int t[500][500];int d[500][500];int main()&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; cin &gt;&gt; t[i][j]; &#125; &#125; d[0][0] = t[0][0]; for (int k = 1; k &lt; n; k++) &#123; for (int h = 0; h &lt; n; h++) &#123; if (h == 0) &#123; d[k][0] = d[k - 1][0] + t[k][0]; //바로 위의 최대경로만 가져올 수 있음. &#125; else if (k == h) &#123; d[k][h] = d[k - 1][h - 1] + t[k][h]; // 바로 위 왼쪽의 최대경로만 가져올 수 있음. &#125; else &#123; d[k][h] = max(d[k - 1][h - 1], d[k - 1][h]) + t[k][h]; &#125; &#125; &#125; int max_cost = 0; // 0보다 작을 수 없음. for (int index = 0; index &lt; n; index++) &#123; max_cost = max(d[n - 1][index], max_cost); &#125; cout &lt;&lt; max_cost &lt;&lt; endl; return 0;&#125; 12345678910111213141516171819202122232425262728#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int max_sum = 0;vector&lt;vector&lt;int&gt;&gt; dp;int main() &#123; int n, input; scanf(\" %d\", &amp;n); dp.resize(n); vector&lt;vector&lt;int&gt;&gt; tri(n); for(int i = 0; i &lt; n; ++i) &#123; for(int j = i; j &gt;= 0; --j) &#123; scanf(\" %d\", &amp;input); tri[i].push_back(input); &#125; &#125; dp[0][0] = tri[0][0]; for(int i = 1; i &lt; n; ++i) &#123; for(int j = 0; j &lt;= i; ++j) &#123; dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]); &#125; &#125; cout &lt;&lt; max_sum &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 1525번 퍼즐","slug":"Algorithm/BOJ/1525","date":"2020-01-25T04:04:59.000Z","updated":"2020-01-25T04:49:31.051Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/1525/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/1525/","excerpt":"","text":"1525. 퍼즐Problem 문제링크 Solution 상당히 어려운 문제다. (접근법을 알아둘 필요가 있다.) 접근법 2차원 배열을 1차원 배열로 생각하기 퍼즐에 적혀있는 숫자를 하나로 쭉 이어진 수로 생각한다. 이어진 수 하나가 경우의 수라고 생각한다. (문제 목표는 123456789인 수(경우)를 찾는 것) map&lt;해당 경우(수), 이동 횟수&gt;를 사용하여 해당 경우에 도달하기까지 걸리는 이동 횟수를 저장한다. 9(0)이 있는 위치에서 시작하여 BFS 탐색을 하고 탐색 시에 swap을 해야 한다. (이동을 할 때 인덱스 계산에 주의한다.) swap을 위해 string을 사용한다.123456789101112ex) 현재 193425786 (0대신 9를 해야 각 자릿 수가 모두 채워진다. 0123...으로 하면 0이 사라짐)193425786 -&gt; 913425786 (왼쪽 이동)-&gt; 123495786 (아래쪽 이동)-&gt; 149425786 (오른쪽 이동)3 x 3 0 1 23 4 56 7 8행 &#x3D; 9번 위치(0~8 중) &#x2F; 3열 &#x3D; 9번 위치 % 3 주의 아래 코드에서 dist.count(next_num) == 0 대신 dist[next_num] == 0 을 하면 틀리다.dist[해당 수]에는 이동 횟수가 들어있고 dist.count(해당 수)는 해당 경우의 수가 몇 번 나왔는지 알려주기 때문이다. map에서 해당 키, 값을 넣어주지 않았는데 바로 해당 키에 대한 값을 참조하려고(dist[next_num] == 0) 하면 제대로 연산이 수행되지 않을 것이다. 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;queue&lt;int&gt; q;map&lt;int, int&gt; dist;void BFS(int start) &#123; q.push(start); dist[start] = 0; while (!q.empty()) &#123; int now_num = q.front(); q.pop(); string now = to_string(now_num); int zero = now.find('9'); // 0의 위치 int x = zero / 3; // 행 int y = zero % 3; // 열 for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; 3 &amp;&amp; d_y &lt; 3) &#123; string next = now; swap(next[x * 3 + y], next[d_x * 3 + d_y]); // 문자열 인덱스(2차원-&gt;1차원) int next_num = stoi(next); if (dist.count(next_num) == 0) &#123; q.push(next_num); dist[next_num] = dist[now_num] + 1; &#125; &#125; &#125; &#125;&#125;int main() &#123; string s = \"\"; for (int i = 0; i &lt; 3; ++i) &#123; for (int j = 0; j &lt; 3; ++j) &#123; int num; cin &gt;&gt; num; if (num == 0) num = 9; s += to_string(num); &#125; &#125; int start = stoi(s); BFS(start); if (dist.count(123456789) == 0) cout &lt;&lt; -1 &lt;&lt; \"\\n\"; else cout &lt;&lt; dist[123456789] &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 1261번 알고스팟","slug":"Algorithm/BOJ/1261","date":"2020-01-25T04:04:31.000Z","updated":"2020-01-25T08:57:02.058Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/1261/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/1261/","excerpt":"","text":"1261. 알고스팟Problem 문제링크 Solution 벽을 최소한으로 부수면서 목적지에 도착해야 한다. 벽을 부수지 않고 갈 경우 비용은 0 벽을 부수고 갈 경우 비용은 1 따라서 deque를 사용하여 BFS 탐색을 한다. 벽을 부수지 않는 경우 front에 넣는다. 벽을 부수는 경우 back에 넣는다. front 부분을 탐색하고 pop한다.그래야 벽을 최소한으로 부수면서 visit(방문) 표시가 가능하다. 1 Try 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;tuple&gt;#include &lt;deque&gt;using namespace std;int N, M;int map[100][100];bool visit[100][100];int cnt[100][100];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1 ,1 &#125;;void Input() &#123; scanf(\"%d %d\", &amp;N, &amp;M); for (int i = 0; i &lt; M; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; scanf(\"%1d\", &amp;map[i][j]); &#125; &#125;&#125;void BFS() &#123; deque &lt;pair&lt;int, int&gt;&gt; q; q.push_front(&#123; 0, 0 &#125;); visit[0][0] = true; while (!q.empty()) &#123; int x, y; tie(x, y) = q.front(); q.pop_front(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x == N - 1 &amp;&amp; d_y == M - 1) &#123; cnt[d_x][d_y] = cnt[x][y]; return; &#125; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; M &amp;&amp; d_y &lt; N) &#123; if (visit[d_x][d_y]) continue; if (map[d_x][d_y] == 1) &#123; cnt[d_x][d_y] = cnt[x][y] + 1; q.push_back(&#123; d_x, d_y &#125;); &#125; else &#123; cnt[d_x][d_y] = cnt[x][y]; q.push_front(&#123; d_x, d_y &#125;); &#125; visit[d_x][d_y] = true; &#125; &#125; &#125;&#125;int main() &#123; Input(); BFS(); printf(\"%d\\n\", cnt[M - 1][N - 1]); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"Jenkins, NAVER Cloud Platform, Docker로 CI/CD 무중단 배포 환경 구축하기 - 2편","slug":"DevOps/cicd-2","date":"2020-01-21T13:06:11.000Z","updated":"2020-01-25T04:56:07.289Z","comments":true,"path":"2020/01/21/DevOps/cicd-2/","link":"","permalink":"https://doyuni.github.io/2020/01/21/DevOps/cicd-2/","excerpt":"","text":"2편에서는 CD에서 무중단 배포까지 구축한다. (1편에서는 Github Push 후에 Jenkins가 자동으로 빌드되도록 설정하였다.) 2. Jenkins로 Node.js기반 프로젝트 배포 설정하기배포를 위해 scp를 사용하여 Jenkins에 있는 프로젝트 코드를 NAVER Cloud 서버에 복사해야 한다.Node.js 기반의 프로젝트는 Tomcat과 같은 WAS(웹 서버+웹 컨테이너)가 존재하지 않아 ssh로 접속, scp로 파일을 주고 받는 작업으로 비교적 간단히 배포할 수 있다. 2-1. NAVER Cloud 서버에도 ssh 키를 생성한다.1ssh-keygen -t rsa 키가 생성되면 authorized_keys, id_rsa, id_rsa.pub, known_hosts 가 생성되어 있는 것을 볼 수 있다. scp로 파일을 주고 받는다 하였는데 이때 복사 받을 서버의 접속 비밀번호를 알아야 한다. 그렇게되면 복사할 때마다 매번 비밀번호를 요구하여 자동화 배포는 불가능하게 된다. 이를 해결하기 위해 위의 4개의 키를 이용한다.Jenkins에서는 NAVER Cloud 서버를 호스트로, NAVER Cloud 서버에서는 Jenkins 서버의 공개 키를 허가받은 키로 등록한다. 이러면 비밀번호를 요구하지 않고 자동화 배포가 가능하다. 2-2. Jenkins 서버에서 NAVER Cloud 서버를 known_hosts로 등록한다.1ssh-keyscan -H (NAVER CLOUD 서버)ip &gt;&gt; ~/.ssh/known_hosts 2-3. Jenkins에서 생성한 키 중에 공개 키(id_rsa.pub)를 NAVER Cloud 서버에서 생성한 authorized_keys에 입력한다. Jenkins 서버의 공개 키 NAVER Cloud 서버의 authorized_keys 1vi ~/.ssh/authorized_keys scp로 테스트하기접속 비밀번호를 요구하지 않았다면 성공이다. Jenkins 서버에서 test.txt 파일을 생성한다. Jenkins 서버에서 scp를 사용해 test.txt를 NAVER Cloud 서버의 /root/test 폴더에 복사한다.비밀번호를 요구하지 않으면 성공. NAVER Cloud 서버에서 복사된 파일을 확인한다. 3. NAVER Cloud 서버에 Docker, NGINX 설정하기이제 프로젝트가 배포되는 NAVER Cloud 서버에서 설정해야 할 부분이다.(*Docker 및 NGINX 설치는 생략한다.) 3-1. Dockerfile 작성.ssh로 서버에 접속하고 Dockerfile을 다음과 같이 작성한다. 123456789101112131415FROM 이미지 환경 MAINTAINER 개발자 VOLUME 호스트와 공유할 폴더 RUN mkdir -p /app WORKDIR /app COPY ./프로젝트 소스코드 폴더/ /app RUN npm install CMD npm start FROM: Node 이미지(Node version 명시) MAINTAINER: 개발자(팀명) VOLUME: host와 컨테이너가 공유할 폴더 경로 RUN: 해당 명령어 실행( 위에선 app 폴더 생성 ) WORKDIR: 작업 디렉토리 설정(위에서 만든 app 폴더로 설정) COPY: NAVER Cloud 서버에 있는 파일을 컨테이너 폴더에 복사서버에 있는 파일은 Dockerfile이 존재하는 현재 경로 내에 존재하는 것만 가능하다.(즉, 절대 경로는 Dockerfile이 있는 경로 이내가 아니라면 불가능) 그 다음은 패키지 파일들을 설치하고 서버를 실행한다. docker image build -t 도커이미지이름 .를 입력하여 이미지를 빌드한다. 3-2. Docker-compose 작성하기docker-compose(컨테이너 관리)를 설치하여 편하게 컨테이너를 설정한다.여기서 blue-green 배포 방식이 사용되는데, 이는 무중단 배포 구축을 위함이다. Dockerfile이 있는 곳에 docker-compose.blue.yml을 다음과 같이 작성한다. 123456789version: '2'services: linking-server: image: 빌드한 도커 이미지 volumes: - ./deploy:/deploy/linking ports: - \"NAVER Cloud 서버 포트:컨테이너 포트\" image: 아까 빌드한 이미지 이름을 작성한다. volumes: host 폴더와 컨테이너 폴더를 설정하여 공유한다.(심볼릭 링크와 비슷한 개념이라고 한다.) ports: host 포트와 컨테이너 포트 순으로 작성하여 포트 포워딩 설정을 한다. 같은 곳에 docker-compose.green.yml을 다음과 같이 작성한다.host 포트만 다르다. 3-3. deploy script 작성하기. 같은 곳에 deploy.sh를 다음과 같이 작성한다. 123456789101112131415161718192021#!/bin/bash DOCKER_APP_NAME=linking-server EXIST_BLUE=$(docker-compose -p $&#123;DOCKER_APP_NAME&#125;-blue -f docker-compose.blue.yml ps | grep Up) if [ -z \"$EXIST_BLUE\" ]; then echo \"blue up\" docker-compose -p $&#123;DOCKER_APP_NAME&#125;-blue -f docker-compose.blue.yml up -d sleep 10 docker-compose -p $&#123;DOCKER_APP_NAME&#125;-green -f docker-compose.green.yml downelse echo \"green up\" docker-compose -p $&#123;DOCKER_APP_NAME&#125;-green -f docker-compose.green.yml up -d sleep 10 docker-compose -p $&#123;DOCKER_APP_NAME&#125;-blue -f docker-compose.blue.yml downfi 지금까지 잘 따라 했다면 아래와 비슷한 디렉토리 구조를 볼 수 있을 것이다. 컨테이너 생성하기 docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml up -d를 입력하여 blue 컨테이너를 먼저 생성해준다. docker ps -a로 컨테이너가 잘 실행되고 있는지 확인할 수 있다. 3-4. NGINX 설정하기.다음은 NGINX로 blue, green의 로드밸런싱을 설정해 주어야 한다. vi /etc/nginx/sites-available/linking-server를 입력하여 다음과 같이 작성한다.linking-server는 필자가 정한 이름이다. 12345678910111213# Load Balancingupstream linking-server &#123; least_conn; server 127.0.0.1:1025 weight=5 max_fails=3 fail_timeout=10s; server 127.0.0.1:1026 weight=10 max_fails=3 fail_timeout=10s;&#125;server &#123; listen 1024; server_name NAVER Cloud 서버 아이피; location / &#123; proxy_pass http://linking-server; &#125;&#125; 그런 다음 아래 명령어로 이 파일을 /etc/nginx/sites-enabled 디렉터리에 링크해준다. sudo ln -fs /etc/nginx/sites-available/linking-server /etc/nginx/sites-enabled/ 마지막으로 sudo nginx -t 명령어로 문법 이상 유무를 확인하고 이상이 없을 경우, systemctl stop nginx 명령어로 NGINX를 종료한 후에 systemctl start nginx 로 다시 시작한다. 3-5. NAVER Cloud Platform ACG 설정하기.여기서 마지막으로 한 가지 해야할 것은 ACG 설정이다. ACG 설정하기 NAVER Cloud Platform 콘솔에서 1024포트를 열어준다. 위에서 blue, green 모두 다른 포트지만 NGINX를 통해 1024 포트로 로드 밸런싱 되기에 사용자는 이를 통해 접근할 수 있다.(보통 백엔드와 프론트엔드를 분리하면서 프로젝트를 진행하고 있다면 프론트엔드는 80포트를 사용하는게 좋다. 80이 기본 포트라 생략 가능하므로) 이것으로 NAVER Cloud 서버에서의 설정은 끝났다. 4. 마지막 작업이제 마지막 Jenkins에서 빌드할 때 설정을 해주어야 위에서 설정한 무중단 배포가 자동화된다. Jenkins 프로젝트 관리에서 “Execute managed script”를 클릭한다.다만, 아직 작성한 스크립트가 없기에 Jenkins 관리 &gt; Managed files &gt; Add a new Config를 통해 스크립트를 작성한다. 다음과 같이 작성한다. 123456789101112131415#!/bin/shssh -T root@서버 아이피 &lt;&lt;EOF rm -rf /home/docker-image/deploy/* exitEOF scp -r /var/lib/jenkins/jobs/LinkingCI/workspace/* root@서버 아이피:/home/docker-image/deploy/ #!/bin/shssh -T root@서버 아이피 &lt;&lt;EOF cd /home/docker-image docker image build -t linking-server-docker-image . ./deploy.sh exitEOF 1) Jenkins가 빌드 동안 해당 서버에 접속하여 원래 있던 애플리케이션 코드를 삭제한다. 2) 빌드된 파일을 해당 서버에 복사한다. 3) 해당 서버에 다시 접속하여 새로 복사된 파일을 토대로 도커 이미지를 빌드한다. 4) 배포 스크립트를 실행한다. 위와 같은 과정이 일어나고 지금까지 설정한 것들이 모두 자동화되어 무중단 배포까지 진행된다. 이를 이제 Jenkins 프로젝트 관리에서 실행하도록 한다. 5. 빌드 상태 표시, Slack 알림추가로 프로젝트에서 보이는 Embeddable Build Status를 클릭하면 마크다운 형식으로 Github 레포지토리에 빌드 상태바를 보이게 할 수 있다. 마지막으로 팀원들이 빌드 상태(시작, 실패, 성공)을 알고 싶을 때 Slack을 통해 알림을 받도록 할 수도 있다.1편에서 이미 관련 플러그인을 설치하였기에 바로 설정이 가능하다. Slack에 채널을 만들었다면 Apps에서 Jenkins를 검색 후 클릭한다. 알림을 받을 채널을 설정하면 Jenkins에서 어떻게 설정해야 하는지 친절하게 나온다. 설정을 하고 나면 Jenkins 프로젝트에서 빌드 후 조치에 알림 받을 내역을 설정할 수가 있게 된다. 빌드 시작부터 끝까지 알림이 날라온다. 이것으로 CI/CD 무중단 배포 환경 구축을 마친다. -끝-","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://doyuni.github.io/categories/DevOps/"},{"name":"CI/CD","slug":"DevOps/CI-CD","permalink":"https://doyuni.github.io/categories/DevOps/CI-CD/"}],"tags":[{"name":"NAVER CLOUD","slug":"NAVER-CLOUD","permalink":"https://doyuni.github.io/tags/NAVER-CLOUD/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://doyuni.github.io/tags/Jenkins/"},{"name":"Docker","slug":"Docker","permalink":"https://doyuni.github.io/tags/Docker/"},{"name":"NGINX","slug":"NGINX","permalink":"https://doyuni.github.io/tags/NGINX/"}]},{"title":"Jenkins, NAVER Cloud Platform, Docker로 CI/CD 무중단 배포 환경 구축하기 - 1편","slug":"DevOps/cicd-1","date":"2020-01-21T13:01:34.000Z","updated":"2020-01-25T04:56:07.287Z","comments":true,"path":"2020/01/21/DevOps/cicd-1/","link":"","permalink":"https://doyuni.github.io/2020/01/21/DevOps/cicd-1/","excerpt":"","text":"이번 내용은 필자가 프로젝트를 진행하면서 처음으로 DevOps를 맡으면서 꼭 공유 하겠다고 마음 먹고 작성하였다. CI/CD란? CI(Continuous Integration)지속적인 통합을 의미한다. 이는 개발자를 위한 자동화 프로세스 중 하나이며 어플리케이션을 변경할 때 자동으로 빌드 및 테스트되어 Github 공유 레포지토리에 병합된다. 그렇기에 협업 시 발생할 수 있는 충돌문제를 해결할 수 있다. CD(Continuous Deployment)지속적인 배포를 의미한다. 어플리케이션 변경 사항이 반영된 공유 레포지토리에서 사용자가 사용 가능한 환경까지 자동으로 배포하는 것을 말한다. 이를 통해 어플리케이션을 원활히 그리고 더 빠르게 제공하므로써 사용자의 피드백을 빠르게 반영할 수 있다. 아래는 필자가 맡은 프로젝트의 전체 시스템 구조이면서 동시에, CI/CD 과정을 볼 수 있다. 전체 시스템 구조 대부분 Travis CI, AWS, Docker, NGINX를 사용하여 CI/CD 무중단 배포를 구축한다는 점에서 비교하여 보아도 좋을 것이다. 선택의 순간들AWS가 아닌 NAVER CLOUD 선택AWS와 NAVER Cloud Platform을 사용해 보면서 느낀 것은 확실히 AWS의 기능이 훨씬 많고 유용하다.그럼에도 NAVER Cloud Platform을 사용한 것은 40만 크레딧(지원 받았다.)이 제일 컸다.AWS에는 무중단 배포까지 지원하는 서비스인 Blue-Green Deployment가 있는데 반해 NAVER Cloud는 없다…그럼 굳이 왜 AWS를 선택하지 않았냐고 할 수 있는데 내가 직접 설정해서 구축하고 싶었기 때문이다. (사서 고생한다는 얘기) Travis가 아닌 Jenkins 선택Travis reference만 보아도 AWS랑 얼마나 죽이 잘 맞는지를 알 수 있다. (AWS말고도 Google Cloud, Azure도 지원한다.) 이미 NAVER Cloud를 선택한 이상 Travis는 더 어려운 방법으로 가는 길이라 생각했다. 오히려 설정할 수 있는 범위가 넓은 Jenkins를 택하는 것이 쉽다고 판단하였다. 처음에 AWS와 Travis로 자동화 배포 환경 구축을 연습했었는데, 개인적인 입장으로는 Jenkins가 좀 더 쉬운 것 같다. 40만 크레딧의 위엄으로 Jenkins를 도커가 아닌 Naver Cloud로 서버를 따로 구축했다. 지금 생각해보면 자원 낭비인 셈이지만 안정성 측면에서는 따로 서버를 두는 것이 좋다. 환경 구축하기NAVER Cloud 사용 설명서는 무척 잘 되어 있고 AWS의 EC2나 S3와 같은 개념과 똑같기에 같은 방식으로 설정하면 된다. NAVER Cloud의 Server = AWS의 EC2 NAVER Cloud의 Object Storage = AWS의 S3 아래와 같이 SourcePipeline 서비스를 이용하면 Github에서 push한 것을 자동으로 빌드하고 배포할 수 있는데, 아래 사진 우측 상단에 보이는 파이프라인 실행하기를 매번 클릭해줘야 한다…내가 원한건 push만 해도 자동화 빌드 및 배포이다. 결국 이걸 접고 Jenkins와 NAVER Cloud의 Server만 사용하기로 결정했다. 1. Jenkins 설정하기Docker로 Jenkins 서버를 운영해도 되지만 NAVER Cloud에서 다음과 같이 지원하기에 사용하였다.다만 수동으로 최신 업데이트 하는 것을 권장한다. 1-1. Jenkins 보안 설정Jenkins는 기본적으로 보안 설정이 되어있지 않다.Jenkins 관리 &gt; Configure Global Security에서 설정할 수 있다. 처음에 사용자의 가입을 허용하여 admin 계정을 생성한다. 팀원과 함께 작업한다면 팀원 각각 계정 생성하도록 둔다. 계정 생성을 끝냈으면 ‘Matrix-based security’를 적절히 설정한다. (없다면 Matrix Authorization Strategy Plugin를 설치하자.)필자는 익명에게 읽기 권한 중 Job(Jenkins 작업 단위) 부분만 볼 수 있게 하였다. 이는 나중에 설정할 Github의 build status를 보여주기 위함이다.그리고 혼자 환경 구축을 담당 하였기에 팀원 계정 역시 익명과 같은 권한을 주었다. 1-2. 플러그인 설치하기Jenkins 관리 &gt; 플러그인 관리 Github plugin: Jenkins와 Github 통합 Global Slack Notifier Plugin: Slack 연동(Job 알림 설정) Publish Over SSH: ssh로 빌드 파일 보내기 Embeddable Build Status Plugin: Github 레포지토리에 빌드 상태바 생성 Managed Scripts: Node.js 기반의 서버를 배포하기 위한 스크립트 1-3. Jenkins Global 설정하기Jenkins 관리 &gt; 시스템 설정 &gt; GitHub Servers에서 다음과 같이 설정한다. Credentials 설정을 위해 자신의 Github &gt; Settings &gt; Developer settings &gt; Personal access tokens에서 다음과 같이 토큰을 생성한다. 생성 후 화면에 보이는 secret 문자열을 아래의 Secret에 입력한다. 1-4. 프로젝트 생성 및 설정하기새로운 Item을 클릭하고 프로젝트 이름을 입력, Freestyle을 누른다. 다음과 같이 프로젝트 url을 입력하고 Credentials를 설정한다. 이 작업은 Github을 연동하는 것인데, ID와 PW로 연동하면 보안에 취약하기에 ssh키로 연동하였다. ssh 키 생성하기 ssh로 Jenkins 서버에 원격 접속하여 다음을 입력한다.1ssh-keygen -t rsa -f id_rsa id_rsa, id_rsa.pub 를 포함해 총 4개의 키가 생성된다. 아래 Add 표시를 눌러 cat ~/.ssh/id_rsa 입력 후 나오는 private key를 넣어준다 BEGIN ~부터 모두 복사하여 입력한다. Github에 공개 키 등록하기. cat ~/.ssh/id_rsa.pub 를 입력하면 나오는 공개 키를 프로젝트 레포지토리의 Setting &gt; Deploy keys에 등록한다. 이제 Jenkins과 Github을 연동시켰기에, Jenkins에 코드를 가져올 수 있게 되었다. 다음으로는 push했을 때 Jenkins가 push 이벤트를 받을 수 있도록 설정 해보자.마찬가지로 레포지토리의 setting &gt; webhooks 에서 빨간색 네모박스에 Jenkins ip 주소를 입력하고 나머지는 그대로 입력한다. Github에서의 설정은 끝났고 Jenkins 프로젝트에서 다음을 체크함으로써 이벤트 설정은 끝이 났다.이젠 push만 하면 Jenkins 해당 프로젝트에서 빌드가 시작됨을 볼 수 있다. 빌드 기록을 통해 소스 코드가 빌드 중인지 빌드 완료 되었는지를 확인할 수 있다. 이것으로 Jenkins로 CI 환경 구축은 끝이 났다. 2편에서는 CD 환경 구축과 무중단 배포를 구축해보겠다.","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://doyuni.github.io/categories/DevOps/"},{"name":"CI/CD","slug":"DevOps/CI-CD","permalink":"https://doyuni.github.io/categories/DevOps/CI-CD/"}],"tags":[{"name":"NAVER CLOUD","slug":"NAVER-CLOUD","permalink":"https://doyuni.github.io/tags/NAVER-CLOUD/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://doyuni.github.io/tags/Jenkins/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://doyuni.github.io/tags/CI-CD/"}]}]}