{"meta":{"title":"JUST WRITE IT.","subtitle":"","description":"","author":"Geum Doyun","url":"https://doyuni.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-01-20T12:25:32.000Z","updated":"2020-01-25T04:38:20.526Z","comments":true,"path":"tags/index.html","permalink":"https://doyuni.github.io/tags/index.html","excerpt":"","text":"CI/CD Docker Jenkins NAVER CLOUD NGINX Algorithm"},{"title":"categories","date":"2020-01-20T12:25:42.000Z","updated":"2020-01-25T04:38:20.521Z","comments":true,"path":"categories/index.html","permalink":"https://doyuni.github.io/categories/index.html","excerpt":"","text":"DevOps CI/CD Algorithm BOJ Programmers SWEA"}],"posts":[{"title":"ë°±ì¤€ 17472ë²ˆ ë‹¤ë¦¬ ë§Œë“¤ê¸° 2","slug":"Algorithm/BOJ/17472","date":"2020-01-25T08:05:32.000Z","updated":"2020-01-25T13:35:31.290Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17472/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17472/","excerpt":"","text":"#17472. ë‹¤ë¦¬ ë§Œë“¤ê¸° 2Problem ë¬¸ì œë§í¬ Solution ê° ì„¬ì— ê³ ìœ  ë²ˆí˜¸ ë¶™ì´ê¸°(ì˜¤ë¦„ì°¨ìˆœ)ì„¬ë¼ë¦¬ ì—°ê²°ì„ í•´ì•¼í•˜ê¸° ë•Œë¬¸ì— ì´ë¥¼ ì‹ë³„í•´ì£¼ì–´ì•¼ í•œë‹¤.BFS or DFSë¥¼ ì´ìš©í•˜ì—¬ êµ¬í•  ìˆ˜ ìˆê³  í•„ìëŠ” BFSë¥¼ ì‚¬ìš©í•˜ì˜€ë‹¤. ê° ì„¬ë“¤ë§ˆë‹¤ ì—°ê²°ì‹œí‚¤ëŠ” ëª¨ë“  ê²½ìš°ë¥¼ êµ¬í•˜ë˜, ê° ê²½ìš°ë§ˆë‹¤ ì—°ê²°ì´ ê°€ëŠ¥í•œì§€ ê±°ë¦¬ë¥¼ ì¸¡ì •í•˜ë©´ì„œ í™•ì¸í•œë‹¤.â†’ ì—°ê²°ì´ ê°€ëŠ¥í•˜ë©´ í•´ë‹¹ ë‹¤ë¦¬ë¥¼ ì €ì¥í•œë‹¤.(ì–´ë””ì—ì„œ ì–´ë””ë¡œ ì—°ê²°ë˜ê³  ê·¸ëŸ´ ë•Œ ìµœì†Œ ë¹„ìš© ì €ì¥) ë‹¤ë¦¬ë¥¼ ì„ íƒí•´ì„œ 1ê°œ ì´ìƒ ì„ íƒí–ˆì„ ë•Œë¶€í„° ëª¨ë“  ì„¬ì„ ì—°ê²° ì‹œí‚¬ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.â†’ ëª¨ë“  ì„¬ì„ ì—°ê²°í•  ìˆ˜ ìˆìœ¼ë©´ ìµœì†Œë¹„ìš© ê°±ì‹  Answer ì™„íƒ ì½”ë“œ ë³´ê¸° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int N, M, total_island, ans = 1e9;int map[10][10];bool visited[10][10]; // ì„¬ì— ë²ˆí˜¸ ë¶™ì¼ ë•Œ ë°©ë¬¸ ì²´í¬ ìš©ë„int dist[7][7]; // dist[a][b]: aì—ì„œ bë¡œ ê°€ëŠ” ê²½ë¡œ ë¹„ìš©, ê¸°ë³¸ê°’ 1000int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;vector&lt;pair&lt;int, int&gt;&gt; Island_pos[11]; // Island_pos[i]: ië²ˆ ì„¬ì˜ ëª¨ë“  ì¢Œí‘œvector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; bridge_list; // a, b, c : a-&gt;bì˜ ë¹„ìš©ì´ cì¸ ë‹¤ë¦¬ ëª©ë¡bool connect[7][7]; // a, bì™€ì˜ ì—°ê²° ìƒíƒœ í™•ì¸ ìš©ë„bool connect_island[7]; // ië²ˆ ì„¬ì˜ ë°©ë¬¸ ì²´í¬ ìš©ë„bool selected[7 * 7]; // ê°„ì„ ì˜ ëª¨ë“  ê²½ìš°ë¥¼ ë‹´ê¸° ìœ„í•¨( N(N-1)/2 )void BFS(int x, int y, int id) &#123; // ì„¬ì— ë²ˆí˜¸ ë¶™ì´ê¸° queue&lt;pair&lt;int, int&gt; &gt; q; q.push(&#123; x, y &#125;); visited[x][y] = true; map[x][y] = id; Island_pos[id].push_back(&#123; x, y &#125;); while (!q.empty()) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; N &amp;&amp; d_y &lt; M) &#123; if (visited[d_x][d_y] || map[d_x][d_y] != 1) continue; visited[d_x][d_y] = true; map[d_x][d_y] = id; Island_pos[id].push_back(&#123; d_x, d_y &#125;); q.push(&#123; d_x, d_y &#125;); &#125; &#125; &#125;&#125;void Go(int x, int y, int dir, int len, int start, int end) &#123; // ê±°ë¦¬ ì¸¡ì •í•˜ê¸° int nx = x + dx[dir]; int ny = y + dy[dir]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= M) return; if (map[nx][ny] == end) &#123; if (len &gt; 1) &#123; // ê±°ë¦¬ 2ì´ìƒì¸ ê²½ìš°ë§Œ ì—°ê²° ê°€ëŠ¥ if (dist[start][end] &gt; len) &#123; // ìµœì†Œ ê±°ë¦¬ ê°±ì‹  dist[start][end] = len; dist[end][start] = len; &#125; &#125; return; &#125; else if (map[nx][ny] == 0) Go(nx, ny, dir, len + 1, start, end); else return;&#125;void MakeBridge(int start, int end) &#123; //Startì— í•´ë‹¹ë˜ëŠ” ì„¬ì˜ ëª¨ë“  ì¢Œí‘œë¥¼ endì— í•´ë‹¹ë˜ëŠ” ì„¬ê¹Œì§€ ë„ë‹¬í•´ë³¸ë‹¤. for (int i = 0; i &lt; Island_pos[start].size(); i++) &#123; int x = Island_pos[start][i].first; int y = Island_pos[start][i].second; for (int dir = 0; dir &lt; 4; ++dir) &#123; int nx = x + dx[dir]; int ny = y + dy[dir]; if (nx &gt; -1 &amp;&amp; ny &gt; -1 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M) &#123; if (map[nx][ny] == 0) Go(nx, ny, dir, 1, start, end); // í•œ ë°©í–¥ìœ¼ë¡œ ê°€ì•¼í•¨, 0ì¸ ì§€ì  ë°©ë¬¸ì´ë‹ˆ ê±°ë¦¬ 1 &#125; &#125; &#125;&#125;void GetDistance() &#123; // ì„¬ë“¤ë¼ë¦¬ 1:1ë¡œ ì—°ê²°ì‹œí‚¤ëŠ” ëª¨ë“  ê²½ìš° for (int i = 1; i &lt; total_island; i++) &#123; for (int j = i + 1; j &lt; total_island; j++) &#123; MakeBridge(i, j); if (dist[i][j] == 1000) continue; // ì—°ê²° ë¶ˆê°€ëŠ¥í•œ ê²½ìš° bridge_list.push_back(&#123; &#123;i, j&#125;, dist[i][j] &#125;); // (i -&gt; j : ë¹„ìš©) ì €ì¥ &#125; &#125;&#125;bool CheckConnect() &#123; // ì¡°ê±´ì— ë§ê²Œ ëª¨ë“  ì„¬ì´ ì—°ê²°ë˜ì–´ìˆëŠ”ì§€ í™•ì¸ memset(connect, false, sizeof(connect)); memset(connect_island, false, sizeof(connect_island)); for (int i = 0; i &lt; bridge_list.size(); i++) // ì„ íƒí•œ ë‹¤ë¦¬ ì—°ê²° í‘œì‹œ &#123; if (selected[i]) &#123; // ì—°ê²° í‘œì‹œ (x-&gt;y, y-&gt;x) int x = bridge_list[i].first.first; int y = bridge_list[i].first.second; connect[x][y] = connect[y][x] = true; &#125; &#125; queue&lt;int&gt; q; q.push(1); // 1ë²ˆ ì„¬(ì„¬ì€ ìµœì†Œ 2ê°œ) connect_island[1] = true; // 1ë²ˆ ì„¬ ë°©ë¬¸ ì²´í¬ int Island_cnt = 1; bool flag = false; while (!q.empty()) &#123; // ëª¨ë“  ì„¬ ë°©ë¬¸ê°€ëŠ¥í•œì§€ ì²´í¬í•˜ëŠ” ë¶€ë¶„ int cur = q.front(); q.pop(); if (Island_cnt == total_island - 1) &#123; flag = true; break; &#125; for (int i = 1; i &lt; total_island; i++) &#123; if (cur == i) continue; if (connect[cur][i] &amp;&amp; connect_island[i] == false) &#123; // í˜„ì¬ ì„¬ê³¼ ië²ˆ ì„¬ì´ ì—°ê²°ë˜ì–´ìˆê³  ië²ˆ ì„¬ì„ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ì„ ë•Œ connect_island[i] = true; q.push(i); Island_cnt++; &#125; &#125; &#125; return flag;&#125;void SelectBridge(int idx, int cnt, int sum) &#123; if (cnt &gt;= 1) &#123; if (CheckConnect() == true) &#123; if (ans &gt; sum) ans = sum; &#125; &#125; for (int i = idx; i &lt; bridge_list.size(); ++i) &#123; if (selected[i] == true) continue; selected[i] = true; SelectBridge(i, cnt + 1, sum + bridge_list[i].second); selected[i] = false; &#125;&#125;int main() &#123; for (int i = 0; i &lt; 7; ++i) &#123; for (int j = 0; j &lt; 7; j++) &#123; dist[i][j] = 1000; &#125; &#125; cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; int id = 1; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; if (map[i][j] != 0 &amp;&amp; !visited[i][j]) BFS(i, j, id++); &#125; &#125; total_island = id; GetDistance(); SelectBridge(0, 0, 0); if (ans == 1e9) ans = -1; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; Solution ìœ„ ë°©ì‹ì—ì„œ 1, 2ê¹Œì§€ëŠ” ë™ì¼ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•œë‹¤. Answer ì½”ë“œ ë³´ê¸°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; d;struct Bridge &#123; int from; int to; int len;&#125;;int N, M, total, ans = 10000;int map[10][10];bool visited[10][10];int parent[7];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;vector&lt;d&gt; island[7];vector&lt;Bridge&gt; bridge;int Go(int from, int to) &#123; int len = 10000; for (int i = 0; i &lt; island[from].size(); i++)&#123; int x = island[from][i].first; int y = island[from][i].second; for (int dir = 0; dir &lt; 4; ++dir) &#123; int nx = x; int ny = y; int cur = 0; while (true) &#123; if (len &lt;= cur) break; nx += dx[dir]; ny += dy[dir]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= M) break; if (map[nx][ny] == 0) &#123; cur++; &#125; else if (map[nx][ny] == to) &#123; if (cur &lt; 2) break; if (len &gt; cur) len = cur; break; &#125; else break; &#125; &#125; &#125; return len;&#125;void GetDistance() &#123; Bridge b; for (int i = 1; i &lt;= total; ++i) &#123; for (int j = i + 1; j &lt;= total; ++j) &#123; b.from = i; b.to = j; b.len = Go(i, j); if (b.len == 10000) continue; bridge.push_back(b); &#125; &#125;&#125;void BFS(int r, int c, int id) &#123; queue&lt;d&gt; q; q.push(&#123; r, c &#125;); visited[r][c] = true; map[r][c] = id; island[id].push_back(&#123; r, c &#125;); while (!q.empty()) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int nx = x + dx[dir]; int ny = y + dy[dir]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= M) continue; if (map[nx][ny] != 1 || visited[nx][ny]) continue; visited[nx][ny] = true; map[nx][ny] = id; island[id].push_back(&#123; nx, ny &#125;); q.push(&#123; nx, ny &#125;); &#125; &#125;&#125;void MakeLabel() &#123; int id = 1; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; if (map[i][j] == 0 || visited[i][j]) continue; BFS(i, j, id++); &#125; &#125; total = id - 1; for (int i = 1; i &lt;= total; ++i) &#123; parent[i] = i; &#125;&#125;int cmp(Bridge a, Bridge b) &#123; return a.len &lt; b.len;&#125;int FindParent(int idx) &#123; if (parent[idx] == idx) return idx; else return FindParent(parent[idx]);&#125;void Union(int from, int to) &#123; int p1 = FindParent(parent[from]); int p2 = FindParent(parent[to]); if (p1 &lt; p2) &#123; parent[to] = p1; parent[p2] = p1; &#125; else &#123; parent[from] = p2; parent[p1] = p2; &#125;&#125;bool CheckConnection() &#123; for (int i = 1; i &lt;= total; ++i) &#123; if (FindParent(parent[i]) != 1) return false; &#125; return true;&#125;void Kruskal() &#123; sort(bridge.begin(), bridge.end(), cmp); int cost = 0; for (int i = 0; i &lt; bridge.size(); ++i) &#123; int from = bridge[i].from; int to = bridge[i].to; if(FindParent(from) == FindParent(to)) continue; else &#123; Union(from, to); cost += bridge[i].len; &#125; &#125; if (CheckConnection()) ans = cost;&#125;void Solve() &#123; MakeLabel(); GetDistance(); Kruskal();&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; Solve(); if (ans == 10000) ans = -1; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 17471ë²ˆ ê²Œë¦¬ë§¨ë”ë§","slug":"Algorithm/BOJ/17471","date":"2020-01-25T08:05:30.000Z","updated":"2020-01-25T13:35:31.291Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17471/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17471/","excerpt":"","text":"#17471. ê²Œë¦¬ë§¨ë”ë§Problem ë¬¸ì œë§í¬ Solution city[n][j] = në²ˆì§¸ êµ¬ì—­ê³¼ ì¸ì ‘í•œêµ¬ì—­ jëŠ” 1ë¡œ í‘œì‹œ, ì•„ë‹ˆë©´ 0ìœ¼ë¡œ í‘œì‹œ í•œ ì§€ì—­ì˜ êµ¬ì—­ì„ ì •í•œë‹¤. (ì¤‘ë³µx, ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ) - (1,2,3) ê³¼ (2,1,3)ì€ ê°™ì€ ì¡°í•©ì´ê¸°ì— ì •í•œ êµ¬ì—­ì´ ì´ì–´ì ¸ ìˆëŠ”ì§€ DFSë¥¼ í†µí•´ í™•ì¸í•œë‹¤. ë°©ë¬¸í‘œì‹œ ì „ì²´ êµ¬ì—­ íƒìƒ‰í•˜ì—¬ í•´ë‹¹ ì§€ì—­ì— ì†í•˜ê³  ì¸ì ‘í•  ë•Œ, í•´ë‹¹ êµ¬ì—­ íƒìƒ‰ DFS ì‹œì‘ ì§€ì ì€ í•´ë‹¹ ì§€ì—­ì—ì„œ í•œ êµ¬ì—­ìœ¼ë¡œ ì§€ì •í•œë‹¤. (ê·¸ë˜ì•¼ ëª¨ë‘ ì¸ì ‘í•´ìˆëŠ”ì§€ í™•ì¸ ê°€ëŠ¥) 2ê°œì˜ ì§€ì—­ ëª¨ë‘ DFS íƒìƒ‰ í›„ì— check í‘œì‹œê°€ ëª¨ë‘ ë˜ì–´ìˆì§€ ì•Šìœ¼ë©´ returní•œë‹¤. ê·œì¹™ì— ë§ê²Œ êµ¬ì—­ì´ ë‚˜ëˆ„ì–´ì ¸ ìˆì§€ ì•Šë‹¤ëŠ” ëœ»ì´ê¸° ë•Œë¬¸ì´ë‹¤. 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int N, ans = 1e9;bool selected[11];int people[11];int city[11][11];bool check[11];void getDifference() &#123; int a_sum = 0, b_sum = 0; for (int i = 1; i &lt;= N; ++i) &#123; if (selected[i]) a_sum += people[i]; else b_sum += people[i]; &#125; int res = abs(a_sum - b_sum); if (res &lt; ans) ans = res;&#125;void DFS(int n, int status) &#123; check[n] = true; for (int i = 1; i &lt;= N; ++i) &#123; if (check[i]) continue; if (status == 1) &#123; if (selected[i] &amp;&amp; city[n][i]) &#123; check[i] = true; DFS(i, status); &#125; &#125; else &#123; if (!selected[i] &amp;&amp; city[n][i]) &#123; check[i] = true; DFS(i, status); &#125; &#125; &#125;&#125;void Solve() &#123; memset(check, 0, sizeof(check)); for (int i = 1; i &lt;= N; ++i) &#123; if (selected[i]) &#123; DFS(i, 1); break; &#125; &#125; for (int i = 1; i &lt;= N; ++i) &#123; if (!selected[i]) &#123; DFS(i, 0); break; &#125; &#125; for (int i = 1; i &lt;= N; ++i) &#123; if (!check[i]) return; &#125; getDifference();&#125;void SelectArea(int n, int cnt) &#123; if (cnt &gt;= N) return; if (cnt &gt;= 1) &#123; Solve(); &#125; for (int i = n; i &lt;= N; ++i) &#123; if (selected[i]) continue; selected[i] = true; SelectArea(i, cnt + 1); selected[i] = false; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 1; i &lt;= N; ++i) &#123; cin &gt;&gt; people[i]; &#125; for (int i = 1; i &lt;= N; ++i) &#123; int cnt; cin &gt;&gt; cnt; for (int j = 0; j &lt; cnt; ++j) &#123; int n; cin &gt;&gt; n; city[i][n] = 1; &#125; &#125; SelectArea(1, 0); if (ans == 1e9) ans = -1; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 17406ë²ˆ ë°°ì—´ ëŒë¦¬ê¸° 4","slug":"Algorithm/BOJ/17406","date":"2020-01-25T08:05:23.000Z","updated":"2020-01-25T13:35:31.288Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17406/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17406/","excerpt":"","text":"#17406. ë°°ì—´ ëŒë¦¬ê¸° 4Problem ë¬¸ì œë§í¬ Solution íšŒì „ ì—°ì‚° ìˆœì„œë¥¼ ì •í•œë‹¤. (0, 1, 2) ì™€ (1, 0, 2)ëŠ” ë‹¤ë¥¸ ìˆœì„œì´ë‹¤! ê°€ì¥ ë°”ê¹¥ìª½ ë¶€í„° ì‹œê³„ë°©í–¥ìœ¼ë¡œ ê° ì›ì†Œë“¤ì„ íšŒì „ì‹œí‚¨ë‹¤.ê°€ì¥ ë°”ê¹¥ìª½ í¬ê¸°ëŠ” 2*s+1ì´ë‹¤. ì‹œì‘ ì§€ì ë¶€í„° ì‹œì‘í•´ì„œ +1ì”©, í¬ê¸°ëŠ” -2ì”© ë³€ê²½í•˜ë©° íšŒì „ì‹œí‚¨ë‹¤. ì¤‘ì•™ ì§€ì ìœ¼ ë§Œë‚˜ë©´ ë”ì´ìƒ íšŒì „ì‹œí‚¬ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì¢…ë£Œí•œë‹¤. íšŒì „ì€ ì•„ë˜ì™€ ê°™ì€ ë°©ë²•ìœ¼ë¡œ ì§„í–‰í•œë‹¤. â€œë¯¸ì„¸ë¨¼ì§€ ì•ˆë…•!â€ ë¬¸ì œì—ì„œ ì„¤ëª…í•œ ë°°ì—´ íšŒì „ ë°©ë²•ê³¼ ë™ì¼í•˜ë‹¤.ì—¬ê¸°ì„  ì‹œê³„ë°©í–¥ì´ë¯€ë¡œ 2ë²ˆì§¸ ê·¸ë¦¼ì´ ì´ì— í•´ë‹¹í•œë‹¤. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;using namespace std;int N, M, K, ans = 1e9;int arr[50][50];int copy_arr[50][50];int order[6];bool selected[6];struct Inst &#123; int r, c, s;&#125;ins[6];void CopyArray() &#123; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; copy_arr[i][j] = arr[i][j]; &#125; &#125;&#125;int getSum() &#123; int res = 1e9; for (int i = 0; i &lt; N; ++i) &#123; int sum = 0; for (int j = 0; j &lt; M; ++j) &#123; sum += copy_arr[i][j]; &#125; if (res &gt; sum) res = sum; &#125; return res;&#125;void Rotate() &#123; CopyArray(); for (int i = 0; i &lt; K; ++i) &#123; int len = ins[order[i]].s * 2 + 1; // ê°€ì¥ ë°”ê¹¥ìª½ í¬ê¸° int mid_r = ins[order[i]].r; // ì¤‘ì‹¬ ì¢Œí‘œ int mid_c = ins[order[i]].c; int start_r = ins[order[i]].r - ins[order[i]].s; // ì‹œì‘ ì¢Œí‘œ int start_c = ins[order[i]].c - ins[order[i]].s; while (true) &#123; if (mid_r == start_r &amp;&amp; mid_c == start_c) break; // ì¤‘ì‹¬ì ì´ë©´ ì¢…ë£Œ int temp = copy_arr[start_r][start_c]; // ì‹œì‘ì§€ì  ê°’ë§Œ ë¹¼ë†“ê¸° int end_r = start_r + len - 1; // ë í–‰ int end_c = start_c + len - 1; // ë ì—´ for (int r = start_r; r &lt; start_r + len - 1; ++r) &#123; // (1) copy_arr[r][start_c] = copy_arr[r + 1][start_c]; &#125; for (int c = start_c; c &lt; start_c + len - 1; ++c) &#123; // (2) copy_arr[end_r][c] = copy_arr[end_r][c + 1]; &#125; for (int r = end_r; r &gt; start_r; --r) &#123; // (3) copy_arr[r][end_c] = copy_arr[r - 1][end_c]; &#125; for (int c = end_c; c &gt; start_c + 1; --c) &#123; // (4) copy_arr[start_r][c] = copy_arr[start_r][c - 1]; &#125; copy_arr[start_r][start_c + 1] = temp; // ë¹¼ë†“ì€ ê°’ ë„£ê¸° start_r++; start_c++; len -= 2; // ì‹œì‘ì§€ì  ë° ê¸¸ì´ ê°±ì‹  &#125; &#125; int res = getSum(); if (ans &gt; res) ans = res;&#125;void SelectOrder(int cnt) &#123; if (cnt == K) &#123; Rotate(); return; &#125; for (int i = 0; i &lt; K; ++i) &#123; if (selected[i]) continue; order[cnt] = i; selected[i] = true; SelectOrder(cnt + 1); selected[i] = false; &#125;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; cin &gt;&gt; arr[i][j]; &#125; &#125; for (int i = 0; i &lt; K; ++i) &#123; int r, c, s; cin &gt;&gt; r &gt;&gt; c &gt;&gt; s; ins[i] = &#123; r-1, c-1, s &#125;; &#125; SelectOrder(0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 17298ë²ˆ ì˜¤í°ìˆ˜","slug":"Algorithm/BOJ/17298","date":"2020-01-25T08:04:55.000Z","updated":"2020-01-25T13:33:14.417Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17298/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17298/","excerpt":"","text":"#17298. ì˜¤í°ìˆ˜ë¬¸ì œë§í¬ Problem ê¸¸ì´ê°€ Nì¸ ìˆ˜ì—´ Goal: ê° ì›ì†Œì— ëŒ€í•´ ìì‹ ë³´ë‹¤ ì˜¤ë¥¸ìª½ì— ìˆìœ¼ë©´ì„œ í¬ê³  ê°€ì¥ ì™¼ìª½ì— ìœ„ì¹˜í•œ ìˆ˜ë¥¼ êµ¬í•˜ì—¬ë¼ì—†ë‹¤ë©´ -1 ì¶œë ¥ Solution Stackì„ ì‚¬ìš©í•œë‹¤. ë‹¨ê³„ëŠ” ë¬¸ì œì— ì˜ˆì‹œë¡œ ìˆëŠ” ì…ë ¥ ê°’ìœ¼ë¡œ ì„¤ëª…ì„ í•˜ê² ë‹¤. ì˜¤ë¥¸ìª½ ìˆœì„œë¡œ ë‹¨ê³„ê°€ ì§„í–‰ëœë‹¤. ì›ì†Œì˜ ìµœëŒ“ê°’ì€ ìµœëŒ€ 1000000(ë°±ë§Œ)ì´ê¸°ì— +1ê°’ì„ MAXë¡œ ì£¼ì—ˆë‹¤. ìˆ˜ì—´ì˜ ë§¨ ì˜¤ë¥¸ìª½ë¶€í„° ì§„í–‰í•œë‹¤. ì‚¬ì´í´ ë¹„êµ ëŒ€ìƒì¸ ì…ë ¥ê°’ê³¼ ìŠ¤í…ì— ìˆëŠ” ê°’ì„ ë¹„êµí•˜ì—¬ ìŠ¤í…ì— ìˆëŠ” ê°’ì´ í´ ë•Œê¹Œì§€ ì‘ì—…(ë¹„êµ)ì„ ìˆ˜í–‰í•œë‹¤. ë§Œì•½ MAXê°€ ìŠ¤í…ì˜ topì´ë¼ë©´ ì´ë¯¸ ìì‹ ë³´ë‹¤ í° ìˆ˜ê°€ ì—†ë‹¤ëŠ” ëœ»ì´ê¸°ì— -1ë¥¼ ì¶œë ¥ê°’ì— ë„£ì–´ì¤€ë‹¤. ê·¸ê²Œ ì•„ë‹ˆë¼ë©´ ìŠ¤í…ì˜ topì€ í•­ìƒ í˜„ì¬ ì…ë ¥ê°’ë³´ë‹¤ í¬ë©´ì„œ ê°€ì¥ ì˜¤ë¥¸ìª½ì— ìˆëŠ” ìˆ˜ì´ë‹¤. ê·¸ë ‡ê¸°ì— topì„ ì¶œë ¥ê°’ì— ë„£ì–´ì¤€ë‹¤. 1 Try123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;vector&gt;#define MAX 1000001using namespace std;stack&lt;int&gt; a, ans, num;int main() &#123; int n, input; scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf(\"%d\", &amp;input); num.push(input); &#125; a.push(MAX); while(!num.empty()) &#123; while(a.top() &lt;= num.top()) a.pop(); // ê°™ì„ ë•Œë„ popì„ í•´ì£¼ì–´ì•¼ ë‹¤ìŒ í° ê°’ì„ ë¹„êµê°€ëŠ¥ if(a.top() == MAX) ans.push(-1); else ans.push(a.top()); a.push(num.top()); num.pop(); &#125; while(!ans.empty()) &#123; printf(\"%d \", ans.top()); ans.pop(); &#125; printf(\"\\n\"); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 17281ë²ˆ âš¾(ì•¼êµ¬ê³µ)","slug":"Algorithm/BOJ/17281","date":"2020-01-25T08:04:49.000Z","updated":"2020-01-25T13:30:54.806Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17281/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17281/","excerpt":"","text":"#17281. âš¾Problem ë¬¸ì œë§í¬ Solutionì‹œë®¬ë ˆì´ì…˜ ë¬¸ì œì´ë‹¤. ë¬¸ì œì˜ ì„¤ëª…ì— ë§ê²Œ ì˜ êµ¬í˜„í•˜ë©´ í° ì–´ë ¤ì›€ì€ ì—†ëŠ” ë¬¸ì œ íƒ€ìì˜ ìˆœë²ˆì„ ì •í•œë‹¤. (1ë²ˆ ì„ ìˆ˜ëŠ” 4ë²ˆ íƒ€ìë¡œ ê³ ì •) â†’ (1, 2, 3)ê³¼ (2, 1, 3)ì€ ë‹¤ë¥¸ ìˆœì„œì„ 1ì´ë‹ë¶€í„° Nì´ë‹ê¹Œì§€ ê²½ê¸°ë¥¼ ì§„í–‰í•œë‹¤. ê° ì´ë‹ë³„ ì§„í–‰ íë¦„ ì´ì „ ìˆœë²ˆ ë°”ë¡œ ë‹¤ìŒë¶€í„° ìˆœë²ˆì´ ì§„í–‰ëœë‹¤. (ì²« ì´ë‹ì€ 1ë²ˆë¶€í„°(ì¸ë±ìŠ¤ìƒ 0)) ì•„ì›ƒì´ 3ë²ˆì´ ë  ë•Œê¹Œì§€ ì§„í–‰í•œë‹¤. 1ë£¨, 2ë£¨, 3ë£¨ì— ì„ ìˆ˜ê°€ ìˆëŠ”ì§€ í‘œì‹œí•˜ëŠ” is_there ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì§„í–‰í•œë‹¤. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;using namespace std;int N, ans;int info[50][9]; // ê° ì´ë‹ë³„ íƒ€ì ì •ë³´int order[9]; // íƒ€ì ìˆœë²ˆbool selected[9];void Game() &#123; int idx = 0, score = 0; // ìˆœë²ˆ ì¸ë±ìŠ¤, í˜„ì¬ ì ìˆ˜ for(int inning = 0; inning &lt; N; ++inning) &#123; bool is_there[3] = &#123; false, false, false &#125;; // 1, 2, 3ë£¨ int out = 0; while (true) &#123; if (info[inning][order[idx]] == 0) &#123; // ì•„ì›ƒ out++; &#125; else if (info[inning][order[idx]] == 1) &#123; // 1ë£¨íƒ€ if (is_there[2]) &#123; // 3ë£¨íƒ€ -&gt; í™ˆ score++; is_there[2] = false; &#125; for (int i = 1; i != -1; --i) &#123; // ê°ê° 1 ì „ì§„ if (is_there[i]) &#123; is_there[i + 1] = true; is_there[i] = false; &#125; &#125; is_there[0] = true; // 1ë£¨ ì „ì§„ &#125; else if (info[inning][order[idx]] == 2) &#123; // 2ë£¨íƒ€ for (int i = 1; i &lt; 3; ++i) &#123; // 2ë£¨, 3ë£¨ -&gt; í™ˆ if (is_there[i]) &#123; score++; is_there[i] = false; &#125; &#125; if (is_there[0]) &#123; // 1ë£¨ -&gt; 3ë£¨ is_there[2] = true; is_there[0] = false; &#125; is_there[1] = true; // 2ë£¨ ì „ì§„ &#125; else if (info[inning][order[idx]] == 3) &#123; // 3ë£¨íƒ€ for (int i = 0; i &lt; 3; ++i) &#123; // 1, 2, 3ë£¨ -&gt; í™ˆ if (is_there[i]) &#123; score++; is_there[i] = false; &#125; &#125; is_there[2] = true; // 3ë£¨ ì „ì§„ &#125; else &#123; // í™ˆëŸ° for (int i = 0; i &lt; 3; ++i) &#123; if (is_there[i]) &#123; score++; is_there[i] = false; &#125; &#125; score++; &#125; idx = (idx + 1) % 9; // ë‹¤ìŒ ìˆœë²ˆ if (out == 3) break; // 3ì§„ ì•„ì›ƒ &#125; &#125; if (ans &lt; score) ans = score;&#125;void SelectOrder(int cnt) &#123; if (cnt == 9) &#123; Game(); return; &#125; if (cnt == 3) cnt++; for (int i = 1; i &lt; 9; ++i) &#123; if (selected[i]) continue; selected[i] = true; order[cnt] = i; SelectOrder(cnt + 1); selected[i] = false; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; 9; ++j) &#123; cin &gt;&gt; info[i][j]; &#125; &#125; selected[0] = true; order[3] = 0; // 1ë²ˆ ì„ ìˆ˜ 4ë²ˆì§¸ ê³ ì • SelectOrder(0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 17144ë²ˆ ë¯¸ì„¸ë¨¼ì§€ ì•ˆë…•!","slug":"Algorithm/BOJ/17144","date":"2020-01-25T08:04:44.000Z","updated":"2020-01-25T13:42:17.182Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17144/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17144/","excerpt":"","text":"#17144. ë¯¸ì„¸ë¨¼ì§€ ì•ˆë…•!ë¬¸ì œë§í¬ Problem ê³µê¸°ì²­ì •ê¸° í•­ìƒ ì™¼ìª½ ì—´ (ë‘ í–‰ ì°¨ì§€) ê·¸ì™¸ ë¯¸ì„¸ë¨¼ì§€ë‚˜ ë¹ˆ ì¹¸ì´ ì¡´ì¬ 1ì´ˆ ë™ì•ˆ ì¼ì–´ë‚˜ëŠ” ì¼ ë¯¸ì„¸ë¨¼ì§€ í™•ì‚°4ë°©í–¥(ìƒí•˜ì¢Œìš°)ê³µê¸°ì²­ì •ê¸°ë‚˜ ê²½ê³„ë¥¼ ë²—ì–´ë‚˜ëŠ” ì¹¸ì€ í™•ì‚°ì´ ì¼ì–´ë‚˜ì§€ ì•ŠìŒë¯¸ì„¸ë¨¼ì§€ ì–‘/5 ë§Œí¼ í™•ì‚°ëœë‹¤. (ê° ë°©í–¥ì— ëŒ€í•´ í•œ ì¹¸)í™•ì‚°ëœ í›„ ë‚¨ì€ ë¯¸ì„¸ë¨¼ì§€ ì–‘ì€í˜„ì¬ ë¯¸ì„¸ë¨¼ì§€ ì–‘ - í˜„ì¬ ë¯¸ì„¸ë¨¼ì§€ ì–‘/5 * í™•ì‚°ëœ ë°©í–¥ ê°œìˆ˜ ê³µê¸°ì²­ì •ê¸° ì‘ë™ (ë°”ëŒ)ìœ„ìª½ â†’ ë°˜ì‹œê³„ë°©í–¥ ìˆœí™˜ì•„ë˜ìª½ â†’ ì‹œê³„ë°©í–¥ ìˆœí™˜ë¯¸ì„¸ë¨¼ì§€ê°€ ë°”ëŒì˜ ë°©í–¥ëŒ€ë¡œ í•œ ì¹¸ì”© ì´ë™ë¯¸ì„¸ë¨¼ì§€ê°€ ê³µê¸°ì²­ì •ê¸°ë¡œ ë“¤ì–´ê°€ë©´ ëª¨ë‘ ì •í™” Goal: Tì´ˆê°€ ì§€ë‚œ í›„ ë‚¨ì•„ìˆëŠ” ë¯¸ì„¸ë¨¼ì§€ì˜ ì–‘ Solution1ì´ˆê°€ ì§€ë‚  ë•Œë§ˆë‹¤ ë‹¤ìŒê³¼ ê°™ì€ ì‘ì—…ì´ ìˆ˜í–‰ëœë‹¤. ë¯¸ì„¸ë¨¼ì§€ í™•ì‚° ë°”ëŒìœ¼ë¡œ ì¸í•œ ì´ë™ ë¯¸ì„¸ë¨¼ì§€ í™•ì‚° 5 ì´ìƒì¸ ê°’ë§Œ í™•ì‚°ì´ ì¼ì–´ë‚œë‹¤.í™•ì‚°ì´ ì¼ì–´ë‚˜ê¸° ì „ì— queueì— ì´ ê°’ê³¼ ì´ ê°’ì´ ìˆëŠ” ìœ„ì¹˜ë¥¼ ì €ì¥í•´ë†“ëŠ”ë‹¤.(ê°’ì„ ì €ì¥í•´ì•¼ ì˜¬ë°”ë¥¸ ê°’ì„ êµ¬í•  ìˆ˜ ìˆìŒ)queueì—ì„œ í•˜ë‚˜ì”© êº¼ë‚´ì–´ 4ê°€ì§€ ë°©í–¥ì„ í™•ì¸í•œë‹¤.(ê³µê¸°ì²­ì •ê¸° ìˆëŠ” ê³³ê³¼ ê²½ê³„ë¥¼ ë„˜ëŠ” ê³³ì€ ë¶ˆê°€ëŠ¥)1234567891011121314151617void spread() &#123; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().r; int c = q.front().c; int mid = q.front().value; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; map[x][y] != -1) &#123; map[x][y] += mid / 5; map[r][c] -= mid / 5; &#125; &#125; &#125;&#125;í™•ì‚°ì´ ê°€ëŠ¥í•˜ë‹¤ë©´ ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤. ë°”ëŒìœ¼ë¡œ ì¸í•œ ì´ë™ ì•„ë˜ ìˆœì„œëŒ€ë¡œ mapì„ ë°”ê¿”ì¤€ë‹¤. ê³µê¸°ì²­ì •ê¸°ë¡œ ë“¤ì–´ê°„ë‹¤ëŠ” ê²ƒì€ êµ³ì´ ê°’ì„ ë°”ê¿”ì¤„ í•„ìš” ì—†ì´ ì „ì˜ ê°’ì´ ì´ë¥¼ ë®ì–´ì£¼ê¸°ë§Œ í•˜ë©´ ëœë‹¤. (1ë²ˆì§¸) â†’ ì•„ë˜ 2ë²ˆ í™”ì‚´í‘œê°€ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤â€¦.(ë°˜ëŒ€ì…ë‹ˆë‹¤)ê³µê¸°ì²­ì •ê¸°ì—ì„œ ë‚˜ì•„ê°€ëŠ” ë°”ëŒìœ¼ë¡œ(4ë²ˆì§¸) ê°’ì„ 0ìœ¼ë¡œ ì±„ì›Œì£¼ì–´ì•¼ í•œë‹¤.1234567891011121314151617181920212223242526272829303132void wind() &#123; int i, j, clean_row = clean[0];// ìœ„ìª½ for (i = clean_row - 2; i &gt;= 0; --i) &#123; map[i + 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[0][j - 1] = map[0][j]; &#125; for (i = 1; i &lt;= clean_row; ++i) &#123; map[i - 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 1; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125;// ì•„ë˜ìª½ map[clean_row][1] = 0; clean_row = clean[1]; for (i = clean_row + 2; i &lt; total_row; ++i) &#123; map[i - 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[total_row - 1][j - 1] = map[total_row - 1][j]; &#125; for (i = total_row - 2; i &gt;= clean_row; --i) &#123; map[i + 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 2; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0;&#125; 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;queue&gt;#define MAX 50using namespace std;int total_row, total_col, time;int map[MAX][MAX];int clean[2]; struct info &#123; int r, c, value;&#125;;queue&lt;info&gt; q;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; total_row &amp;&amp; c &lt; total_col) return true; return false;&#125;void spread() &#123; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().r; int c = q.front().c; int mid = q.front().value; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; map[x][y] != -1) &#123; map[x][y] += mid / 5; map[r][c] -= mid / 5; &#125; &#125; &#125;&#125;void wind() &#123; int i, j, clean_row = clean[0]; for (i = clean_row - 2; i &gt;= 0; --i) &#123; map[i + 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[0][j - 1] = map[0][j]; &#125; for (i = 1; i &lt;= clean_row; ++i) &#123; map[i - 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 1; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0; clean_row = clean[1]; for (i = clean_row + 2; i &lt; total_row; ++i) &#123; map[i - 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[total_row - 1][j - 1] = map[total_row - 1][j]; &#125; for (i = total_row - 2; i &gt;= clean_row; --i) &#123; map[i + 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 2; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0;&#125;int main() &#123; int answer, idx = 0; scanf(\"%d %d %d\", &amp;total_row, &amp;total_col, &amp;time); for (int i = 0; i &lt; total_row; ++i) &#123; for (int j = 0; j &lt; total_col; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); if (map[i][j] &gt;= 5) q.push(&#123; i, j, map[i][j] &#125;); &#125; if (map[i][0] == -1) clean[idx++] = i; &#125; while (time--) &#123; answer = 0; spread(); wind(); for (int i = 0; i &lt; total_row; ++i) &#123; for (int j = 0; j &lt; total_col; ++j) &#123; if (map[i][j] &gt; 0) answer += map[i][j]; if (map[i][j] &gt;= 5) q.push(&#123; i, j, map[i][j] &#125;); &#125; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ëŠ” ë‹¤ ë§ë‹¤ëŠ”ë° í‹€ë ¸ë‹¨ë‹¤â€¦ã… ê·¸ ì´ìœ ëŠ” MAXë¥¼ 50ì´ê¸° ë•Œë¬¸ì´ë‹¤. (ì‘? ë­” ğŸ™„ğŸ¤”â€¦ë‹¤ìŒë¶€í„° ë„‰ë„‰íˆ ì¡ì..)MAX 51ë¡œ ê³ ì³ì£¼ë‹ˆê¹Œ ë°”ë¡œ ì •ë‹µ ì²˜ë¦¬ ë˜ì—ˆë‹¤. 2 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;queue&gt;#define MAX 51using namespace std;int total_row, total_col, time;int map[MAX][MAX];int clean[2];struct info &#123; int r, c, value;&#125;;queue&lt;info&gt; q;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; total_row &amp;&amp; c &lt; total_col) return true; return false;&#125;void spread() &#123; while(!q.empty()) &#123; int r = q.front().r; int c = q.front().c; int mid = q.front().value; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; map[x][y] != -1) &#123; map[x][y] += mid / 5; map[r][c] -= mid / 5; &#125; &#125; &#125;&#125;void wind() &#123; int i, j, clean_row = clean[0]; for (i = clean_row - 2; i &gt;= 0; --i) &#123; map[i + 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[0][j - 1] = map[0][j]; &#125; for (i = 1; i &lt;= clean_row; ++i) &#123; map[i - 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 1; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0; clean_row = clean[1]; for (i = clean_row + 2; i &lt; total_row; ++i) &#123; map[i - 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[total_row - 1][j - 1] = map[total_row - 1][j]; &#125; for (i = total_row - 2; i &gt;= clean_row; --i) &#123; map[i + 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 2; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0;&#125;int main() &#123; int answer, idx = 0; scanf(\"%d %d %d\", &amp;total_row, &amp;total_col, &amp;time); for (int i = 0; i &lt; total_row; ++i) &#123; for (int j = 0; j &lt; total_col; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); if (map[i][j] &gt;= 5) q.push(&#123; i, j, map[i][j] &#125;); &#125; if (map[i][0] == -1) clean[idx++] = i; &#125; while (time--) &#123; answer = 0; spread(); wind(); for (int i = 0; i &lt; total_row; ++i) &#123; for (int j = 0; j &lt; total_col; ++j) &#123; if (map[i][j] &gt; 0) answer += map[i][j]; if (map[i][j] &gt;= 5) q.push(&#123; i, j, map[i][j] &#125;); &#125; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; Debug ì½”ë“œ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;#include &lt;queue&gt;#define MAX 50using namespace std;int total_row, total_col, time;int map[MAX][MAX];int clean[2]; // ê³µê¸°ì²­ì •ê¸° ìœ„ì¹˜(ë¬´ì¡°ê±´ 0ì—´)struct info &#123; int r, c, value;&#125;;queue&lt;info&gt; q;// ìƒí•˜ì¢Œìš°int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; total_row &amp;&amp; c &lt; total_col) return true; return false;&#125;// 1. ë¯¸ì„¸ë¨¼ì§€ í™•ì‚°void spread() &#123; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().r; int c = q.front().c; int mid = q.front().value; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; map[x][y] != -1) &#123; map[x][y] += mid / 5; map[r][c] -= mid / 5; &#125; &#125; &#125;&#125;// 2. ë°”ëŒìœ¼ë¡œ ë¯¸ì„¸ë¨¼ì§€ ì´ë™void wind() &#123; // ìœ„ìª½ ( ë°˜ì‹œê³„ ì‘ì—…ì€ ê±°ê¾¸ë¡œ ìˆ˜í–‰, ê·¸ë˜ì•¼ í¸í•¨) int i, j, clean_row = clean[0]; for (i = clean_row - 2; i &gt;= 0; --i) &#123; // ê³µê¸°ì²­ì •ê¸°ì— ë“¤ì–´ê°€ë©´ ì‚¬ë¼ì§€ë‹ˆê¹Œ ë°”ë¡œ ì´ì „ê±´ ê·¸ëƒ¥ ë®ì–´ì“°ë©´ ë¨ map[i + 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[0][j - 1] = map[0][j]; &#125; for (i = 1; i &lt;= clean_row; ++i) &#123; map[i - 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 1; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0; // ì•„ë˜ìª½ ( ì‹œê³„ ) clean_row = clean[1]; for (i = clean_row + 2; i &lt; total_row; ++i) &#123; map[i - 1][0] = map[i][0]; &#125; for (j = 1; j &lt; total_col; ++j) &#123; map[total_row - 1][j - 1] = map[total_row - 1][j]; &#125; for (i = total_row - 2; i &gt;= clean_row; --i) &#123; map[i + 1][total_col - 1] = map[i][total_col - 1]; &#125; for (j = total_col - 2; j &gt;= 1; --j) &#123; map[clean_row][j + 1] = map[clean_row][j]; &#125; map[clean_row][1] = 0;&#125;int main() &#123; int answer, idx = 0; scanf(\"%d %d %d\", &amp;total_row, &amp;total_col, &amp;time); for (int i = 0; i &lt; total_row; ++i) &#123; for (int j = 0; j &lt; total_col; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); if (map[i][j] &gt;= 5) q.push(&#123; i, j, map[i][j] &#125;); &#125; if (map[i][0] == -1) clean[idx++] = i; &#125; while (time--) &#123; answer = 0; spread(); wind(); printf(\"change\\n\"); for (int i = 0; i &lt; total_row; ++i) &#123; for (int j = 0; j &lt; total_col; ++j) &#123; printf(\"%d \", map[i][j]); if (map[i][j] &gt; 0) answer += map[i][j]; if (map[i][j] &gt;= 5) q.push(&#123; i, j, map[i][j] &#125;); &#125; printf(\"\\n\"); &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; ë°”ëŒì— ì˜í•œ ì´ë™ í™•ì¸ìš© test case12345678910111213141516177 8 12 4 0 0 0 0 0 93 0 0 0 3 0 0 8-1 3 5 0 0 0 22 0-1 8 0 0 0 0 0 33 0 0 0 0 10 43 54 0 5 0 15 0 0 02 1 40 0 0 0 20 3&#x2F;&#x2F; outputChange4 0 0 0 0 0 9 82 0 0 0 3 0 0 0-1 0 3 5 0 0 0 22-1 0 8 0 0 0 0 04 0 0 0 0 10 43 32 0 5 0 15 0 0 51 40 0 0 0 20 3 0 12345678910111213146 6 1 5 0 3 4 1 2 0 0 7 0 0 3-1 10 0 46 0 2-1 0 0 0 0 4 3 0 0 0 0 3 1 3 1 2 4 2change!! 3 1 4 4 1 2 1 3 3 10 0 3-1 4 12 10 9 2-1 2 0 9 0 4 3 0 0 0 0 3 1 3 1 2 4 2","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 17143ë²ˆ ë‚šì‹œì™•","slug":"Algorithm/BOJ/17143","date":"2020-01-25T08:04:40.000Z","updated":"2020-01-25T13:28:41.646Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17143/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17143/","excerpt":"","text":"#17143. ë‚šì‹œì™•ë¬¸ì œë§í¬ Problem R x C í¬ê¸°ì˜ ê²©ìíŒ ë‚šì‹œì™• ìœ„ì¹˜ (0, 0) 1ì´ˆ ë™ì•ˆ ì¼ì–´ë‚˜ëŠ” ì¼ ë‚šì‹œì™• ì˜¤ë¥¸ìª½ìœ¼ë¡œ í•œ ì¹¸ ì´ë™(ë‚šì‹œì™•ì´ ë¨¼ì € ì´ë™í•˜ê¸°ì— ìƒì–´ê°€ ì´ë™í•˜ê¸° ì „ ì¡íˆê²Œ ëœë‹¤.) ë‚šì‹œì™•ì´ ì—´ì— ìˆëŠ” ìƒì–´ ì¤‘ ê°€ì¥ ê°€ê¹Œìš´ ìƒì–´ë¥¼ ì¡ëŠ”ë‹¤. ìƒì–´ ì´ë™ìƒì–´ : ì†ë„ì™€ í¬ê¸°ë¥¼ ê°€ì§ê²½ê³„ë¥¼ ë„˜ê²Œë˜ë©´ ë°©í–¥ì„ ë°˜ëŒ€ë¡œ ë°”ê¿ˆì´ë™ì„ ë§ˆì¹œ í›„ì— ìƒì–´ê°€ í•œ ì¹¸ì— ì—¬ëŸ¬ ë§ˆë¦¬ ìˆìœ¼ë©´, ê°€ì¥ í° ìƒì–´ê°€ ë‚˜ë¨¸ì§€ ìƒì–´ë“¤ì„ ëª¨ë‘ ë¨¹ìŒ(ì‚¬ë¼ì§) Goal: ë‚šì‹œì™•ì´ ì¡ì€ ìƒì–´ í¬ê¸°ì˜ í•© ì…ë ¥ R : ~100 C : ~100 M(ìƒì–´ ìˆ˜) : ~10000 r, c : ìœ„ì¹˜ ~R, ~C s : ì†ë ¥ ~1000 d : ì´ë™ë°©í–¥ 1~4 ìƒí•˜ìš°ì¢Œ z : í¬ê¸° ~10000 Solution í•„ìëŠ” ì¸ë±ìŠ¤ë¥¼ 0ë¶€í„° ê³„ì‚°í•˜ì˜€ê¸°ì—â€¦ì´ë¥¼ ëª¨ë‘ ì‹ ê²½ì“°ëŠë¼ ğŸ•ê³ ìƒê·¸ëƒ¥ 1ë¶€í„° ì‹ ê²½ì“°ëŠ”ê²Œ í¸í•  ìˆ˜ë„ ìˆë‹¤. (ì…ë ¥ ë°›ì„ ë•Œë„ ì‹ ê²½ì¨ì£¼ì–´ì•¼í•¨â€¦) ìƒì–´ ì •ë³´ (MAXëŠ” 100)1234struct INFO &#123; int row, col, speed, direction, size; bool death = false;&#125;sharks[MAX*MAX]; ìƒì–´ì˜ í˜„ì¬ ìœ„ì¹˜, ë°©í–¥, í¬ê¸°, ì‚¬ë¼ì¡ŒëŠ”ì§€ ìœ ë¬´ê°€ ì €ì¥ëœë‹¤.1234for(ì—´ì˜ ìˆ˜: ì²˜ìŒë¶€í„°~ì—´ì˜ ëê¹Œì§€ ì´ë™) catchShark() // 1. ìƒì–´ë¥¼ ì¡ëŠ”ë‹¤ moveShark() // 2. ìƒì–´ê°€ ì´ë™í•œë‹¤. updateMap() // 3. ì´ë™ì„ ë§ˆì¹œ ìƒì–´ë“¤ mapì— ë°˜ì˜(ë¨¹íˆë©´ ì‚¬ë¼ì§€ë„ë¡) catchShark()í•´ë‹¹ ì—´ì„ íƒìƒ‰í•˜ë‹¤ê°€ ìƒì–´ë¥¼ ë°œê²¬í•˜ë©´ ë‹µì— í¬ê¸°ë¥¼ ë”í•´ì£¼ê³  ë¦¬í„´ moveShark()1234567891011121314151617ì£¼ê¸° : 2 * (ì „ì²´ í–‰ì´ë‚˜ ì—´ì˜ í¬ê¸°-1)// ex ë°©í–¥ -&gt; ì „ì²´ ì—´ì˜ í¬ê¸°: 4, ìƒì–´ëŠ” (1, 2)ì— ìˆë‹¤ê³  ê°€ì •í•  ë•Œìœ„ì¹˜: 2 3 2 1 0 1 2 3 2 1 0 1 2 3ë°©í–¥: -&gt; &lt;- &lt;- &lt;- -&gt; -&gt; -&gt; &lt;- &lt;- &lt;- -&gt; -&gt; -&gt; &lt;-ì´ë™ê±°ë¦¬: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 ì£¼ê¸°ê°€ 2 * 3 = 6ìœ¼ë¡œ ì´ë™ê±°ë¦¬ê°€ 6ë§ˆë‹¤ ê°™ì€ ìœ„ì¹˜ë¥¼ ë°˜ë³µí•˜ê³  ìˆìŒë°©í–¥ì€ 0ì´ë‚˜ ì „ì²´ ì—´ì˜ í¬ê¸°-1ì— ìœ„ì¹˜í•  ë•Œ ë°”ë€œìœ„ì¹˜ëŠ” ë°©í–¥ì— ë§ê²Œ ì´ë™í•´ì£¼ë©´ ë¨ë°©í–¥1 2 3 4 // ìƒí•˜ ìš°ì¢Œ1 &lt;-&gt; 2 (1ì¼ ë•Œ 2, 2ì¼ ë•Œ 1)3 &lt;-&gt; 4 (3ì¼ ë•Œ 4, 4ì¼ ë•Œ 3)í˜„ì¬ ë°©í–¥ì„ 2ë¡œ ë‚˜ëˆ´ì„ ë•Œ ë‚˜ë¨¸ì§€ê°€ 0ì´ë©´ í˜„ì¬ ë°©í–¥ì—ì„œ 1ì„ ë¹¼ì£¼ê³ ì•„ë‹ˆë©´ 1ì„ ë”í•´ì£¼ë©´ ë°”ë€ ë°©í–¥ì„ êµ¬í•  ìˆ˜ ìˆë‹¤. updateMap() mapì„ ì´ˆê¸°í™” í•´ì¤€ë‹¤. (ì´ë™í•œ ìƒì–´ì˜ ìœ„ì¹˜ë¥¼ ìƒˆë¡œ ë°˜ì˜í•˜ê¸° ìœ„í•´) í•´ë‹¹ ìœ„ì¹˜ì— ìƒì–´ê°€ ìˆì„ ë•Œì™€ ì—†ì„ ë•Œë¥¼ êµ¬ë¶„í•´ì„œ ì²˜ë¦¬ë¥¼ í•´ì¤€ë‹¤. ì´ˆê¸°ì— ì…ë ¥ê°’ì„ ë°˜ì˜í•˜ê¸° ìœ„í•´, ì…ë ¥ì„ ëª¨ë‘ ë°›ê³  í•œ ë²ˆ í˜¸ì¶œí•´ì¤€ë‹¤. 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cstdio&gt;#define MAX 100using namespace std;int r, c, m, idx, answer;// ìƒí•˜ìš°ì¢Œint dx[4] = &#123;-1, 1, 0, 0&#125;; int dy[4] = &#123;0, 0, 1, -1&#125;;// ìƒì–´ ì •ë³´struct INFO &#123; int row, col, speed, direction, size; bool death = false;&#125;sharks[MAX*MAX];int map[MAX][MAX][2]; // ìƒì–´ê°€ ì¡´ì¬í•œë‹¤ë©´ í•´ë‹¹ ìƒì–´ í¬ê¸°ì™€ í•´ë‹¹ ìƒì–´ê°€ ëª‡ ë²ˆì§¸ ìƒì–´ì¸ì§€void catchShark(int col) &#123; for (int i = 0; i &lt; r; ++i) &#123; if (map[i][col][0] != 0) &#123; sharks[map[i][col][1]].death = true; answer += sharks[map[i][col][1]].size; return; &#125; &#125;&#125;void changeDirection(int idx) &#123; if (sharks[idx].direction % 2 == 0) &#123; sharks[idx].direction--; &#125; else &#123; sharks[idx].direction++; &#125;&#125;void moveShark(int idx, int end) &#123; int period = 2 * end; int move = sharks[idx].speed % period; for (int i = 0; i &lt; move; ++i) &#123; if (sharks[idx].direction &lt;= 2) &#123; // ìƒí•˜ if ((sharks[idx].row == end &amp;&amp; sharks[idx].direction == 2) || (sharks[idx].row == 0 &amp;&amp; sharks[idx].direction == 1)) &#123; changeDirection(idx); &#125; sharks[idx].row += dx[sharks[idx].direction - 1]; &#125; else &#123; // ìš°ì¢Œ if ((sharks[idx].col == end &amp;&amp; sharks[idx].direction == 3) || (sharks[idx].col == 0 &amp;&amp; sharks[idx].direction == 4)) &#123; changeDirection(idx); &#125; sharks[idx].col += dy[sharks[idx].direction-1]; &#125; &#125;&#125;void updateMap() &#123; for (int i = 0; i &lt; r; ++i) &#123; // map ì´ˆê¸°í™” for (int j = 0; j &lt; c; ++j) &#123; map[i][j][0] = 0; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; if (sharks[i].death) continue; int r = sharks[i].row; int c = sharks[i].col; if (map[r][c][0] != 0) &#123; // í•´ë‹¹ ìœ„ì¹˜ì— ìƒì–´ê°€ ìˆë‹¤ë©´ if (sharks[i].size &gt; map[r][c][0]) &#123; sharks[map[r][c][1]].death = true; map[r][c][0] = sharks[i].size; map[r][c][1] = i; &#125; else &#123; sharks[i].death = true; &#125; &#125; else &#123; // í•´ë‹¹ ìœ„ì¹˜ì— ìƒì–´ê°€ ì—†ì„ ë•Œ map[r][c][0] = sharks[i].size; map[r][c][1] = i; &#125; &#125;&#125;int main() &#123; scanf(\"%d %d %d\", &amp;r, &amp;c, &amp;m); int row, col; for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d\", &amp;row); sharks[idx].row = row - 1; scanf(\"%d\", &amp;col); sharks[idx].col = col - 1; scanf(\"%d\", &amp;sharks[idx].speed); scanf(\"%d\", &amp;sharks[idx].direction); scanf(\"%d\", &amp;sharks[idx++].size); &#125; updateMap(); // ì´ˆê¸° map update for (int i = 0; i &lt; c; ++i) &#123; catchShark(i); // ìƒì–´ ì¡ê¸° for (int j = 0; j &lt; m; ++j) &#123; // ìƒì–´ ì´ë™ if (sharks[j].death) continue; if (sharks[j].direction &lt;= 2) &#123; moveShark(j, r-1); &#125; else &#123; moveShark(j, c-1); &#125; &#125; updateMap(); // ì´ë™í•œ ìƒì–´ ìœ„ì¹˜ ë°˜ì˜ &#125; printf(\"%d\\n\", answer); return 0;&#125; ìê¾¸ forë¬¸ì—ì„œ ië‚˜ jê°€ ì•„ë‹Œ r, cë¡œ ê³ ì •ê°’ì„ ë‘ì–´ì„œâ€¦ì´ëŸ° ì‹¤ìˆ˜ëŠ” ì§„ì§œì§„ì§œ ì¡°ì‹¬í•˜ì. For Debug123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdio&gt;#define MAX 100using namespace std;int r, c, m, idx, answer;// ìƒí•˜ìš°ì¢Œint dx[4] = &#123;-1, 1, 0, 0&#125;; int dy[4] = &#123;0, 0, 1, -1&#125;;// ìƒì–´ ì •ë³´struct INFO &#123; int row, col, speed, direction, size; bool death = false;&#125;sharks[MAX*MAX];int map[MAX][MAX][2]; // ìƒì–´ê°€ ì¡´ì¬í•œë‹¤ë©´ í•´ë‹¹ ìƒì–´ í¬ê¸°ì™€ í•´ë‹¹ ìƒì–´ê°€ ëª‡ ë²ˆì§¸ ìƒì–´ì¸ì§€void catchShark(int col) &#123; /*printf(\"%dë²ˆì§¸\\n\", col); // map í™•ì¸ for (int i = 0; i &lt; r; ++i) &#123; for (int j = 0; j &lt; c; ++j) &#123; printf(\"%d \", map[i][j][0]); &#125; printf(\"\\n\"); &#125;*/ for (int i = 0; i &lt; r; ++i) &#123; if (map[i][col][0] != 0) &#123; sharks[map[i][col][1]].death = true; answer += sharks[map[i][col][1]].size; return; &#125; &#125;&#125;void changeDirection(int idx) &#123; if (sharks[idx].direction % 2 == 0) &#123; sharks[idx].direction--; &#125; else &#123; sharks[idx].direction++; &#125;&#125;void moveShark(int idx, int end) &#123; int period = 2 * end; int move = sharks[idx].speed % period; for (int i = 0; i &lt; move; ++i) &#123; if (sharks[idx].direction &lt;= 2) &#123; // ìƒí•˜ if ((sharks[idx].row == end &amp;&amp; sharks[idx].direction == 2) || (sharks[idx].row == 0 &amp;&amp; sharks[idx].direction == 1)) &#123; changeDirection(idx); &#125; sharks[idx].row += dx[sharks[idx].direction - 1]; &#125; else &#123; // ìš°ì¢Œ if ((sharks[idx].col == end &amp;&amp; sharks[idx].direction == 3) || (sharks[idx].col == 0 &amp;&amp; sharks[idx].direction == 4)) &#123; changeDirection(idx); &#125; sharks[idx].col += dy[sharks[idx].direction-1]; &#125; &#125;&#125;void updateMap() &#123; for (int i = 0; i &lt; r; ++i) &#123; for (int j = 0; j &lt; c; ++j) &#123; map[i][j][0] = 0; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; if (sharks[i].death) continue; int r = sharks[i].row; int c = sharks[i].col; if (map[r][c][0] != 0) &#123; // í•´ë‹¹ ìœ„ì¹˜ì— ìƒì–´ê°€ ìˆë‹¤ë©´ if (sharks[i].size &gt; map[r][c][0]) &#123; sharks[map[r][c][1]].death = true; map[r][c][0] = sharks[i].size; map[r][c][1] = i; &#125; else &#123; sharks[i].death = true; &#125; &#125; else &#123; // í•´ë‹¹ ìœ„ì¹˜ì— ìƒì–´ê°€ ì—†ì„ ë•Œ map[r][c][0] = sharks[i].size; map[r][c][1] = i; &#125; &#125;&#125;int main() &#123; scanf(\"%d %d %d\", &amp;r, &amp;c, &amp;m); int row, col; for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d\", &amp;row); sharks[idx].row = row - 1; scanf(\"%d\", &amp;col); sharks[idx].col = col - 1; scanf(\"%d\", &amp;sharks[idx].speed); scanf(\"%d\", &amp;sharks[idx].direction); scanf(\"%d\", &amp;sharks[idx++].size); &#125; updateMap(); /*for (int i = 0; i &lt; m; ++i) &#123; // ì…ë ¥ í™•ì¸ printf(\"%d %d %d %d %d\\n\", sharks[i].row, sharks[i].col, sharks[i].speed, sharks[i].direction, sharks[i].size); &#125;*/ for (int i = 0; i &lt; c; ++i) &#123; catchShark(i); for (int j = 0; j &lt; m; ++j) &#123; if (sharks[j].death) continue; if (sharks[j].direction &lt;= 2) &#123; moveShark(j, r-1); &#125; else &#123; moveShark(j, c-1); &#125; &#125; updateMap(); &#125; printf(\"%d\\n\", answer); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 17142ë²ˆ ì—°êµ¬ì†Œ 3","slug":"Algorithm/BOJ/17142","date":"2020-01-25T08:04:37.000Z","updated":"2020-01-25T13:28:41.650Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17142/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17142/","excerpt":"","text":"#17142. ì—°êµ¬ì†Œ 3Problem ë¬¸ì œë§í¬ Solution í¼íŠ¸ë¦´ Mê°œì˜ ë°”ì´ëŸ¬ìŠ¤ë¥¼ ì„ íƒí•œë‹¤. (DFS)ì¤‘ë³µì„ í—ˆìš©í•˜ì§€ ì•ŠëŠ” ì¡°í•©ì´ë‹¤. ì„ íƒí•œ ë°”ì´ëŸ¬ìŠ¤ë¥¼ í¼íŠ¸ë¦¬ë‹¤. (BFS)4 ë°©í–¥ìœ¼ë¡œ íƒìƒ‰ì„ í•˜ë˜, ë¹ˆ ì¹¸ ë˜ëŠ” ë°”ì´ëŸ¬ìŠ¤ê°€ ìˆëŠ” ê³³ì´ì–´ì•¼ í•œë‹¤. distë¼ëŠ” ë°°ì—´ì— ì‹œê°„ì„ ì €ì¥í•œë‹¤.ë‹¨, ëª¨ì„œë¦¬ì— ìˆëŠ” ë°”ì´ëŸ¬ìŠ¤ì—ì„œ íƒìƒ‰ì´ ëë‚œ ê²½ìš° ì‹œê°„ì„ 1 ë¹¼ì£¼ì–´ì•¼ í•œë‹¤. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;int N, M, ans = 1e9;int map[50][50];int selected[10];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;vector&lt;pair&lt;int, int&gt;&gt; virus;void Spread() &#123; bool visit[50][50] = &#123; 0, &#125;; int dist[50][50] = &#123; 0, &#125;; queue&lt;pair&lt;int, int&gt;&gt; q; for (auto e : selected) &#123; if (e != -1) &#123; q.push(&#123; virus[e].first, virus[e].second &#125;); visit[virus[e].first][virus[e].second] = true; &#125; &#125; while (!q.empty()) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &lt; 0 || d_y &lt; 0 || d_x &gt;= N || d_y &gt;= N) continue; if (map[d_x][d_y] == 1 || visit[d_x][d_y]) continue; visit[d_x][d_y] = true; q.push(&#123; d_x, d_y &#125;); dist[d_x][d_y] = dist[x][y] + 1; &#125; &#125; int time = 0; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (dist[i][j] != 0 &amp;&amp; map[i][j] == 2) &#123; if (i == 0 || j == 0 || i == N - 1 || j == N - 1) dist[i][j]--; &#125; if (!visit[i][j] &amp;&amp; map[i][j] == 0) return; if (dist[i][j] &gt; time) time = dist[i][j]; &#125; &#125; if (ans &gt; time) ans = time;&#125;void SelectVirus(int idx, int cnt) &#123; if (cnt == M) &#123; Spread(); return; &#125; for (int i = idx; i &lt; virus.size(); ++i) &#123; selected[i] = i; SelectVirus(i+1, cnt + 1); selected[i] = -1; &#125;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M; bool no_zero = true; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; cin &gt;&gt; map[i][j]; if (map[i][j] == 2) virus.push_back(&#123; i, j &#125;); if (map[i][j] == 0) no_zero = false; &#125; &#125; if (no_zero) &#123; cout &lt;&lt; 0 &lt;&lt; \"\\n\"; &#125; else &#123; memset(selected, -1, sizeof(selected)); SelectVirus(0, 0); if (ans != 1e9) cout &lt;&lt; ans &lt;&lt; \"\\n\"; else cout &lt;&lt; -1 &lt;&lt; \"\\n\"; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 17140ë²ˆ ì´ì°¨ì› ë°°ì—´ê³¼ ì—°ì‚°","slug":"Algorithm/BOJ/17140","date":"2020-01-25T08:04:30.000Z","updated":"2020-01-25T13:28:41.638Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17140/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17140/","excerpt":"","text":"#17140. ì´ì°¨ì› ë°°ì—´ê³¼ ì—°ì‚°Problem ë¬¸ì œë§í¬ Solution ì‹œë®¬ë ˆì´ì…˜ ë¬¸ì œì´ë‹¤. (í•­ìƒ ìë£Œêµ¬ì¡°ë¥¼ ë­˜ ì‚¬ìš©í• ì§€ ì˜ íŒë‹¨í•˜ì.) ì—¬ê¸°ì„œëŠ” mapê³¼ priority queueë¥¼ ì‚¬ìš©í•˜ì˜€ë‹¤. mapì˜ ì“°ì„ &lt;ìˆ˜, ë“±ì¥ íšŸìˆ˜&gt;ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ ì“°ì¸ë‹¤. ì²˜ìŒì— 1ì°¨ì› ë°°ì—´ë¡œ cnt[ìˆ˜]=ë“±ì¥ íšŸìˆ˜ë¡œ í•˜ë ¤ í–ˆì§€ë§Œ, ì´ë ‡ê²Œ ë˜ë©´ ë§¤ë²ˆ 100ë²ˆ forë¬¸ì„ ì—°ì‚°í•´ì•¼ í•œë‹¤ê³  ëŠê»´ mapì„ ì´ìš©í•´ ë°”ë¡œ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë„ë¡ í•˜ì˜€ë‹¤. priority queueì˜ ì“°ì„ Rì—°ì‚° ë˜ëŠ” Cì—°ì‚° ì¤‘ì— ìƒì„±ë˜ëŠ” ì •ë ¬ëœ ê°’ë“¤ì„ ì €ì¥í•˜ê¸° ìœ„í•´ ì“°ì¸ë‹¤. ì—°ì‚°ìë¥¼ ì˜¤ë²„ë¡œë”©í•˜ì—¬ ì‚½ì… ì‹œ ì •ë ¬ ìˆœìœ„ë¥¼ ì •í•´ì£¼ì—ˆë‹¤.ì›ë˜ ìš°ì„ ìˆœìœ„ íëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆë‹¤. (pairë¼ë©´ ì²« ë²ˆì§¸ ê¸°ì¤€, ì²« ë²ˆì§¸ ì›ì†Œê°€ ê°™ë‹¤ë©´ ë‘ ë²ˆì§¸ ì›ì†Œ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬) ê·¸ë ‡ê¸°ì— ë”°ë¡œ ì •í•´ì£¼ì—ˆëŠ”ë° ê·¸ëŸ´ í•„ìš” ì—†ì´ -ë¥¼ ë¶™ì—¬ ì €ì¥í•˜ë©´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ëœë‹¤ëŠ” ê²ƒì„ ê¹¨ë‹«ê³ â€¦(ìœ ë ˆì¹´!!) *ì•„ë˜ ì½”ë“œëŠ” ê·¸ëŸ¬ì§„ ì•Šì•˜ë‹¤. í•´ë‹¹ ìˆ˜ë¥¼ ì¹´ìš´íŠ¸í•  ë•Œ ì¤‘ìš”í•œ ê²ƒì€ ì¹´ìš´íŠ¸ê°€ ëë‚˜ë©´ í•´ë‹¹ ë°°ì—´ì˜ ê°’ì„ 0ìœ¼ë¡œ ë°”ê¾¼ë‹¤ëŠ” ê²ƒì´ë‹¤. ê·¸ë˜ì•¼ í–‰ì´ë‚˜ ì—´ì˜ í¬ê¸°ê°€ ì¤„ì–´ë“¤ ë•Œ ì˜í–¥ì„ ë°›ì§€ ì•Šê³  ì—°ì‚°ì„ ì •ìƒì ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤. ê·¸ ì™¸ëŠ” ë¬¸ì œ ê·¸ëŒ€ë¡œ êµ¬í˜„í•˜ë©´ ëœë‹¤. 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;int r, c, k, total_r, total_c;int A[100][100]; // 1 ~ 100map&lt;int, int&gt; cnt;struct Info &#123; int num, count;&#125;;bool operator&lt;(const Info &amp;v1, const Info &amp;v2) &#123; if (v1.count == v2.count) return v1.num &gt; v2.num; return v1.count &gt; v2.count;&#125;void Input() &#123; cin &gt;&gt; r &gt;&gt; c &gt;&gt; k; total_r = total_c = 3; for (int i = 0; i &lt; total_r; ++i) &#123; for (int j = 0; j &lt; total_c; ++j) &#123; cin &gt;&gt; A[i][j]; &#125; &#125;&#125;void Task() &#123; for (int t = 0; t &lt;= 100; ++t) &#123; if (A[r - 1][c - 1] == k) &#123; cout &lt;&lt; t &lt;&lt; \"\\n\"; return; &#125; priority_queue&lt;Info&gt; pq; if (total_r &gt;= total_c) &#123; // R ì—°ì‚° for (int i = 0; i &lt; total_r; ++i) &#123; for (int j = 0; j &lt; total_c; ++j) &#123; if (A[i][j] == 0) continue; if (cnt.count(A[i][j]) == 0) cnt[A[i][j]] = 1; else cnt[A[i][j]]++; A[i][j] = 0; &#125; for (auto e : cnt) &#123; pq.push(&#123; e.first, e.second &#125;); &#125; cnt.clear(); int len = pq.size() * 2; for (int j = 0; j &lt; len; j += 2) &#123; A[i][j] = pq.top().num; A[i][j + 1] = pq.top().count; pq.pop(); &#125; if (total_c &lt; len) total_c = len; &#125; &#125; else &#123; // C ì—°ì‚° for (int i = 0; i &lt; total_c; ++i) &#123; for (int j = 0; j &lt; total_r; ++j) &#123; if (A[j][i] == 0) continue; if (cnt.count(A[j][i]) == 0) cnt[A[j][i]] = 1; else cnt[A[j][i]]++; A[j][i] = 0; &#125; for (auto e : cnt) &#123; pq.push(&#123; e.first, e.second &#125;); &#125; cnt.clear(); int len = pq.size() * 2; for (int j = 0; j &lt; len; j += 2) &#123; A[j][i] = pq.top().num; A[j + 1][i] = pq.top().count; pq.pop(); &#125; if (total_r &lt; len) total_r = len; &#125; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; \"\\n\";&#125;int main() &#123; Input(); Task(); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 17136ë²ˆ ìƒ‰ì¢…ì´ ë¶™ì´ê¸°","slug":"Algorithm/BOJ/17136","date":"2020-01-25T08:04:26.000Z","updated":"2020-01-25T13:28:41.643Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17136/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17136/","excerpt":"","text":"#17136. ìƒ‰ì¢…ì´ ë¶™ì´ê¸°Problem ë¬¸ì œë§í¬ Solution DFS + BackTrackingì„ ì‚¬ìš©í•˜ì—¬ í‘¼ë‹¤.(ì²˜ìŒì— BFS+Greedyë¥¼ ì´ìš©í•´ í’€ì—ˆë‹¤ê°€ í‹€ë ¸ë‹¤â€¦ë°˜ë¡€ê°€ ì¡´ì¬) 10 x 10 í¬ê¸°ì˜ ëª¨ë“  ë°°ì—´ì—ì„œ ëª¨ë“  ì§€ì ì„ íƒìƒ‰í•œë‹¤. íƒìƒ‰ íšŸìˆ˜ê°€ 100ì´ë¼ë©´ ëª¨ë“  ì§€ì ì„ íƒìƒ‰í•œ ê²½ìš°ë¼ ê°’ì„ ê°±ì‹ í•˜ê³  ì¢…ë£Œí•œë‹¤. í–‰ê³¼ ì—´ì€ 0 â†’ 100ê°œì˜ ì›ì†Œë“¤ì— ë§ê²Œ ê³„ì‚° ì´ë¯¸ ans ê°€ ì§€ê¸ˆê¹Œì§€ êµ¬í•œ ê°œìˆ˜(cnt) ë³´ë‹¤ í¬ë©´ ì¢…ë£Œ (BackTracking) í•´ë‹¹ ì§€ì ì´ 1ì´ë©´ ìƒ‰ì¢…ì´ í¬ê¸°ê°€ í° 5ë¶€í„° ê²€ì‚¬ ì‹œì‘ í•´ë‹¹ í¬ê¸°ê°€ ê°€ëŠ¥í•˜ë©´ ë¶™ì´ê³  ë‹¤ìŒ ê²½ìš° íƒìƒ‰íƒìƒ‰ì´ ëë‚œ ê²½ìš° ì›ë˜ëŒ€ë¡œ ëŒë ¤ë†“ì•„ì•¼ ëª¨ë“  ê²½ìš° íƒìƒ‰ì´ ê°€ëŠ¥í•˜ë‹¤. í•´ë‹¹ ì§€ì ì´ 0ì´ë©´ ë‹¤ìŒ ë²ˆì§¸ ì›ì†Œ íƒìƒ‰ 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;int ans = 100;int map[10][10];int type[5] = &#123;5, 5, 5, 5, 5 &#125;; // 1 2 3 4 5 ì¢…ë¥˜void Update(int x, int y, int size, int status) &#123; for (int i = x; i &lt; x + size; ++i) &#123; for (int j = y; j &lt; y + size; ++j) &#123; map[i][j] = status; &#125; &#125;&#125;bool Check(int x, int y, int size) &#123; if (x + size &gt; 10 || y + size &gt; 10) return false; // ë²”ìœ„ ë°– for (int i = x; i &lt; x + size; ++i) &#123; for (int j = y; j &lt; y + size; ++j) &#123; if (map[i][j] == 0) return false; &#125; &#125; return true;&#125;void DFS(int n, int cnt) &#123; if (n == 100) &#123; // ëª¨ë“  ê²½ìš°ë¥¼ íƒìƒ‰í•œ ê²½ìš° (ì´ 100ê°œ) if (ans &gt; cnt) ans = cnt; return; &#125; int x = n / 10; int y = n % 10; if (ans &lt;= cnt) return; // BackTracking if (map[x][y] == 1) &#123; for (int i = 5; i &gt; 0; --i) &#123; // í¬ê¸° 5ë¶€í„° ì‹œì‘ if (type[i-1] &gt; 0) &#123; if (Check(x, y, i)) &#123; type[i - 1]--; Update(x, y, i, 0); // ìƒ‰ì¢…ì´ ë¶™ì´ê¸° DFS(n+1, cnt + 1); Update(x, y, i, 1); // ìƒ‰ì¢…ì´ ë‹¤ì‹œ ë•Œê¸° type[i - 1]++; &#125; &#125; &#125; &#125; else DFS(n + 1, cnt);&#125;int main() &#123; for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; 10; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; DFS(0, 0); if (ans == 100) ans = -1; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 17135ë²ˆ ìºìŠ¬ ë””íœìŠ¤","slug":"Algorithm/BOJ/17135","date":"2020-01-25T08:04:21.000Z","updated":"2020-01-25T13:28:41.647Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17135/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17135/","excerpt":"","text":"#17135. ìºìŠ¬ ë””íœìŠ¤Problem ë¬¸ì œë§í¬ Solution ê¶ìˆ˜ 3ëª…ì˜ ìœ„ì¹˜ë¥¼ ì§€ì •í•œë‹¤. (ì¤‘ë³µx, ì˜¤ë¦„ì°¨ìˆœ ìˆœì—´ì¡°í•©) ì ì´ ì‚¬ë¼ì§ˆ ë•Œê¹Œì§€(=ê¶ìˆ˜ê°€ 0ë²ˆì§¸ í–‰ìœ¼ë¡œ ì´ë™í•  ë•Œê¹Œì§€) ê²Œì„ì„ ì§„í–‰í•œë‹¤. ê¶ìˆ˜ëŠ” ê°€ì¥ ê°€ê¹Œìš´ ìœ„ì¹˜ì˜ ì ì„ ê³µê²©í•´ì•¼ í•˜ë©°, ì—¬ëŸ¿ì´ë©´ ì™¼ìª½ì˜ ì ë¶€í„° ê³µê²©í•œë‹¤. ë˜í•œ ë™ì‹œì— ê³µê²©ì´ ê°€ëŠ¥í•˜ë‹¤(=ìœ„ì˜ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ê°™ì€ ì ì„ ê³µê²©í•œë‹¤.) ê³µê²©ì´ ëë‚˜ë©´ ë°°ì—´ì„ ë°”ê¾¸ì§€ ì•Šê³  ê¶ìˆ˜ì˜ ìœ„ì¹˜ë¥¼ ì´ë™ì‹œí‚¨ë‹¤. (ìœ„ë¡œ)step ë³€ìˆ˜ë¥¼ ë‘ì–´ ë²”ìœ„ë¥¼ ì¢í˜€ê°„ë‹¤. ê°€ê¹Œìš´ ì ì„ ë¨¼ì € ì°¾ì•„ ê³µê²©í•˜ê¸° ìœ„í•´ BFS íƒìƒ‰ì„ ì‚¬ìš©í•œë‹¤. ê° ê¶ìˆ˜ë³„ë¡œ queue ë¥¼ ë§Œë“¤ì–´ ìì‹ ì˜ ìœ„ì¹˜ë¥¼ ì €ì¥í•˜ê³  íƒìƒ‰ ì‹œì‘ (ìµœëŒ€ Dê¹Œì§€) ê¶ìˆ˜ê°€ ì ì„ ê³µê²©í•  ê²½ìš° ë‹¤ìŒ ê¶ìˆ˜ì—ê²Œ ì°¨ë¡€ë¥¼ ë„˜ê¸´ë‹¤. (ì¦‰, ê³µê²©í•˜ë©´ ìì‹ ì˜ í„´ ë=íƒìƒ‰ ë) check arrayë¥¼ ì‚¬ìš©í•´ ê³µê²©í•œ ì ì¼ ê²½ìš° í•´ë‹¹ step + 1ì˜ ê°’ì„ ì¤€ë‹¤. (stepì´ 0ë¶€í„° ì‹œì‘, checkëŠ” 0ìœ¼ë¡œ ì´ˆê¸°í™” ë˜ì–´ìˆê¸°ì—) stepì„ ì´ìš©í•´ checkì— ê°’ì„ ì¤€ ì´ìœ ëŠ” ë‹¤ìŒ stepì—ì„œ ê¶ìˆ˜ì˜ ìœ„ì¹˜ê°€ ì´ë™ë  ë•Œ ì´ì „ í„´ì—ì„œ ê³µê²© ë‹¹í•´ ì œì™¸ëœ ì ì¸ì§€ ì•„ë‹Œì§€ë¥¼ íŒë‹¨í•˜ê¸° ìœ„í•¨ì´ë‹¤. (stepì˜ ê°’ì´ ë³€í•˜ë‹ˆê¹Œ ì¤‘ë³µë˜ì§€ ì•Šê²Œ íƒìƒ‰ ê°€ëŠ¥) 1 Try ê¶ìˆ˜ëŠ” ê°€ì¥ ê°€ê¹Œìš´ ìœ„ì¹˜ì˜ ì ì„ ê³µê²©, ê°€ê¹Œìš´ ì ì´ ì—¬ëŸ¿ì´ë©´ ì™¼ìª½ ìš°ì„  ê·¸ë¦¬ê³  ë™ì‹œì— ê³µê²© ê°€ëŠ¥í•˜ë‹¤ëŠ” ì¡°ê±´ì„ ì¶©ì¡±í•˜ì§€ ëª» í–ˆë‹¤. â†’ BFSë¥¼ ì´ìš©í•˜ê¸°ë¡œ ê²°ì •123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int N, M, D, ans;int map[16][16];bool check[16][16];int archer[3] = &#123; -1, -1, -1 &#125;;int getDistance(int a_x, int a_y, int b_x, int b_y) &#123; return abs(a_x - b_x) + abs(a_y - b_y);&#125;void Game() &#123; int step = 0, res = 0; memset(check, 0, sizeof(check)); while (true) &#123; int attack_cnt = 0; for (int i = N - step - 1; i &gt;= (N -step) - D &amp;&amp; i &gt;= 0; --i) &#123; for (int k = attack_cnt; k &lt; 3; ++k) &#123; // 3ëª…ì˜ ê¶ìˆ˜ for (int j = 0; j &lt; M; ++j) &#123; if (D &gt;= getDistance(i, j, N - step, archer[k]) &amp;&amp; map[i][j] == 1 &amp;&amp; !check[i][j]) &#123; // ê³µê²© ê°œì‹œ res++; check[i][j] = true; attack_cnt++; break; // í•œ ë²ˆë§Œ ê³µê²© ê°€ëŠ¥ &#125; &#125; &#125; &#125; step++; if (N - step - 1 &lt; 0) break; &#125; if (ans &lt; res) ans = res;&#125;void SelectPosition(int n, int cnt) &#123; if (cnt == 3) &#123; Game(); return; &#125; for (int i = n; i &lt; M; ++i) &#123; if (archer[cnt] != -1) continue; archer[cnt] = i; SelectPosition(i + 1, cnt + 1); archer[cnt] = -1; &#125;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; D; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; SelectPosition(0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; 2 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int N, M, D, ans;int map[16][16];int check[16][16];int archer[3] = &#123; -1, -1, -1 &#125;;int dx[3] = &#123; 0, -1, 0 &#125;;int dy[3] = &#123; -1, 0, 1 &#125;;void Game() &#123; int step = 0, res = 0; // stepì€ 1í„´ì´ ëë‚  ë•Œ ì´ë™ì„ ìœ„í•¨ memset(check, 0, sizeof(check)); while (true) &#123; for (int i = 0; i &lt; 3; ++i) &#123; // ê¶ìˆ˜ ê° 3ëª…ì— ëŒ€í•˜ì—¬ queue&lt;pair&lt;int, int&gt; &gt; q; q.push(&#123; N - step, archer[i] &#125;); // ê¶ìˆ˜ í˜„ì¬ ìœ„ì¹˜ë¶€í„° ì‹œì‘ for(int j = 0; j &lt; D; ++j) &#123; // ìµœëŒ€ Dê¹Œì§€ë§Œí¼ë§Œ íƒìƒ‰ int len = q.size(); bool end_flag = false; // ì ì„ ê³µê²©í–ˆì„ ë•Œ ì¢…ë£Œ flag for (int k = 0; k &lt; len; ++k) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 3; ++dir) &#123; // ì™¼ ìœ„ ì˜¤ ìˆœì„œë¡œ íƒìƒ‰ ì‹œì‘ int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; N - step &amp;&amp; d_y &lt; M) &#123; // N - stepì€ ê¶ìˆ˜ ìœ„ì¹˜ if (d_x &lt; N - step - D) continue; // [N - step - D, N-step) íƒìƒ‰ ë²”ìœ„ if (map[d_x][d_y] == 1 &amp;&amp; check[d_x][d_y] == 0) &#123; // ì²˜ìŒ ì ì„ ê³µê²©í•œ ê²½ìš° res++; check[d_x][d_y] = step + 1; // stepì„ ì˜®ê²¼ì„ ë•Œ ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•¨ end_flag = true; break; &#125; else if (map[d_x][d_y] == 1 &amp;&amp; check[d_x][d_y] == step + 1) &#123; // ë™ì‹œì— ì ì„ ê³µê²©í•œ ê²½ìš° end_flag = true; break; &#125; else &#123; // ì ì„ ë°œê²¬í•˜ì§€ ëª» í•œ ê²½ìš° q.push(&#123; d_x, d_y &#125;); &#125; &#125; &#125; if (end_flag) break; &#125; if (end_flag) break; &#125; &#125; step++; if (N - step - 1 &lt; 0) break; &#125; if (ans &lt; res) ans = res;&#125;void SelectPosition(int n, int cnt) &#123; if (cnt == 3) &#123; Game(); return; &#125; for (int i = n; i &lt; M; ++i) &#123; if (archer[cnt] != -1) continue; archer[cnt] = i; SelectPosition(i + 1, cnt + 1); archer[cnt] = -1; &#125;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; D; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; SelectPosition(0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 17070ë²ˆ íŒŒì´í”„ ì˜®ê¸°ê¸° 1","slug":"Algorithm/BOJ/17070","date":"2020-01-25T08:04:16.000Z","updated":"2020-01-25T13:28:41.649Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/17070/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/17070/","excerpt":"","text":"#17070. íŒŒì´í”„ ì˜®ê¸°ê¸° 1ë¬¸ì œë§í¬ Problem íŒŒì´í”„ëŠ” 2ê°œì˜ ì—°ì†ëœ ì¹¸ì„ ì°¨ì§€ íšŒì „ì´ ê°€ëŠ¥ (3ê°€ì§€: ìˆ˜í‰ì„ , ìˆ˜ì§ì„ , ëŒ€ê°ì„ (4ì¹¸ ì°¨ì§€)) Goal: (0, 0) ê³¼ (0, 1)ì— ìœ„ì¹˜í•œ í•˜ë‚˜ì˜ íŒŒì´í”„ë¥¼ (N, N)ìœ¼ë¡œ ì˜®ê¸°ëŠ” ë°©ë²•ì˜ ê°œìˆ˜ë¶ˆê°€ëŠ¥í•œ ê²½ìš° 0 íŒŒì´í”„ ì˜®ê¸°ê¸° ì˜¤ë¥¸ìª½, ì•„ë˜, ì˜¤ë¥¸ìª½ ì•„ë˜ ëŒ€ê°ì„  ë°©í–¥ìœ¼ë¡œ ì˜®ê¸¸ ìˆ˜ ìˆìŒì˜®ê¸¸ ë•Œ 45ë„ íšŒì „ ê°€ëŠ¥ë²½ì— ë‹¿ìœ¼ë©´ ì•ˆë¨ ê°€ë¡œ(ìˆ˜í‰) â†’ ì˜¤ë¥¸ìª½ or ì˜¤ë¥¸ìª½ ì•„ë˜ ëŒ€ê°ì„  ì„¸ë¡œ(ìˆ˜ì§) â†’ ì•„ë˜ or ì˜¤ë¥¸ìª½ ì•„ë˜ ëŒ€ê°ì„  ì˜¤ë¥¸ìª½ ì•„ë˜ ëŒ€ê°ì„  â†’ 3ê°€ì§€ ëª¨ë‘ ê°€ëŠ¥ ì…ë ¥ N: 3~16 ë¹ˆì¹¸ 0 ë²½ì€ 1 // ì˜ˆì œ 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 -&gt; 0 ë§¨ ì²˜ìŒ íŒŒì´í”„ëŠ” (0,0), (0,1) ì¦‰ ê°€ë¡œì´ê¸°ì— ê°€ëŠ¥í•œ ë°©í–¥ì¸ ì˜¤ë¥¸ìª½, ì˜¤ë¥¸ìª½ ì•„ë˜ ëŒ€ê°ì„ ìœ¼ë¡œ ì˜®ê¸¸ ìˆ˜ ì—†ë‹¤. Solution í˜„ì¬ type ì •ë³´ì™€ ìœ„ì¹˜ë¥¼ ì•Œê³  ìˆì–´ì•¼ í•œë‹¤. í˜„ì¬ typeì— ë”°ë¼ ì˜®ê¸¸ ìˆ˜ ìˆëŠ” ë°©í–¥ì´ ë‹¤ë¥´ë‹¤. í˜„ì¬ typeì— ë”°ë¼ ì˜®ê¸¸ ìˆ˜ ìˆëŠ”ì§€ checkë¥¼ í•´ì£¼ì–´ì•¼ í•œë‹¤. check12345678910111213ê°€ë¡œ: ì˜¤ë¥¸ìª½ 1ì¹¸ ê²€ì‚¬ì„¸ë¡œ: ì•„ë˜ 1ì¹¸ ê²€ì‚¬ëŒ€ê°ì„ : ì˜¤ë¥¸ìª½ 1ì¹¸, ì•„ë˜ 1ì¹¸, ì˜¤ë¥¸ìª½ ì•„ë˜ 1ì¹¸ ê²€ì‚¬// # 1.ê°€ë¡œ -&gt; ê°€ë¡œ (ìê¸° ìì‹ ) -&gt; ëŒ€ê°ì„  // # 2.ì„¸ë¡œ -&gt; ì„¸ë¡œ (ìê¸° ìì‹ ) -&gt; ëŒ€ê°ì„  // # 3.ëŒ€ê°ì„  -&gt; ì„¸ë¡œ -&gt; ê°€ë¡œ -&gt; ëŒ€ê°ì„  ëª¨ë‘ ìê¸° ìì‹ ì˜ íƒ€ì… ê·¸ëŒ€ë¡œ ì˜®ê¸¸ ìˆ˜ ìˆë‹¤. ëŒ€ê°ì„ ì„ ê°€ê¸° ìœ„í•´ì„œëŠ” ê°€ë¡œ, ì„¸ë¡œë¡œ ê°ˆ ìˆ˜ ìˆëŠ” ì¡°ê±´ ì—­ì‹œ ë§Œì¡±í•´ì•¼ í•œë‹¤. ìœ„ë¥¼ ì´ìš©í•˜ì—¬ íƒìƒ‰ ì½”ë“œë¥¼ êµ¬í˜„í•œë‹¤.12345678void íƒìƒ‰(í˜„ì¬ ìœ„ì¹˜, í˜„ì¬ íƒ€ì…) ë„ì°©í–ˆì„ ë•Œ answer++í›„ ë¦¬í„´ for(3ë²ˆ) checkí•  ìœ„ì¹˜(ì˜¤ë¥¸ìª½, ì•„ë˜, ì˜¤ë¥¸ìª½ ì•„ë˜) ê²½ê³„í™•ì¸ (ë²½ì´ ì•„ë‹ˆê³  ìì‹ ê³¼ ê°™ì€ type)ì´ê±°ë‚˜(ë²½ì´ ì•„ë‹ˆê³  ëŒ€ê°ì„ ) íƒìƒ‰(ì˜®ê¸¸ ìœ„ì¹˜, ê°€ëŠ¥í•œ íƒ€ì…) ëª¨ë“  ê³³ì„ ê²€ì‚¬í–ˆì„ ë•Œë§Œ ëŒ€ê°ì„  íƒìƒ‰ 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#define MAX 16using namespace std;int n, answer;int map[MAX][MAX];bool check[MAX][MAX];// ì˜¤ë¥¸ìª½ 1ì¹¸ ê²€ì‚¬, ì•„ë˜ 1ì¹¸ ê²€ì‚¬, ì˜¤ë¥¸ìª½ ì•„ë˜ 1ì¹¸ ê²€ì‚¬int dx[3] = &#123; 0, 1, 1 &#125;; int dy[3] = &#123; 1, 0, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; n &amp;&amp; c &lt; n) return true; return false;&#125;// type 0 : ê°€ë¡œ, 1 : ì„¸ë¡œ, 2 : ëŒ€ê°ì„ void dfs(int r, int c, int type) &#123; if (r == n - 1 &amp;&amp; c == n - 1) &#123; answer++; return; &#125; // í˜„ì¬ íƒ€ì…ì´ ê°€ë¡œì¼ ë•Œ ì–´ì°¨í”¼ ëŒ€ê°ì„  ë•Œë¬¸ì— 3ì¹¸ ë‹¤ ê²€ì‚¬í•´ì•¼ í•œë‹¤. int x, y; bool flag = true; for (int i = 0; i &lt; 3; ++i) &#123; x = r + dx[i]; y = c + dy[i]; if (isBound(x, y)) &#123;// ê°™ì€ typeì¼ ê²½ìš° or ëŒ€ê°ì„ ì¼ ê²½ìš°, i==2ì´ë©´ ëŒ€ê°ì„  ê²½ìš°ê°€ í•œ ë²ˆ ë” êµ¬í•´ì§€ëŠ” ê¼´ì´ë‹¤. if ((map[x][y] == 0 &amp;&amp; type == i || map[x][y] == 0 &amp;&amp; type == 2) &amp;&amp; i != 2) &#123; dfs(x, y, i); &#125; else if (map[x][y] != 0) flag = false; &#125; else flag = false; &#125; if (flag) &#123; dfs(x, y, 2); // ì˜¤ë¥¸ìª½ ì•„ë˜ ëŒ€ê°ì„  &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); &#125; &#125; dfs(0, 1, 0); printf(\"%d\\n\", answer); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 16637ë²ˆ ê´„í˜¸ ì¶”ê°€í•˜ê¸°","slug":"Algorithm/BOJ/16637","date":"2020-01-25T08:04:06.000Z","updated":"2020-01-25T13:28:41.644Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/16637/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/16637/","excerpt":"","text":"#16637. ê´„í˜¸ ì¶”ê°€í•˜ê¸°Problem ë¬¸ì œë§í¬ Solution ì–´ëŠ ì—°ì‚°ìì— ê´„í˜¸ë¥¼ ë„£ì„ì§€ ì •í•´ì•¼ í•œë‹¤.ê´„í˜¸ëŠ” ì—°ì‚°ì ì—°ì†ìœ¼ë¡œ ë„£ì„ ìˆ˜ ì—†ë‹¤. (1+(3)-2) â†’ ë§ë„ ì•ˆë˜ëŠ” ì‹ê·¸ë ‡ê¸°ì— ì´ì „ ê´„í˜¸ì˜ ìœ„ì¹˜ë¥¼ ì•Œê³  ìˆì–´ì•¼ í•œë‹¤.ê´„í˜¸ëŠ” ì²« ë²ˆì§¸ì— ë„£ì„ í•„ìš”ëŠ” ì—†ìœ¼ë©°(op[i]â‰ 1)ì´ì „ ê´„í˜¸ì˜ ìœ„ì¹˜ì™€ 2 ì°¨ì´ê°€ ë‚˜ë©´ ì•ˆëœë‹¤. ê´„í˜¸ë¥¼ ëª¨ë‘ ì§€ì •í–ˆìœ¼ë©´ ê° ê²½ìš°ì— ë§ê²Œ ì‹ì„ ê³„ì‚°í•œë‹¤. ê´„í˜¸ê°€ ë“±ì¥í•˜ë©´ í•œ ë²ˆì— ê³„ì‚°í•˜ê³  ë°˜í™˜í•œë‹¤. Stackì„ ì‚¬ìš©í•˜ì—¬ ì—°ì‚°ìë§Œ ë„£ëŠ”ë‹¤. Stackì´ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´ êº¼ë‚´ì–´ ì—°ì‚°ìì— ë§ê²Œ ê³„ì‚°í•œë‹¤. 1 Try *(ê³±ì…ˆ)ì€ ê´„í˜¸ê°€ í•„ìš” ì—†ì„ ê²ƒì´ë¼ ìƒê°í•˜ì—¬ ê´„í˜¸ë¥¼ ë„£ì–´ì£¼ì§€ ì•Šì•˜ë‹¤.í•˜ì§€ë§Œ ì—°ì‚°ì€ ì™¼ìª½ì—ì„œë¶€í„° ìˆœì„œëŒ€ë¡œ ì§„í–‰ë˜ê¸°ì— ê³±ì…ˆë„ ê´„í˜¸ê°€ í•„ìš”í•˜ë‹¤. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;char expr[20];bool selected[20];int op[10];int N, ans, total_bracket;int TaskBracket(int start) &#123; int a = expr[start] - '0'; int b = expr[start+2] - '0'; char opr = expr[start + 1]; if (opr == '+') &#123; return a + b; &#125; else &#123; return a - b; &#125;&#125;void Calculate() &#123; int res = expr[0]-'0', tmp = 0, idx = 0; bool flag = false; stack&lt;char&gt; st; for (int i = 1; i &lt; N; ++i) &#123; if (i != N-1 &amp;&amp; selected[i+1]) &#123; tmp = TaskBracket(i); i+=2; flag = true; &#125; if (!st.empty()) &#123; if (st.top() == '+') &#123; if(flag) res += tmp; else res += int(expr[i] - '0'); &#125; else if (st.top() == '-') &#123; if(flag) res -= tmp; else res -= int(expr[i] - '0'); &#125; else &#123; if(flag) res *= tmp; else res *= int(expr[i] - '0'); &#125; st.pop(); flag = false; &#125; if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*') &#123; st.push(expr[i]); &#125; &#125; if (res &gt; ans) ans = res;&#125;void SelectBracket(int n, int cnt, int prior) &#123; if (cnt &lt;= total_bracket) &#123; Calculate(); &#125; for (int i = n; i &lt; total_bracket; ++i) &#123; if (selected[op[i]] || op[i] == 1) continue; if (op[i] - prior == 2) continue; selected[op[i]] = true; SelectBracket(i+1, cnt+1, op[i]); selected[op[i]] = false; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; expr[i]; if (expr[i] == '+' || expr[i] == '-') &#123; op[total_bracket++] = i; &#125; &#125; SelectBracket(0, 0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; 2 Try ans(ì •ë‹µ)ì˜ ì´ˆê¸°ê°’ì„ 0ìœ¼ë¡œ ì„¤ì •í•´ì„œ í‹€ë ¸ë‹¤. ì •ë‹µì€ (-2^31, 2^31)ì˜ ë²”ìœ„ì— ì†í•œë‹¤. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;char expr[20];bool selected[20];int op[10];int N, total_bracket, ans;int TaskBracket(int start) &#123; int a = expr[start] - '0'; int b = expr[start+2] - '0'; char opr = expr[start + 1]; if (opr == '+') &#123; return a + b; &#125; else if(opr == '-') &#123; return a - b; &#125; else return a * b;&#125;void Calculate() &#123; int res = expr[0]-'0', tmp = 0, idx = 0; bool flag = false; stack&lt;char&gt; st; for (int i = 1; i &lt; N; ++i) &#123; if (i != N-1 &amp;&amp; selected[i+1]) &#123; tmp = TaskBracket(i); i+=2; flag = true; &#125; if (!st.empty()) &#123; if (st.top() == '+') &#123; if(flag) res += tmp; else res += int(expr[i] - '0'); &#125; else if (st.top() == '-') &#123; if(flag) res -= tmp; else res -= int(expr[i] - '0'); &#125; else &#123; if(flag) res *= tmp; else res *= int(expr[i] - '0'); &#125; st.pop(); flag = false; &#125; if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*') &#123; st.push(expr[i]); &#125; &#125; if (res &gt; ans) ans = res;&#125;void SelectBracket(int n, int cnt, int prior) &#123; if (cnt &lt;= total_bracket) &#123; Calculate(); &#125; for (int i = n; i &lt; total_bracket; ++i) &#123; if (selected[op[i]] || op[i] == 1) continue; if (op[i] - prior == 2) continue; selected[op[i]] = true; SelectBracket(i+1, cnt+1, op[i]); selected[op[i]] = false; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; expr[i]; if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*') &#123; op[total_bracket++] = i; &#125; &#125; SelectBracket(0, 0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; 3 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;limits&gt;#include &lt;stack&gt;using namespace std;char expr[20];bool selected[20];int op[10];int N, total_bracket, ans = numeric_limits&lt;int&gt;::min();int TaskBracket(int start) &#123; int a = expr[start] - '0'; int b = expr[start+2] - '0'; char opr = expr[start + 1]; if (opr == '+') &#123; return a + b; &#125; else if(opr == '-') &#123; return a - b; &#125; else return a * b;&#125;void Calculate() &#123; int res = expr[0]-'0', tmp = 0, idx = 0; bool flag = false; stack&lt;char&gt; st; for (int i = 1; i &lt; N; ++i) &#123; if (i != N-1 &amp;&amp; selected[i+1]) &#123; // ê´„í˜¸ì¸ ê²½ìš° tmp = TaskBracket(i); // í•œ ë²ˆì— ê³„ì‚° i+=2; flag = true; &#125; if (!st.empty()) &#123; // ìŠ¤íƒì— ì—°ì‚°ìê°€ ìˆì„ ê²½ìš° if (st.top() == '+') &#123; if(flag) res += tmp; else res += int(expr[i] - '0'); &#125; else if (st.top() == '-') &#123; if(flag) res -= tmp; else res -= int(expr[i] - '0'); &#125; else &#123; if(flag) res *= tmp; else res *= int(expr[i] - '0'); &#125; st.pop(); flag = false; &#125; if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*') &#123; st.push(expr[i]); &#125; &#125; if (res &gt; ans) ans = res;&#125;void SelectBracket(int n, int cnt, int prior) &#123; if (cnt &lt;= total_bracket) &#123; Calculate(); &#125; for (int i = n; i &lt; total_bracket; ++i) &#123; if (selected[op[i]] || op[i] == 1) continue; // ì²« ë²ˆì§¸ ì—°ì‚°ìì— ê´„í˜¸ëŠ” í•„ìš” ì—†ë‹¤. if (op[i] - prior == 2) continue; // ì—°ì†ì ì¸ ê´„í˜¸ëŠ” ë¶ˆê°€ëŠ¥ selected[op[i]] = true; SelectBracket(i+1, cnt+1, op[i]); selected[op[i]] = false; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; expr[i]; if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*') &#123; op[total_bracket++] = i; &#125; &#125; SelectBracket(0, 0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 16236ë²ˆ ì•„ê¸° ìƒì–´","slug":"Algorithm/BOJ/16236","date":"2020-01-25T08:03:58.000Z","updated":"2020-01-25T13:16:42.342Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/16236/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/16236/","excerpt":"","text":"#16236. ì•„ê¸° ìƒì–´ë¬¸ì œë§í¬ Problem N x N ê³µê°„ ë¬¼ê³ ê¸° M, ì•„ê¸° ìƒì–´ 1ë§ˆë¦¬ (1ì¹¸ì— ìµœëŒ€ 1ë§ˆë¦¬) ì•„ê¸° ìƒì–´ ì²˜ìŒ í¬ê¸° : 2, ë¬¼ê³ ê¸°ë„ í¬ê¸° ì¡´ì¬ ì•„ê¸° ìƒì–´ ì›€ì§ì„ (1ì´ˆë§ˆë‹¤ ìƒí•˜ì¢Œìš°)ìì‹ ë³´ë‹¤ í° ë¬¼ê³ ê¸° ìˆëŠ” ì¹¸ì€ ëª» ê° ë‚˜ë¨¸ì§„ ì´ë™ ê°€ëŠ¥ìì‹ ë³´ë‹¤ ì‘ì€ ë¬¼ê³ ê¸°ë§Œ ë¨¹ì„ ìˆ˜ ìˆê³ , í¬ê¸°ê°€ ê°™ë‹¤ë©´ ì§€ë‚˜ê°€ëŠ”ê±´ ê°€ëŠ¥ ìì‹ ì˜ í¬ê¸°ë§Œí¼ ë¬¼ê³ ê¸°ë¥¼ ë¨¹ì–´ì•¼ í¬ê¸°ê°€ 1 ì¦ê°€í•œë‹¤. ìƒì–´ê°€ ì´ë™í•  ê³³ ê²°ì • ë°©ë²• ë” ì´ìƒ ë¨¹ì„ ë¬¼ê³ ê¸°ê°€ ì—†ìœ¼ë©´ ì¢…ë£Œ ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ê°€ 1ë§ˆë¦¬ë¼ë©´, ê·¸ ë¬¼ê³ ê¸°ë¥¼ ë¨¹ëŠ”ë‹¤. (ì—¬ê¸°ë¶€í„° ì´ë™) 1ë§ˆë¦¬ë³´ë‹¤ ë§ë‹¤ë©´, ê±°ë¦¬ê°€ ê°€ì¥ ê°€ê¹Œìš´ ë¬¼ê³ ê¸°ë¶€í„° ë¨¹ëŠ”ë‹¤. ê°€ì¥ ê°€ê¹Œìš´ ë¬¼ê³ ê¸°ê°€ ì—¬ëŸ¿ì´ë©´ ê°€ì¥ ìœ„ ê·¸ëŸ° ë¬¼ê³ ê¸°ê°€ ë˜ ì—¬ëŸ¿ì´ë©´ ê°€ì¥ ì™¼ìª½ì— ìˆëŠ” ë¬¼ê³ ê¸°ë¥¼ ë¨¹ëŠ”ë‹¤. Goal: ì¢…ë£Œë˜ëŠ” ì‹œê°„ì€? ì…ë ¥ 0: ë¹ˆ ì¹¸ 1~6: ë¬¼ê³ ê¸° í¬ê¸° 9: ì•„ê¸° ìƒì–´ Solution ì…ë ¥ê°’ ë‹¤ë£¨ê¸° struct shark { int r, c, size, cnt= 0; }baby; ì•„ê¸° ìƒì–´ì˜ ìœ„ì¹˜, í¬ê¸°, ë¨¹ì€ ìˆ˜ë¥¼ ì €ì¥í•  ìˆ˜ ìˆë„ë¡ êµ¬ì¡°ì²´ë¥¼ ë§Œë“ ë‹¤. ë‹¤ìŒ ì‘ì—…ì´ ë°˜ë³µëœë‹¤. ë¨¹ì´ë¥¼ ì°¾ê¸° ì°¾ì•˜ë‹¤ë©´ ê·¸ ì¤‘ ê·œì¹™ì— ë”°ë¼ ë¨¹ì´ ì„ íƒí•˜ê¸° ë¨¹ì´ ì°¾ê¸° íƒìƒ‰í•  queueì™€ ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ë¥¼ ì €ì¥í•  queueê°€ í•„ìš”í•˜ë‹¤. íƒìƒ‰ ì§€ì ì˜ í‘œì‹œë¥¼ ìœ„í•´ check ë°°ì—´ì´ í•„ìš”í•˜ë‹¤. ì•„ê¸° ìƒì–´ê°€ ì´ë™í•œ í›„ ë‹¤ìŒ ë¨¹ì´ê¹Œì§€ ì°¾ì•„ê°€ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ ë”°ë¡œ ì €ì¥í•´ì•¼ í•œë‹¤. (part_time) íƒìƒ‰í•  ì§€ì ì€ ê²½ê³„ë¥¼ ë„˜ì§€ ì•Šê³  ì•„ê¸° ìƒì–´ í¬ê¸°ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ê³  íƒìƒ‰í‘œì‹œê°€ ì•ˆëœ ì§€ì ì´ë‹¤. íƒìƒ‰ì´ ê°€ëŠ¥í•  ë•Œ íƒìƒ‰ í‘œì‹œë¥¼ í•˜ê³  íƒìƒ‰ queueì— ë„£ì–´ì¤€ë‹¤. ì•„ê¸° ìƒì–´ í¬ê¸°ë³´ë‹¤ ì‘ì€ ë¬¼ê³ ê¸°ë¼ë©´ ë¨¹ì´ queueì— ë„£ì–´ì¤€ë‹¤. 1ì´ˆê°„ ê°ˆ ìˆ˜ ìˆëŠ” íƒìƒ‰ì´ ëë‚˜ë©´ ë¨¹ì´ queueê°€ ë¹„ì–´ìˆëŠ”ì§€ë¥¼ íŒë‹¨í•œë‹¤. ë¨¹ì´ queueì— ë¨¹ì´ê°€ ë“¤ì–´ìˆìœ¼ë©´ ê±¸ë¦° ì‹œê°„(part_time)ì„ ë”í•´ì¤€ë‹¤. ë¨¹ì´ë¥¼ ì„ íƒí•œë‹¤.123456789101112131415161718192021222324252627282930313233void findPrey(int row, int col) &#123; queue&lt;pair&lt;int, int&gt;&gt; q, prey; q.push(&#123; row, col &#125;); memset(check, 0, sizeof(check)); check[row][col] = true; int part_time = 0; while (!q.empty()) &#123; // ìˆœíšŒí•  ë•Œë§ˆë‹¤ 1ì´ˆ ì¦ê°€ part_time++; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; baby.size &gt;= map[x][y] &amp;&amp; !check[x][y]) &#123; if (baby.size &gt; map[x][y] &amp;&amp; map[x][y] &gt; 0) &#123; prey.push(&#123; x, y &#125;); &#125; check[x][y] = true; q.push(&#123; x, y &#125;); &#125; &#125; &#125; if (!prey.empty()) &#123; selectPrey(prey); time += part_time; return; &#125; &#125; isEnd = true;&#125; ë§Œì•½ íƒìƒ‰ì„ ëª¨ë‘ í–ˆëŠ”ë°ë„ ë¨¹ì´ê°€ ì—†ë‹¤ë©´ isEndëŠ” trueê°€ ë˜ë¯€ë¡œ ì‘ì—…ì´ ì¢…ë£Œëœë‹¤. ê·œì¹™ì— ë”°ë¼ ë¨¹ì´ ì„ íƒí•˜ê¸°1234567891011121314151617181920212223242526void selectPrey(queue&lt;pair&lt;int, int&gt;&gt; &amp;prey) &#123; int prior_x = n, prior_y = n; while (!prey.empty()) &#123; int x = prey.front().first; int y = prey.front().second; prey.pop(); if (x &lt; prior_x) &#123; prior_x = x; prior_y = y; &#125; else if (x == prior_x) &#123; if (y &lt; prior_y) &#123; prior_y = y; &#125; &#125; &#125; map[baby.r][baby.c] = 0; map[prior_x][prior_y] = 9; baby.r = prior_x; baby.c = prior_y; baby.cnt++; if (baby.cnt == baby.size) &#123; baby.size++; baby.cnt = 0; &#125;&#125; ì´ ë¨¹ì´ queueì— ë“¤ì–´ìˆëŠ” (ì—¬ëŸ¿ì´ë¼ë©´)ë¬¼ê³ ê¸°ë“¤ì€ ëª¨ë‘ ê°™ì€ ê±°ë¦¬ì´ê¸°ì— ë¬¸ì œì˜ ê·œì¹™ì¸ ê°€ì¥ ìœ„ìª½ ìš°ì„ , ê°€ì¥ ì™¼ìª½ ìš°ì„ ì„ ë”°ë¼ ë¬¼ê³ ê¸°ë¥¼ ì„ íƒí•œë‹¤. ë¨¹ì„ ë¬¼ê³ ê¸°ê°€ ì„ íƒë˜ë©´ ì•„ê¸° ìƒì–´ì˜ ìœ„ì¹˜ë¥¼ ë³€ê²½í•´ì¤€ë‹¤. í¬ê¸° ë˜í•œ ë¨¹ì€ ìˆ˜ì— ë§ê²Œ ë³€ê²½í•´ì¤€ë‹¤. 1 Try ì‹œê°„ì´ˆê³¼ ì½”ë“œ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX 21using namespace std;int n, time;bool isEnd;int map[MAX][MAX];bool check[MAX][MAX];int dx[4] = &#123; -1, 0, 0, 1 &#125;;int dy[4] = &#123; 0, -1, 1, 0 &#125;;struct shark &#123; int r, c, size, cnt= 0;&#125;baby;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; n &amp;&amp; c &lt; n) return true; return false;&#125;void selectPrey(queue&lt;pair&lt;int, int&gt;&gt; &amp;prey, queue&lt;pair&lt;int, int&gt;&gt; &amp;q) &#123; int prior_x = n, prior_y = n; while (!prey.empty()) &#123; int x = prey.front().first; int y = prey.front().second; prey.pop(); if (x &lt; prior_x) &#123; prior_x = x; prior_y = y; &#125; else if (x == prior_x) &#123; if (y &lt; prior_y) &#123; prior_y = y; &#125; &#125; &#125; map[baby.r][baby.c] = 0; map[prior_x][prior_y] = 9; baby.r = prior_x; baby.c = prior_y; baby.cnt++; if (baby.cnt == baby.size) &#123; baby.size++; baby.cnt = 0; &#125; q.push(&#123; prior_x, prior_y &#125;);&#125;void findPrey(int row, int col) &#123; queue&lt;pair&lt;int, int&gt;&gt; q, prey; q.push(&#123; row, col &#125;); check[row][col] = true; int part_time = 0; while (!q.empty()) &#123; // ìˆœíšŒí•  ë•Œë§ˆë‹¤ 1ì´ˆ ì¦ê°€ part_time++; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; baby.size &gt;= map[x][y] &amp;&amp; !check[x][y]) &#123; if (baby.size &gt; map[x][y] &amp;&amp; map[x][y] &gt; 0) &#123; prey.push(&#123; x, y &#125;); &#125; check[x][y] = true; q.push(&#123; x, y &#125;); &#125; &#125; &#125; if (!prey.empty()) &#123; while (!q.empty()) q.pop(); selectPrey(prey, q); time = part_time; memset(check, 0, sizeof(check)); &#125; &#125; isEnd = true;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); if (map[i][j] == 9) &#123; // ì•„ê¸° ìƒì–´ ì •ë³´ baby.r = i; baby.c = j; baby.size = 2; &#125; &#125; &#125; while (!isEnd) &#123; findPrey(baby.r, baby.c); &#125; printf(\"%d\\n\", time); return 0;&#125; while (!q.empty()) q.pop(); ë¼ì¸ ë•Œë¬¸ì— ì‹œê°„ì´ˆê³¼ê°€ ê±¸ë¦° ê²ƒ ê°™ì•„ êµ³ì´ ì´ëŸ´ í•„ìš” ì—†ì´ ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ê°€ ìˆë‹¤ë©´ selectPrey() ë¥¼ í˜¸ì¶œí•˜ì—¬ ë¬¼ê³ ê¸°ë¥¼ ì„ íƒí•˜ê³  ì‹œê°„ì„ ê°±ì‹ í•´ì¤€ í›„ returní•˜ë„ë¡ í•˜ì˜€ë‹¤. ì´ëŸ¬ë©´ ë‹¤ì‹œ findPrey() ë¥¼ í˜¸ì¶œí•˜ê¸°ì— ì—…ë°ì´íŠ¸ ëœ ì•„ê¸° ìƒì–´ ìœ„ì¹˜ê°€ queueì— ë“¤ì–´ê°€ê³  ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤. që¥¼ ë¹„ìš¸ í•„ìš”ê°€ ì—†ì–´ì§. 2 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX 21using namespace std;int n, time;bool isEnd;int map[MAX][MAX];bool check[MAX][MAX];// ìƒì¢Œìš°í•˜int dx[4] = &#123; -1, 0, 0, 1 &#125;;int dy[4] = &#123; 0, -1, 1, 0 &#125;;struct shark &#123; int r, c, size, cnt= 0;&#125;baby;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; n &amp;&amp; c &lt; n) return true; return false;&#125;void selectPrey(queue&lt;pair&lt;int, int&gt;&gt; &amp;prey) &#123; int prior_x = n, prior_y = n; while (!prey.empty()) &#123; int x = prey.front().first; int y = prey.front().second; prey.pop(); if (x &lt; prior_x) &#123; prior_x = x; prior_y = y; &#125; else if (x == prior_x) &#123; if (y &lt; prior_y) &#123; prior_y = y; &#125; &#125; &#125; map[baby.r][baby.c] = 0; map[prior_x][prior_y] = 9; baby.r = prior_x; baby.c = prior_y; baby.cnt++; if (baby.cnt == baby.size) &#123; baby.size++; baby.cnt = 0; &#125;&#125;void findPrey(int row, int col) &#123; queue&lt;pair&lt;int, int&gt;&gt; q, prey; q.push(&#123; row, col &#125;); memset(check, 0, sizeof(check)); check[row][col] = true; int part_time = 0; while (!q.empty()) &#123; // ìˆœíšŒí•  ë•Œë§ˆë‹¤ 1ì´ˆ ì¦ê°€ part_time++; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; baby.size &gt;= map[x][y] &amp;&amp; !check[x][y]) &#123; if (baby.size &gt; map[x][y] &amp;&amp; map[x][y] &gt; 0) &#123; prey.push(&#123; x, y &#125;); &#125; check[x][y] = true; q.push(&#123; x, y &#125;); &#125; &#125; &#125; if (!prey.empty()) &#123; selectPrey(prey); time += part_time; return; &#125; &#125; isEnd = true;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); if (map[i][j] == 9) &#123; // ì•„ê¸° ìƒì–´ ì •ë³´ baby.r = i; baby.c = j; baby.size = 2; &#125; &#125; &#125; while (!isEnd) &#123; findPrey(baby.r, baby.c); &#125; printf(\"%d\\n\", time); return 0;&#125; Debug ì½”ë“œ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX 21using namespace std;int n, time;bool isEnd;int map[MAX][MAX];bool check[MAX][MAX];// ìƒì¢Œìš°í•˜int dx[4] = &#123; -1, 0, 0, 1 &#125;;int dy[4] = &#123; 0, -1, 1, 0 &#125;;struct shark &#123; int r, c, size, cnt= 0;&#125;baby;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; n &amp;&amp; c &lt; n) return true; return false;&#125;void selectPrey(queue&lt;pair&lt;int, int&gt;&gt; &amp;prey, queue&lt;pair&lt;int, int&gt;&gt; &amp;q) &#123; int prior_x = n, prior_y = n; while (!prey.empty()) &#123; int x = prey.front().first; int y = prey.front().second; prey.pop(); if (x &lt; prior_x) &#123; prior_x = x; prior_y = y; &#125; else if (x == prior_x) &#123; if (y &lt; prior_y) &#123; prior_y = y; &#125; &#125; &#125; map[baby.r][baby.c] = 0; map[prior_x][prior_y] = 9; baby.r = prior_x; baby.c = prior_y; baby.cnt++; if (baby.cnt == baby.size) &#123; baby.size++; baby.cnt = 0; &#125; q.push(&#123; prior_x, prior_y &#125;); /*printf(\"change %d\\n\"); for (int k = 0; k &lt; n; ++k) &#123; for (int l = 0; l &lt; n; ++l) &#123; printf(\"%d \", map[k][l]); &#125; printf(\"\\n\"); &#125;*/&#125;void findPrey(int row, int col) &#123; queue&lt;pair&lt;int, int&gt;&gt; q, prey; q.push(&#123; row, col &#125;); check[row][col] = true; int part_time = 0; while (!q.empty()) &#123; // ìˆœíšŒí•  ë•Œë§ˆë‹¤ 1ì´ˆ ì¦ê°€ part_time++; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; baby.size &gt;= map[x][y] &amp;&amp; !check[x][y]) &#123; if (baby.size &gt; map[x][y] &amp;&amp; map[x][y] &gt; 0) &#123; prey.push(&#123; x, y &#125;); &#125; check[x][y] = true; q.push(&#123; x, y &#125;); &#125; &#125; &#125; if (!prey.empty()) &#123; while (!q.empty()) q.pop(); selectPrey(prey, q); time = part_time; memset(check, 0, sizeof(check)); &#125; &#125; isEnd = true;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); if (map[i][j] == 9) &#123; // ì•„ê¸° ìƒì–´ ì •ë³´ baby.r = i; baby.c = j; baby.size = 2; &#125; &#125; &#125; while (!isEnd) &#123; findPrey(baby.r, baby.c); &#125; printf(\"%d\\n\", time); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 16235ë²ˆ ë‚˜ë¬´ ì¬í…Œí¬","slug":"Algorithm/BOJ/16235","date":"2020-01-25T08:03:54.000Z","updated":"2020-01-25T13:16:42.339Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/16235/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/16235/","excerpt":"","text":"#16235. ë‚˜ë¬´ ì¬í…Œí¬Problem ë¬¸ì œë§í¬ Solution ì‹œë®¬ë ˆì´ì…˜ ë¬¸ì œì´ë‹¤. ë´„, ì—¬ë¦„, ê°€ì„, ê²¨ìš¸ì— ë§ê²Œ ì‘ì—…ì„ ìˆ˜í–‰í•˜ë©´ ëœë‹¤. ë‹¨ í•œ ì¹¸ì— ì—¬ëŸ¬ ê°œì˜ ë‚˜ë¬´ê°€ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤ëŠ” ì ì— ì£¼ëª©í•˜ì. ì²˜ìŒì— 3ì°¨ì› ë²¡í„°ë¡œ í•´ë‹¹ ì¹¸ì— ë‚˜ë¬´ ì •ë³´ë¥¼ ì €ì¥í•˜ì˜€ì§€ë§Œ ê³„ì ˆë§ˆë‹¤ ì‘ì—…ì„ ìˆ˜í–‰í•  ë•Œ ìƒë‹¹íˆ ë¹„íš¨ìœ¨ì ì´ë¼ ì‹œê°„ì´ˆê³¼ê°€ ë–´ë‹¤. â†’ ë¬¸ì œì˜ ì¡°ê±´ì„ ì˜ ë³´ë©´ ë‹µì´ ë³´ì¸ë‹¤. (í•­ìƒ ëŠë¼ëŠ” ê±°ì§€ë§Œ ì–´ë–¤ ìë£Œêµ¬ì¡°ë¥¼ ì„ íƒí• ì§€ê°€ ì¤‘ìš”) ë‚˜ì´ê°€ ì–´ë¦° ë‚˜ë¬´ë¶€í„° ì–‘ë¶„ì„ ë¨¹ëŠ”ë‹¤. (í•´ë‹¹ ì¹¸ì— ìˆëŠ” ë‚˜ë¬´ ì •ë³´ë¥¼ ìˆœíšŒí•  ë•Œ ì–´ë¦° ë‚˜ë¬´ë¶€í„° ì ‘ê·¼í•´ì•¼ í•œë‹¤.) ë‚˜ë¬´ ì •ë³´ë¥¼ ì²˜ìŒì— ì…ë ¥ë°›ì„ ë•Œ í•œ ì¹¸ì— í•˜ë‚˜ì”©ë§Œ ë°›ëŠ”ë‹¤. ë‚˜ë¬´ê°€ ì¶”ê°€ë  ë•Œ ë‚˜ì´ê°€ 1ì¸ ë‚˜ë¬´ê°€ ì¶”ê°€ëœë‹¤. ë‚˜ì´ê°€ í´ìˆ˜ë¡ ë¨¼ì € ì£½ìŒ(ë‚˜ì´ë§Œí¼ ì–‘ë¶„ì„ ë¨¹ê¸° ë•Œë¬¸ì´ë‹¤.) ìœ„ ì¡°ê±´ì„ ë„í•©í•˜ë©´ deque ê°€ ê°€ì¥ ì í•©í•˜ë‹¤. deque&lt;int&gt; tree[10][10]ë‚˜ì´ê°€ ì–´ë¦° ë‚˜ë¬´ê°€ ì•ì— ì¦‰, ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆì–´ì•¼ í•˜ëŠ”ë°, ì²˜ìŒì— ê° ì¹¸ì— í•˜ë‚˜ì”© ì…ë ¥ ë°›ê³  ì¶”ê°€ë  ë•Œ ì•ë¶€ë¶„ì— ë‚˜ë¬´ë¥¼ ì¶”ê°€í•´ì£¼ë©´ ë˜ê¸° ë•Œë¬¸ì´ë‹¤. ì£½ëŠ”ê±´ ì•ì—ì„œë¶€í„° íƒìƒ‰ì„ í•˜ë‹¤ê°€ ì£½ëŠ” ë‚˜ë¬´ê°€ ìƒê¸°ë©´ ê·¸ ë’¤ë¶€í„° ì´ë¯¸ ì£½ì€ ë‚˜ë¬´ê°€ ë˜ê¸°ì— ì£½ì„ ë‚˜ë¬´ ê°œìˆ˜ë§Œ ì¹´ìš´íŠ¸í•˜ê³  ë’¤ì—ì„œë¶€í„° ê°œìˆ˜ë§Œí¼ popí•˜ë©´ ë˜ê¸° ë•Œë¬¸ì´ë‹¤. 1 Try code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int N, M, K, ans, diff;int land[10][10];int A[10][10];int dx[8] = &#123; -1, -1, 0, 1, 1, 1, 0, -1 &#125;;int dy[8] = &#123; 0, -1, -1, -1, 0, 1, 1, 1 &#125;;vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; v;void Input() &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; for (int i = 0; i &lt; N; ++i) &#123; v.resize(N); for (int j = 0; j &lt; N; ++j) &#123; v[i].resize(N); cin &gt;&gt; A[i][j]; land[i][j] = 5; &#125; &#125; for (int i = 0; i &lt; M; ++i) &#123; int r, c, age; cin &gt;&gt; r &gt;&gt; c &gt;&gt; age; v[r-1][c-1].push_back(age); &#125;&#125;void Task() &#123; // ë´„, ì—¬ë¦„ for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (v[i][j].size() &gt; 1) sort(v[i][j].begin(), v[i][j].end()); int sum = 0; for (int k = 0; k &lt; v[i][j].size(); ++k) &#123; if (v[i][j][k] == 0) continue; if (land[i][j] - v[i][j][k] &lt; 0) &#123; sum += v[i][j][k] / 2; v[i][j][k] = 0; // ì£½ì€ í‘œì‹œ diff++; &#125; else &#123; land[i][j] -= v[i][j][k]; v[i][j][k]++; &#125; &#125; land[i][j] += sum; &#125; &#125; // ê°€ì„, ê²¨ìš¸ for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; for (int k = 0; k &lt; v[i][j].size(); ++k) &#123; if (v[i][j][k] == 0) continue; if (v[i][j][k] % 5 == 0) &#123; for (int dir = 0; dir &lt; 8; ++dir) &#123; int r = i + dx[dir]; int c = j + dy[dir]; if (r &lt;= -1 || c &lt;= -1 || r &gt;= N || c &gt;= N) continue; v[r][c].push_back(1); &#125; &#125; &#125; land[i][j] += A[i][j]; &#125; &#125;&#125;int main() &#123; Input(); while (K--) &#123; Task(); &#125; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; ans += v[i][j].size(); &#125; &#125; ans -= diff; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; ì‹œê°„ì´ˆê³¼ 2 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;int N, M, K, ans;int land[10][10];int A[10][10];int dx[8] = &#123; -1, -1, 0, 1, 1, 1, 0, -1 &#125;;int dy[8] = &#123; 0, -1, -1, -1, 0, 1, 1, 1 &#125;;deque&lt;int&gt; tree[10][10];void Input() &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; ans = M; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; cin &gt;&gt; A[i][j]; land[i][j] = 5; &#125; &#125; for (int i = 0; i &lt; M; ++i) &#123; int r, c, age; cin &gt;&gt; r &gt;&gt; c &gt;&gt; age; tree[r - 1][c - 1].push_back(age); &#125;&#125;void Task() &#123; // ë´„, ì—¬ë¦„ for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (tree[i][j].empty()) continue; int sum = 0, dead_num = 0; for (auto iter = tree[i][j].begin(); iter != tree[i][j].end(); ++iter) &#123; if (land[i][j] - *iter &lt; 0) &#123; sum += (*iter) / 2; dead_num++; ans--; &#125; else &#123; land[i][j] -= (*iter); (*iter)++; &#125; &#125; for (int k = 0; k &lt; dead_num; ++k) tree[i][j].pop_back(); land[i][j] += sum; &#125; &#125; // ê°€ì„, ê²¨ìš¸ for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; for (auto iter = tree[i][j].begin(); iter != tree[i][j].end(); ++iter) &#123; if ((*iter) % 5 == 0) &#123; for (int dir = 0; dir &lt; 8; ++dir) &#123; int r = i + dx[dir]; int c = j + dy[dir]; if (r &lt;= -1 || c &lt;= -1 || r &gt;= N || c &gt;= N) continue; tree[r][c].push_front(1); ans++; &#125; &#125; &#125; land[i][j] += A[i][j]; &#125; &#125;&#125;int main() &#123; Input(); while (K--) &#123; Task(); &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 16234ë²ˆ ì¸êµ¬ ì´ë™","slug":"Algorithm/BOJ/16234","date":"2020-01-25T08:03:51.000Z","updated":"2020-01-25T13:16:42.331Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/16234/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/16234/","excerpt":"","text":"#16234. ì¸êµ¬ ì´ë™Problem ë¬¸ì œë§í¬ Solution BFS N x N í¬ê¸°ì˜ ë°°ì—´ì„ ì „ë¶€ íƒìƒ‰í•˜ë©´ì„œ checkí‘œì‹œê°€ ë˜ì–´ìˆì§€ ì•Šì€ ë¶€ë¶„ì€ ì¸êµ¬ ì´ë™ì´ ê°€ëŠ¥í•œì§€ í™•ì¸ ì‘ì—…ì´ ìˆ˜í–‰ëœë‹¤. ì‘ì—… ë™ì•ˆ ëˆ„ì  í•©ê³¼ ì—°í•©ì— í¬í•¨ëœ ë‚˜ë¼ ìˆ˜ë¥¼ ê³„ì‚°í•´ì•¼ í•œë‹¤. queueê°€ ë¹„ì–´ìˆì„ ë•Œê¹Œì§€ ë‹¤ìŒì„ ìˆ˜í–‰í•œë‹¤. í˜„ì¬ ìœ„ì¹˜ì—ì„œ 4ë°©í–¥ íƒìƒ‰ â†’ ë²”ìœ„ì²´í¬, íƒìƒ‰í•  ìœ„ì¹˜ê°€ ë¯¸íƒìƒ‰ì¸ì§€ í™•ì¸ íƒìƒ‰ ê°€ëŠ¥í•˜ë©´ ëˆ„ì  í•©, ë‚˜ë¼ ìˆ˜ ê³„ì‚°, ì¢…ë£Œë˜ì§€ ì•Šê²Œ flag ê°±ì‹ , queueì— ë„£ì–´ì¤€ë‹¤. ë§Œì•½ ë‚˜ë¼ ìˆ˜ê°€ 1ë³´ë‹¤ í¬ë©´ ëˆ„ì í•©ê³¼ ì‚¬ëŒ ìˆ˜ë¥¼ ë”°ë¡œ ì €ì¥í•œë‹¤. ìœ„ ì‘ì—…ì´ ëë‚˜ë©´ ì´ì œ ë”°ë¡œ ì €ì¥í•œ ëˆ„ì í•©ê³¼ ì‚¬ëŒ ìˆ˜ë¥¼ ì´ìš©í•´ N x N í¬ê¸°ì˜ ë°°ì—´ì„ ë°”ê¿”ì¤€ë‹¤. (ì‹¤ì§ˆì  ì¸êµ¬ ì´ë™) ë§Œì•½ flagê°€ false ì¦‰, ì¸êµ¬ì´ë™ì´ ì—†ë‹¤ë©´ ì¢…ë£Œí•œë‹¤. DFS BFSë³´ë‹¤ í›¨ì”¬ ë¹ ë¥´ê³  ê¹”ë”í•˜ë©° ëª…ë£Œí•˜ë‹¤. ì²˜ìŒì— BFSë¡œ í•  ìƒê°ì„ í–ˆë˜ ê²ƒì€ N x N í¬ê¸°ì˜ ë°°ì—´ ê°’ì„ ë¯¸ë¦¬ ë°”ê¾¸ë©´ ì¸êµ¬ ì´ë™ì— ì˜í–¥ì„ ë¯¸ì¹˜ê²Œ ëœë‹¤ëŠ” ìƒê°ì— ì½”ë“œë¥¼ ì‘ì„±í–ˆì—ˆëŠ”ë° ìƒê°í•´ë³´ë‹ˆ í•œ ë²ˆ íƒìƒ‰ì´ ëë‚˜ë©´(BFSë“  DFSë“ ) check í‘œì‹œ ë˜ì–´ ìˆê¸°ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šê³  í•œ ë²ˆ íƒìƒ‰í•  ë•Œ ìœ„ì¹˜ë§Œ ë¯¸ë¦¬ ë²¡í„°ì— ì €ì¥í•´ì£¼ë©´ ëœë‹¤. BFS 1 Try code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;tuple&gt; using namespace std;int N, L, R, idx, ans;bool no_end;int map[51][51];int check[51][51]; // 1, 2, 3int val[1251][2]; // ê°’, ì‚¬ëŒ ìˆ˜int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; N &amp;&amp; y &lt; N) return true; return false;&#125;void movePeople(int r, int c) &#123; idx++; int sum = map[r][c], cnt = 1; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123; r, c &#125;); check[r][c] = idx; while (!q.empty()) &#123; int x, y; tie(x, y) = q.front(); q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (isBound(d_x, d_y) &amp;&amp; check[d_x][d_y] == 0) &#123; if (abs(map[x][y] - map[d_x][d_y]) &gt;= L &amp;&amp; abs(map[x][y] - map[d_x][d_y]) &lt;= R) &#123; check[d_x][d_y] = idx; q.push(&#123; d_x, d_y &#125;); no_end = true; cnt++; sum += map[d_x][d_y]; &#125; &#125; &#125; &#125; if (cnt &gt; 1) &#123; val[idx][0] = sum; val[idx][1] = cnt; &#125; else &#123; check[r][c] = 0; idx--; &#125;&#125;void changePeople() &#123; bool no_move = true; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (check[i][j] == 0) continue; map[i][j] = val[check[i][j]][0] / val[check[i][j]][1]; check[i][j] = 0; no_move = false; &#125; &#125; if (!no_move) ans++;&#125;int main() &#123; scanf(\"%d %d %d\", &amp;N, &amp;L, &amp;R); for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); &#125; &#125; do &#123; idx = 0; no_end = false; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (check[i][j] &gt; 0) continue; movePeople(i, j); &#125; &#125; changePeople(); &#125; while (no_end); printf(\"%d\\n\", ans); return 0;&#125; DFS 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int N, L, R, sum, ans;int map[51][51];bool check[51][51]; vector&lt;pair&lt;int, int&gt; &gt; v; // ìœ„ì¹˜ ì •ë³´int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; N &amp;&amp; y &lt; N) return true; return false;&#125;void dfs(int x, int y) &#123; sum += map[x][y]; v.push_back(&#123; x, y &#125;); check[x][y] = true; for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (isBound(d_x, d_y) &amp;&amp; !check[d_x][d_y]) &#123; if (abs(map[x][y] - map[d_x][d_y]) &gt;= L &amp;&amp; abs(map[x][y] - map[d_x][d_y]) &lt;= R) &#123; dfs(d_x, d_y); &#125; &#125; &#125;&#125;bool task() &#123; bool change = false; memset(check, 0, sizeof(check)); for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (check[i][j]) continue; sum = 0; v.clear(); dfs(i, j); if (v.size() == 1) continue; for (auto e : v) &#123; map[e.first][e.second] = sum / v.size(); &#125; change = true; &#125; &#125; return change;&#125;int main() &#123; scanf(\"%d %d %d\", &amp;N, &amp;L, &amp;R); for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); &#125; &#125; while (task()) &#123; ans++; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 15686ë²ˆ ì¹˜í‚¨ ë°°ë‹¬","slug":"Algorithm/BOJ/15686","date":"2020-01-25T08:03:46.000Z","updated":"2020-01-25T13:16:42.344Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/15686/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/15686/","excerpt":"","text":"#15686. ì¹˜í‚¨ ë°°ë‹¬ë¬¸ì œë§í¬ Problem N x N ë„ì‹œ 0: ë¹ˆ ì¹¸, 1: ì§‘, 2: ì¹˜í‚¨ ì§‘ ë„ì‹œì˜ ì¹˜í‚¨ ê±°ë¦¬ëŠ” ëª¨ë“  ì§‘ì˜ ì¹˜í‚¨ ê±°ë¦¬ì˜ í•© ì¹˜í‚¨ ê±°ë¦¬ ( ì§‘: (r1, c1) ì¹˜í‚¨ì§‘: (r2, c2) )ì§‘ê³¼ ê°€ì¥ ê°€ê¹Œìš´ ì¹˜í‚¨ì§‘ ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ë§í•œë‹¤. |r_1-r_2| +|c_1-c_2|Goal: ì¹˜í‚¨ì§‘ ì¤‘ì—ì„œ ìµœëŒ€ Mê°œë¥¼ ê³¨ëì„ ë•Œ ë„ì‹œì˜ ì¹˜í‚¨ ê±°ë¦¬ ìµœì†Ÿê°’ Solution ì¹˜í‚¨ ì§‘ì„ Mê°œ ê³ ë¥´ëŠ” ëª¨ë“  ì¡°í•© êµ¬í•˜ê¸° í•´ë‹¹ ì§‘ì„ ê³ ë¥´ë©´ ë°°ì—´ì— ë„£ê³  ì•„ë‹ˆë©´ ë„£ì§€ ì•ŠìŒ1234567891011void combination(int idx) &#123; if (select_idx == m) &#123; BFS ì´ìš©í•˜ì—¬ ì¹˜í‚¨ ê±°ë¦¬ êµ¬í•˜ê¸° return; &#125; if (idx == total_chicken) return; combination(idx + 1); // ì„ íƒí•˜ì§€ ì•Šê¸° select[select_idx++] = idx; combination(idx + 1); // ì„ íƒí•˜ê¸° select_idx--; // ë‹¤ë¥¸ ê²½ìš°ì˜ ìˆ˜ë¥¼ ìœ„í•´ ì¸ë±ìŠ¤ ë¹¼ì£¼ê¸° (ì¤‘ìš”)&#125;ì¤‘ìš”ë¼ê³  ë˜ì–´ìˆëŠ” ë¶€ë¶„ì„ ì‘ì„±í•˜ì§€ ì•Šìœ¼ë©´ ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•  ìˆ˜ ì—†ë‹¤. ê²½ìš°ì˜ ìˆ˜ê°€ ê¼¬ì—¬ë²„ë¦¼. 4ê°œ ì¤‘ì— 2ê°œë¥¼ ê³ ë¥¸ë‹¤ê³  í•˜ë©´12345678comb(0) comb(1) comb(2) comb(3) ... ì´ëŸ°ì‹ìœ¼ë¡œ í˜¸ì¶œì´ ì´ë£¨ì–´ì§€ê¸°ì— (3, 2) ê²½ìš°ê°€ ë¨¼ì € ì™„ì„±ëœë‹¤. ì™„ì„±ë˜ê³  BFSì´ìš©í•˜ì—¬ ì¹˜í‚¨ ê±°ë¦¬ êµ¬í•˜ê³  returnë˜ë©´ select_idxë¥¼ ë¹¼ì¤€ë‹¤. ê·¸ëŸ¼ 2ìë¦¬ì— ë‹¤ë¥¸ ê²½ìš°ê°€ ë„£ì–´ì§ˆ ìˆ˜ ìˆë‹¤. (3, 1) ê° ì¡°í•©ì— ëŒ€í•œ ìµœì†Œí•œì˜ ì¹˜í‚¨ ê±°ë¦¬ êµ¬í•˜ê¸° BFSë¥¼ ì´ìš©í•˜ì—¬ í•œ ì¹¸ì”© ê°ˆ ë•Œ 1ì´ˆ ì¦ê°€ ê·¸ëŸ¬ë‹¤ 1ì„ ë§Œë‚˜ë©´ í•´ë‹¹ ì´ˆë¥¼ ë” í•´ì¤€ë‹¤.BFSë¥¼ ì´ìš©í•˜ë©´ ë™ì‹œì— 1ì„ ë§Œë‚˜ê¸°ì— timeë§Œ ë”í•´ì£¼ì–´ì„œëŠ” ì•ˆëœë‹¤.ë™ì‹œì— ë°œê²¬í•œ ì§‘ì˜ ìˆ˜ë§Œí¼ timeì„ ë”í•´ì£¼ì–´ì•¼ í•œë‹¤. ëª¨ë“  1ì„ ë§Œë‚¬ìœ¼ë©´ ì¢…ë£Œ123456789101112131415161718192021222324252627282930void bfs() &#123; int time = 0, house = 0, dist = 0; memset(check, 0, sizeof(check)); queue&lt;pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; select_idx; ++i) &#123; q.push(&#123; chicken[select[i]].r, chicken[select[i]].c &#125;); while (!q.empty()) &#123; time++; int cnt = 0; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); check[r][c] = true; for (int i = 0; i &lt; 4; ++i) &#123; int x = r + dx[i]; int y = c + dy[i]; if (isBound(x, y) &amp;&amp; !check[x][y]) &#123; check[x][y] = true; if (city[x][y] == 1) &#123; house++; cnt++; &#125; q.push(&#123; x, y &#125;); &#125; &#125; &#125; dist += time * cnt; // í•´ë‹¹ ì´ˆì— ë§Œë‚œ ì§‘ì˜ ìˆ˜ ë§Œí¼ ì´ë™ê±°ë¦¬ ë”í•´ì£¼ê¸° &#125;&#125; ì´ ì¤‘ ê°€ì¥ ìµœì†Œì¸ ì¹˜í‚¨ ê±°ë¦¬ êµ¬í•˜ê¸° 12345dist += time * cnt; // í•´ë‹¹ ì´ˆì— ë§Œë‚œ ì§‘ì˜ ìˆ˜ ë§Œí¼ ì´ë™ê±°ë¦¬ ë”í•´ì£¼ê¸°if (total_house == house) &#123; answer = answer &gt; dist ? dist : answer; return;&#125; 1 Try ì»´íŒŒì¼ ì—ëŸ¬ (indexë¼ëŠ” ë³€ìˆ˜ëª…ì€ ê¸°í”¼í•˜ìâ€¦) select_idxë¡œ ë³€ê²½ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX 51using namespace std;int n, m, total_chicken, total_house, index, answer;int city[MAX][MAX];bool check[MAX][MAX];int select[13];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;struct INFO &#123; int r, c;&#125;chicken[13];bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; n &amp;&amp; c &lt; n) return true; return false;&#125;void bfs() &#123; int time = 0, house = 0, dist = 0; memset(check, 0, sizeof(check)); queue&lt;pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; index; ++i) &#123; q.push(&#123; chicken[select[i]].r, chicken[select[i]].c &#125;); // ì„ íƒí•œ ì¹˜í‚¨ì§‘ queueì— ì €ì¥ &#125; while (!q.empty()) &#123; time++; int cnt = 0; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); check[r][c] = true; for (int i = 0; i &lt; 4; ++i) &#123; int x = r + dx[i]; int y = c + dy[i]; if (isBound(x, y) &amp;&amp; !check[x][y]) &#123; check[x][y] = true; if (city[x][y] == 1) &#123; house++; cnt++; &#125; q.push(&#123; x, y &#125;); &#125; &#125; &#125; dist += time * cnt; // í•´ë‹¹ ì´ˆì— ë§Œë‚œ ì§‘ì˜ ìˆ˜ ë§Œí¼ ì´ë™ê±°ë¦¬ ë”í•´ì£¼ê¸° if (total_house == house) &#123; answer = answer &gt; dist ? dist : answer; return; &#125; &#125;&#125;void combination(int idx) &#123; // Mê°œë¥¼ ì„ íƒí•˜ëŠ” ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ êµ¬í•˜ê¸° if (index == m) &#123; bfs(); return; &#125; if (idx == total_chicken) return; combination(idx + 1); select[index++] = idx; combination(idx + 1); index--;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;city[i][j]); if (city[i][j] == 2) &#123; // ì¹˜í‚¨ì§‘ ì •ë³´ ì €ì¥ chicken[total_chicken].r = i; chicken[total_chicken++].c = j; &#125; else if (city[i][j] == 1) total_house++; &#125; &#125; answer = 1e9; combination(0); printf(\"%d\\n\", answer); return 0;&#125; 2 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX 51using namespace std;int n, m, total_chicken, total_house, select_idx, answer;int city[MAX][MAX];bool check[MAX][MAX];int select[13];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;struct INFO &#123; int r, c;&#125;chicken[13];bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; n &amp;&amp; c &lt; n) return true; return false;&#125;void bfs() &#123; int time = 0, house = 0, dist = 0; memset(check, 0, sizeof(check)); queue&lt;pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; select_idx; ++i) &#123; q.push(&#123; chicken[select[i]].r, chicken[select[i]].c &#125;); // ì„ íƒí•œ ì¹˜í‚¨ì§‘ queueì— ì €ì¥ &#125; while (!q.empty()) &#123; time++; int cnt = 0; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int r = q.front().first; int c = q.front().second; q.pop(); check[r][c] = true; for (int i = 0; i &lt; 4; ++i) &#123; int x = r + dx[i]; int y = c + dy[i]; if (isBound(x, y) &amp;&amp; !check[x][y]) &#123; check[x][y] = true; if (city[x][y] == 1) &#123; house++; cnt++; &#125; q.push(&#123; x, y &#125;); &#125; &#125; &#125; dist += time * cnt; // í•´ë‹¹ ì´ˆì— ë§Œë‚œ ì§‘ì˜ ìˆ˜ ë§Œí¼ ì´ë™ê±°ë¦¬ ë”í•´ì£¼ê¸° if (total_house == house) &#123; answer = answer &gt; dist ? dist : answer; return; &#125; &#125;&#125;void combination(int idx) &#123; // Mê°œë¥¼ ì„ íƒí•˜ëŠ” ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ êµ¬í•˜ê¸° if (select_idx == m) &#123; bfs(); return; &#125; if (idx == total_chicken) return; combination(idx + 1); select[select_idx++] = idx; combination(idx + 1); select_idx--;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;city[i][j]); if (city[i][j] == 2) &#123; // ì¹˜í‚¨ì§‘ ì •ë³´ ì €ì¥ chicken[total_chicken].r = i; chicken[total_chicken++].c = j; &#125; else if (city[i][j] == 1) total_house++; &#125; &#125; answer = 1e9; combination(0); printf(\"%d\\n\", answer); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 15685ë²ˆ ë“œë˜ê³¤ ì»¤ë¸Œ","slug":"Algorithm/BOJ/15685","date":"2020-01-25T08:03:41.000Z","updated":"2020-01-25T13:16:42.337Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/15685/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/15685/","excerpt":"","text":"#15685. ë“œë˜ê³¤ ì»¤ë¸Œë¬¸ì œë§í¬ Problem ì¢Œí‘œ í‰ë©´ 3ê°€ì§€ ì†ì„± ì‹œì‘ ì  ì‹œì‘ ë°©í–¥0: x ì¢Œí‘œ ì¦ê°€ â†’ ë°©í–¥1: y ì¢Œí‘œ ê°ì†Œ â†‘ ë°©í–¥2: x ì¢Œí‘œ ê°ì†Œ â† ë°©í–¥3: y ì¢Œí‘œ ì¦ê°€ â†“ ë°©í–¥ ì„¸ëŒ€ 0ì„¸ëŒ€: ê¸¸ì´ê°€ 1ì¸ ì„ ë¶„ 1ì„¸ëŒ€: 0ì„¸ëŒ€ ë“œë˜ê³¤ ì»¤ë¸Œ ë ì ì„ ê¸°ì¤€ìœ¼ë¡œ ì‹œê³„ ë°©í–¥ 90ë„ íšŒì „ì‹œì¼œ 0ì„¸ëŒ€ ë ì ì— ë¶™ì¸ ê²ƒ 2ì„¸ëŒ€: 1ì„¸ëŒ€ë¥¼ ì´ìš©í•˜ì—¬ 1ì„¸ëŒ€ë¥¼ ë§Œë“  ê²ƒì²˜ëŸ¼ ë§Œë“ ë‹¤. Nì„¸ëŒ€: N-1ì„¸ëŒ€ ì»¤ë¸Œë¥¼ ë ì  ê¸°ì¤€ìœ¼ë¡œ 90ë„ ì‹œê³„ ë°©í–¥ íšŒì „ì‹œí‚¨ ê²ƒì„ ë¶™ì¸ ê²ƒ ì…ë ¥ ë“œë˜ê³¤ ì»¤ë¸Œ ê°œìˆ˜ N (~20) x, y (ë“œë˜ê³¤ ì»¤ë¸Œ ì‹œì‘ ì ) ~100 d (ì‹œì‘ ë°©í–¥) g (ì„¸ëŒ€) ~10 ë“œë˜ê³¤ ì»¤ë¸ŒëŠ” ì„œë¡œ ê²¹ì¹  ìˆ˜ ìˆë‹¤. Goal: ë§Œë“¤ì–´ì§„ ë“œë˜ê³¤ ì»¤ë¸Œì—ì„œ ì •ì‚¬ê°í˜• 4ê°œì˜ ê¼­ì§“ì ì´ ëª¨ë‘ ë“œë˜ê³¤ ì»¤ë¸Œì˜ ì¼ë¶€ì¸ ê²ƒì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ê¸° (ëª¨ì–‘ì´ ì •ì‚¬ê°í˜•ì´ ì•„ë‹ˆì–´ë„ 4ê°œì˜ ê¼­ì§“ì ë§Œ ë§Œì¡±í•˜ë©´ ëœë‹¤.) Solution ëì ì„ ê¸°ì¤€ìœ¼ë¡œ ì‹œê³„ë°©í–¥ 90ë„ë¥¼ í–ˆì„ ë•Œ ê° ë°©í–¥ì˜ ì´ë™ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. 0 â†’ 1 1 â†’ 2 2 â†’ 3 3 â†’ 0 ì•„ë˜ ê·¸ë¦¼ ì°¸ê³ . ë“œë˜ê³¤ ì»¤ë¸Œë¥¼ ê·¸ë ¤ì£¼ëŠ” ê±´ check ë°°ì—´ë¡œ ìˆ˜í–‰í•œë‹¤.(ê²¹ì³ë„ ë˜ë‹ˆê¹Œ ì´ˆê¸°í™”í•  í•„ìš” ì—†ë‹¤.) ë°©í–¥ë§Œ ë°°ì—´ì— ì €ì¥í•´ì£¼ë©´ ëœë‹¤. ëì ì—ì„œ ì´ë™ì„ ìˆ˜í–‰í•˜ë‹ˆ ìœ„ì¹˜ ì¢Œí‘œëŠ” ëì ë§Œ ì•Œë©´ëœë‹¤. 12345// input : 3 3 0 1(3, 3) : ì²˜ìŒ ì‹œì‘ ìœ„ì¹˜(4, 3) : 0ì„¸ëŒ€ // ìœ„ì¹˜ ì¢Œí‘œ: (4, 3) ë°©í–¥ 0(4, 2) : 1ì„¸ëŒ€ // ìœ„ì¹˜ ì¢Œí‘œ: (4, 2) ë°©í–¥ 0, 1(3, 2), (3, 1) : 2ì„¸ëŒ€ // ìœ„ì¹˜ ì¢Œí‘œ: (3, 2) -&gt; (3,1) ë°©í–¥ 0, 1, 2, 1 2ì„¸ëŒ€ ì„¤ëª…: 1ì„¸ëŒ€ì—ì„œ ë°©í–¥ì´ [0, 1]ë¡œ ì €ì¥ë˜ì–´ ìˆë‹¤. ëì ë¶€í„° ì‹œì‘í•˜ê¸°ì— ë°©í–¥ 1ì´ ì‹œê³„ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „í•˜ë©´ ë°©í–¥ 2ê°€ ëœë‹¤. [0, 1, 2]ì´í›„ 0ì´ ì‹œê³„ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „í•˜ë©´ ë°©í–¥ 1ì´ëœë‹¤. [0, 1, 2, 1] ë“œë˜ê³¤ ì»¤ë¸Œ ìœ„ì˜ ê·œì¹™ëŒ€ë¡œ ê·¸ë¦¬ê¸° 0ì„¸ëŒ€ ê¹Œì§€ ê·¸ë ¤ë†“ê³  (0ì„¸ëŒ€ê°€ ì•„ë‹ˆë¼ë©´) 1ì„¸ëŒ€ë¶€í„° ê·¸ë¦°ë‹¤. direction ë°°ì—´ì— ìœ„ì˜ [0, 1, 2, 1]ê³¼ ê°™ì€ ê°’ì´ ë“¤ì–´ê°„ë‹¤.123456789101112131415161718int clockwise[4] = &#123; 1, 2, 3, 0 &#125;;void draw(int x, int y, int d, int g) &#123; int idx = 0; check[y][x] = true; direction[idx++] = d; while(g--) &#123; int len = idx; for (int i = len-1; i &gt;= 0; --i) &#123; d = clockwise[direction[i]]; x += dx[d]; y += dy[d]; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; MAX &amp;&amp; y &lt; MAX) &#123; check[y][x] = true; &#125; direction[idx++] = d; &#125; &#125;&#125; 4ê°œì˜ ê¼­ì§“ì  í™•ì¸ ë°°ì—´ì€ ìµœëŒ€ 100 x 100ì˜ í¬ê¸°ë¥¼ ê°€ì§€ê¸°ì— 0~99ê¹Œì§€ check ê°’ì´ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤. (ì‚¬ì‹¤ìƒ 98ê¹Œì§€ë§Œ í™•ì¸í•˜ë©´ ëœë‹¤.) 1 1 (0, 0)ì„ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¥¸ìª½, ì•„ë˜, ì˜¤ë¥¸ìª½ ì•„ë˜ ëŒ€ê°ì„ ë§Œ í™•ì¸í•˜ë©´ ëœë‹¤. 1 1 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#define MAX 101using namespace std;bool check[MAX][MAX];int clockwise[4] = &#123; 1, 2, 3, 0 &#125;;int dx[4] = &#123;1, 0, -1, 0&#125;;int dy[4] = &#123; 0, -1, 0, 1 &#125;;int direction[MAX*MAX];void draw(int x, int y, int d, int g) &#123; int idx = 0; check[y][x] = true; direction[idx++] = d; while(g--) &#123; int len = idx; for (int i = len-1; i &gt;= 0; --i) &#123; d = clockwise[direction[i]]; x += dx[d]; y += dy[d]; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; MAX &amp;&amp; y &lt; MAX) &#123; check[y][x] = true; &#125; direction[idx++] = d; &#125; &#125;&#125;int main() &#123; int n, x, y, d, g, answer = 0; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%d %d %d %d\", &amp;x, &amp;y, &amp;d, &amp;g); check[y][x] = true; x += dx[d]; y += dy[d]; draw(x, y, d, g); &#125; for (int i = 0; i &lt;= 99; ++i) &#123; for (int j = 0; j &lt;= 99; ++j) &#123; if (check[i][j]) &#123; if (check[i + 1][j] &amp;&amp; check[i][j + 1] &amp;&amp; check[i + 1][j + 1]) answer++; &#125; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 15684ë²ˆ ì‚¬ë‹¤ë¦¬ ì¡°ì‘","slug":"Algorithm/BOJ/15684","date":"2020-01-25T08:03:38.000Z","updated":"2020-01-25T13:10:46.907Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/15684/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/15684/","excerpt":"","text":"#15684. ì‚¬ë‹¤ë¦¬ ì¡°ì‘Problem ë¬¸ì œë§í¬ Solution ì²˜ìŒì— ê°ì´ ì•ˆì¡í˜€ì„œ ì–´ë–»ê²Œ í’€ì§€ ë§‰ë§‰í–ˆì—ˆë‹¤. ì…ë ¥ê°’ì„ ë³´ê³  ì‚¬ë‹¤ë¦¬ ì •ë³´ë¥¼ ì–´ë–¤ ì‹ìœ¼ë¡œ ì €ì¥í• ê±´ì§€ê°€ ì²« ìŠ¤íƒ€íŠ¸ì´ì í¬ì¸íŠ¸ë‹¤.ì´ë ‡ê²Œ dataê°€ ë³´ì—¬ì•¼ ì¡°í•©ë„ ì–´ë–¤ì‹ìœ¼ë¡œ êµ¬ì„±í• ì§€ ìƒê°ë‚˜ê¸° ë•Œë¬¸ì´ë‹¤. ì‘ì—…ì€ 2ê°œë¡œ ë‚˜ë‰œë‹¤. ì¡°í•© êµ¬í•˜ê¸° ì‚¬ë‹¤ë¦¬ íƒ€ê¸° ì¡°í•© êµ¬í•˜ê¸° ì¡°í•©ì„ êµ¬í•˜ê¸° ì „ì— ì…ë ¥ê°’ì´ ì–´ë–»ê²Œ ë“¤ì–´ì˜¤ë‚˜ í™•ì¸í•´ë³´ì. a bê°€ ì…ë ¥ë˜ë©´ aí–‰ì— bì—´ ì‚¬ë‹¤ë¦¬ì™€ b+1ì—´ ì‚¬ë‹¤ë¦¬ê°€ ì—°ê²°ëœë‹¤.ì´ë¥¼ array[a][b] = 1(ì‚¬ë‹¤ë¦¬ ìˆìŒ)ìœ¼ë¡œ í‘œì‹œí•˜ë©´ b+1ë¡œ ê°ˆ ìˆ˜ ìˆë‹¤ëŠ” ëœ»ì´ë‹¤.ë°˜ëŒ€ë¡œ b+1ì§€ì ì—ì„œ array[a][b]ê°’ì´ 1ì¸ê±¸ í™•ì¸í•˜ë©´ bë¡œ ê°ˆ ìˆ˜ ìˆë‹¤ëŠ” ëœ»ì´ë‹¤. ì´ë¥¼ í™œìš©í•˜ì—¬ ì¡°í•©ì„ êµ¬í•´ë³´ì. ëª¨ë“  í–‰ì˜ 1ì—´ë¶€í„° N-1ì—´ê¹Œì§€ íƒìƒ‰í•´ì•¼ í•œë‹¤.ë‹¨, í˜„ì¬ ìœ„ì¹˜ë¿ë§Œ ì•„ë‹ˆë¼ ìì‹ ì˜ ì™¼ìª½, ì˜¤ë¥¸ìª½ë„ í™•ì¸í•´ì•¼ í•œë‹¤. (ì—°ì†ìœ¼ë¡œ ì„¤ì¹˜í•˜ì§€ ëª»í•˜ê¸° ë•Œë¬¸)123456789101112131415161í–‰ 1ì—´ ì„ íƒ ì‹œ ë‹¤ìŒ ê°€ëŠ¥í•œ ê²½ìš° (Nì— í‘œì‹œí•˜ëŠ” ê²ƒì€ ì˜ë¯¸ X - ì…ë ¥ê°’ ìƒê°) 1í–‰ - 1(x), 2(x), 3 ... N-1 2í–‰ - 1, 2, 3 ... N-1 ... Hí–‰ - 1, 2, 3 ... N-1for (int i = idx; i &lt;= H; ++i) &#123; for (int j = 1; j &lt; N; ++j) &#123; if (visit[i][j]) continue; // í˜„ì¬ í™•ì¸ if (j &gt; 1 &amp;&amp; visit[i][j - 1]) continue; // ì™¼ìª½ í™•ì¸ if (visit[i][j + 1]) continue; // ì˜¤ë¥¸ìª½ í™•ì¸ visit[i][j] = true; // ì„ íƒ í‘œì‹œ selectAll(i, cnt + 1); // ë‹¤ìŒ ì„ íƒ visit[i][j] = false; &#125;&#125; 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;using namespace std;int N, M, H, ans;bool visit[31][11];void Input() &#123; ans = 4; cin &gt;&gt; N &gt;&gt; M &gt;&gt; H; for (int i = 0; i &lt; M; ++i) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; visit[a][b] = true; // aí–‰ b - b+1 ì‚¬ë‹¤ë¦¬ &#125;&#125;bool Check() &#123; for (int j = 1; j &lt;= N; ++j) &#123; int current_num = j; for (int i = 1; i &lt;= H; ++i) &#123; if (visit[i][current_num]) &#123; // ì˜¤ë¥¸ìª½ ì‚¬ë‹¤ë¦¬ë¡œ ì´ë™ current_num++; &#125; else if (current_num &gt; 1 &amp;&amp; visit[i][current_num -1]) &#123; // ì™¼ìª½ ì‚¬ë‹¤ë¦¬ë¡œ ì´ë™ current_num--; &#125; &#125; if (current_num != j) return false; &#125; return true;&#125;void selectAll(int idx, int cnt) &#123; if (cnt &gt; ans) return; if (cnt == 4) &#123; return; &#125; if (Check()) &#123; if (ans &gt; cnt) ans = cnt; return; &#125; for (int i = idx; i &lt;= H; ++i) &#123; for (int j = 1; j &lt; N; ++j) &#123; // 5ë²ˆ ì‚¬ë‹¤ë¦¬ëŠ” í™•ì¸í•  í•„ìš” ì—†ë‹¤. (ì…ë ¥ê°’ ìƒê°) if (visit[i][j]) continue; if (j &gt; 1 &amp;&amp; visit[i][j - 1]) continue; if (visit[i][j + 1]) continue; visit[i][j] = true; selectAll(i, cnt + 1); visit[i][j] = false; &#125; &#125;&#125;void Solve() &#123; Input(); selectAll(1, 0); if (ans == 4) ans = -1; cout &lt;&lt; ans &lt;&lt; \"\\n\";&#125;int main() &#123; Solve(); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 15683ë²ˆ ê°ì‹œ","slug":"Algorithm/BOJ/15683","date":"2020-01-25T08:03:35.000Z","updated":"2020-01-25T13:10:46.898Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/15683/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/15683/","excerpt":"","text":"#15683. ê°ì‹œProblem ë¬¸ì œë§í¬ Solution ì„¤ì¹˜ëœ CCTV ìœ„ì¹˜ì •ë³´, ë²ˆí˜¸ ì–»ê¸° ì„¤ì¹˜ëœ CCTV ë°©í–¥ ì •í•˜ê¸° (ìƒí•˜ì¢Œìš°: 0123)1ë²ˆ cctv: 0, 1, 2, 32ë²ˆ cctv: (0, 1), (2, 3)3ë²ˆ cctv: (0, 3), (1, 3), (0, 2), (1, 2)4ë²ˆ cctv: (2, 0, 3), (0, 3, 1), (2, 1, 3), (0, 2, 1)5ë²ˆ cctv: (0, 1, 2, 3)ë¬¶ìŒì„ ì™¼ìª½ì—ì„œë¶€í„° 0, 1, 2, 3ì´ë¼ê³  ì •í•˜ê³  (ì—¬ê¸°ì„œ 5ë²ˆì€ 0ë§Œ ê°–ê²Œëœë‹¤.)selected ë°°ì—´ì— ë„£ì–´ì¤€ë‹¤.123456789101112131415161718void selectDirection(int idx, int cnt) &#123; if (cnt == cctv.size()) &#123; task(); // ë°©í–¥ëŒ€ë¡œ ê°ì‹œ ì‹œì‘ return; &#125; int type = cctv[idx].type; for (int i = 0; i &lt; 4; ++i) &#123; if (type == 2) &#123; // 2ë²ˆ cctvëŠ” ìµœëŒ€ 1 ê°’ë§Œ ê°€ëŠ¥ if (i == 2) break; &#125; if(type == 5) &#123; // 5ë²ˆ cctvëŠ” ìµœëŒ€ 0ë§Œ ê°€ëŠ¥ if (i == 1) break; &#125; selected[idx] = i; selectDirection(idx + 1, cnt + 1); selected[idx] = -1; &#125;&#125; ì„ íƒëœ ë°©í–¥ëŒ€ë¡œ ê°ì‹œ ì‹œì‘ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ê±°ë‚˜ ë²½ì„ ë§Œë‚˜ë©´ ê°ì‹œë¥¼ ì¤‘ë‹¨í•œë‹¤. ê·¸ì „ê¹Œì§€ëŠ” ì •í•´ì§„ ë°©í–¥ëŒ€ë¡œ ê³„ì† check í‘œì‹œë¥¼ í•œë‹¤. checkëŠ” checkë˜ì–´ ìˆì§€ ì•Šê³  ë§µì˜ ê°’ì´ 0ì¸ ê²½ìš°ì—ë§Œ ì§„í–‰í•œë‹¤.íƒìƒ‰ëœ ê³³ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ê¸° ìœ„í•´ì„œì´ë‹¤. ì „ì²´ ì¹¸ì˜ ê°œìˆ˜ - íƒìƒ‰ëœ ê³³ì˜ ê°œìˆ˜ - ë²½ì˜ ê°œìˆ˜ - cctv ê°œìˆ˜ = ì‚¬ê°ì§€ëŒ€ ê°œìˆ˜ ì‚¬ê°ì§€ëŒ€ê°€ ìµœì†Œê°€ ë˜ë„ë¡ ê°±ì‹ í•œë‹¤. 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, m, wall_cnt, ans;int room[9][9];int selected[9];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;int type_two[2][2] = &#123;&#123;0, 1&#125;, &#123;2, 3&#125;&#125;;int type_three[4][2] = &#123; &#123;0, 3&#125;, &#123;1, 3&#125;, &#123;0, 2&#125;, &#123;1, 2&#125; &#125;;int type_four[4][3] = &#123; &#123;2, 0, 3&#125;, &#123;0, 3, 1&#125;, &#123;2, 1, 3&#125;, &#123;0, 2, 1&#125; &#125;;struct INFO &#123; int x, y, type;&#125;;vector&lt;INFO&gt; cctv;void init() &#123; for (int i = 0; i &lt; 9; ++i) selected[i] = -1; ans = 1e9; wall_cnt = 0;&#125;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; n &amp;&amp; y &lt; m) return true; return false;&#125;void task() &#123; bool check[9][9] = &#123; 0, &#125;; int type, res = 0; for (int i = 0; i &lt; cctv.size(); ++i) &#123; int dir = selected[i]; int x = cctv[i].x, y = cctv[i].y; int d_x, d_y; if (cctv[i].type == 1) &#123; d_x = x + dx[dir]; d_y = y + dy[dir]; while (isBound(d_x, d_y) &amp;&amp; room[d_x][d_y] != 6) &#123; if (!check[d_x][d_y] &amp;&amp; room[d_x][d_y] == 0) &#123; check[d_x][d_y] = true; res++; &#125; d_x += dx[dir]; d_y += dy[dir]; &#125; &#125; else if (cctv[i].type == 2) &#123; for (int j = 0; j &lt; 2; ++j) &#123; d_x = x + dx[type_two[dir][j]]; d_y = y + dy[type_two[dir][j]]; while (isBound(d_x, d_y) &amp;&amp; room[d_x][d_y] != 6) &#123; if (!check[d_x][d_y] &amp;&amp; room[d_x][d_y] == 0) &#123; check[d_x][d_y] = true; res++; &#125; d_x += dx[type_two[dir][j]]; d_y += dy[type_two[dir][j]]; &#125; &#125; &#125; else if (cctv[i].type == 3) &#123; for (int j = 0; j &lt; 2; ++j) &#123; d_x = x + dx[type_three[dir][j]]; d_y = y + dy[type_three[dir][j]]; while (isBound(d_x, d_y) &amp;&amp; room[d_x][d_y] != 6) &#123; if (!check[d_x][d_y] &amp;&amp; room[d_x][d_y] == 0) &#123; check[d_x][d_y] = true; res++; &#125; d_x += dx[type_three[dir][j]]; d_y += dy[type_three[dir][j]]; &#125; &#125; &#125; else if (cctv[i].type == 4) &#123; for (int j = 0; j &lt; 3; ++j) &#123; d_x = x + dx[type_four[dir][j]]; d_y = y + dy[type_four[dir][j]]; while (isBound(d_x, d_y) &amp;&amp; room[d_x][d_y] != 6) &#123; if (!check[d_x][d_y] &amp;&amp; room[d_x][d_y] == 0) &#123; check[d_x][d_y] = true; res++; &#125; d_x += dx[type_four[dir][j]]; d_y += dy[type_four[dir][j]]; &#125; &#125; &#125; else if (cctv[i].type == 5) &#123; for (int j = 0; j &lt; 4; ++j) &#123; d_x = x + dx[j]; d_y = y + dy[j]; while (isBound(d_x, d_y) &amp;&amp; room[d_x][d_y] != 6) &#123; if (!check[d_x][d_y] &amp;&amp; room[d_x][d_y] == 0) &#123; check[d_x][d_y] = true; res++; &#125; d_x += dx[j]; d_y += dy[j]; &#125; &#125; &#125; &#125; res = (n * m) - res - wall_cnt - cctv.size(); if (res &lt; ans) ans = res;&#125;void selectDirection(int idx, int cnt) &#123; if (cnt == cctv.size()) &#123; task(); return; &#125; int type = cctv[idx].type; for (int i = 0; i &lt; 4; ++i) &#123; if (type == 2) &#123; if (i == 2) break; &#125; if(type == 5) &#123; if (i == 1) break; &#125; selected[idx] = i; selectDirection(idx + 1, cnt + 1); selected[idx] = -1; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; init(); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; room[i][j]; if (room[i][j] &gt;= 1 &amp;&amp; room[i][j] &lt;= 5) &#123; cctv.push_back(&#123; i, j, room[i][j] &#125;); &#125; else if (room[i][j] == 6) wall_cnt++; &#125; &#125; selectDirection(0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 14891ë²ˆ í†±ë‹ˆë°”í€´","slug":"Algorithm/BOJ/14891","date":"2020-01-25T08:03:29.000Z","updated":"2020-01-25T13:10:46.906Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14891/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14891/","excerpt":"","text":"#14891. í†±ë‹ˆë°”í€´Problem ë¬¸ì œë§í¬ Solution SWEA ëª¨ì˜ SW ì—­ëŸ‰ í…ŒìŠ¤íŠ¸ [íŠ¹ì´í•œ ìì„](https://www.notion.so/doyuni/4013-e51a7fc5e88b4e2b999dba66b24f358b#ffc1b4f8b7b140a2a1f2e12a9f953f5b) ì™€ ë™ì¼í•˜ë‹¤. 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;int magnatic[4][8];map&lt;int, int&gt; task;void rotate(int n, int dir) &#123; if (dir == 1) &#123; // ì‹œê³„ ë°©í–¥ int first_ele = magnatic[n][7]; for (int i = 6; i &gt;= 0; --i) &#123; magnatic[n][i + 1] = magnatic[n][i]; &#125; magnatic[n][0] = first_ele; &#125; else if (dir == -1) &#123; // ë°˜ì‹œê³„ ë°©í–¥ int last_ele = magnatic[n][0]; for (int i = 1; i &lt; 8; ++i) &#123; magnatic[n][i - 1] = magnatic[n][i]; &#125; magnatic[n][7] = last_ele; &#125;&#125;void checkRotate(int current_num, int prior_num, int dir) &#123; int count_dir = dir &gt; 0 ? -1 : 1; task.insert(&#123; current_num, dir &#125;); if (current_num == 0) &#123; if (prior_num != 1) &#123; if (magnatic[current_num][2] != magnatic[current_num + 1][6]) &#123; checkRotate(current_num + 1, current_num, count_dir); &#125; &#125; &#125; else if (current_num == 1) &#123; if (prior_num != 0) &#123; if (magnatic[current_num - 1][2] != magnatic[current_num][6]) &#123; checkRotate(current_num - 1, current_num, count_dir); &#125; &#125; if (prior_num != 2) &#123; if (magnatic[current_num][2] != magnatic[current_num + 1][6]) &#123; checkRotate(current_num + 1, current_num, count_dir); &#125; &#125; &#125; else if (current_num == 2) &#123; if (prior_num != 1) &#123; if (magnatic[current_num - 1][2] != magnatic[current_num][6]) &#123; checkRotate(current_num - 1, current_num, count_dir); &#125; &#125; if (prior_num != 3) &#123; if (magnatic[current_num][2] != magnatic[current_num + 1][6]) &#123; checkRotate(current_num + 1, current_num, count_dir); &#125; &#125; &#125; else if (current_num == 3) &#123; if (prior_num != 2) &#123; if (magnatic[current_num - 1][2] != magnatic[current_num][6]) &#123; checkRotate(current_num - 1, current_num, count_dir); &#125; &#125; &#125;&#125;int getScore() &#123; int ans = 0, score = 1; for (int n = 0; n &lt; 4; ++n) &#123; if (magnatic[n][0] == 1) &#123; ans += score; &#125; score *= 2; &#125; return ans;&#125;int main() &#123; for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 8; ++j) &#123; scanf(\"%1d\", &amp;magnatic[i][j]); &#125; &#125; int k; scanf(\"%d\", &amp;k); for (int i = 0; i &lt; k; ++i) &#123; int number, dir; scanf(\"%d %d\", &amp;number, &amp;dir); checkRotate(number - 1, -1, dir); for (auto e : task) &#123; rotate(e.first, e.second); &#125; task.clear(); &#125; printf(\"%d\\n\", getScore()); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 14890ë²ˆ ê²½ì‚¬ë¡œ","slug":"Algorithm/BOJ/14890","date":"2020-01-25T08:03:20.000Z","updated":"2020-01-25T13:10:46.916Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14890/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14890/","excerpt":"","text":"#14890. ê²½ì‚¬ë¡œë¬¸ì œë§í¬ Problem N x N ì§€ë„, ê° ì¹¸ì˜ ë†’ì´ê°€ ì í˜ ê¸¸ì€ í•œ í–‰ ë˜ëŠ” í•œ ì—´ â†’ ê¸¸ì— ì†í•œ ëª¨ë“  ì¹¸ì˜ ë†’ì´ê°€ ëª¨ë‘ ê°™ì•„ì•¼ ì§€ë‚˜ê°ˆ ìˆ˜ ìˆìŒ ë˜ëŠ” ê²½ì‚¬ë¡œë¥¼ ë†“ì•„ì„œ ì§€ë‚˜ê°ˆ ìˆ˜ ìˆëŠ” ê¸¸ì„ ë§Œë“¤ ìˆ˜ ìˆìŒ( ê²½ì‚¬ë¡œ ë†’ì´ 1, ê¸¸ì´ L), ê²½ì‚¬ë¡œ ê°œìˆ˜ëŠ” ë§¤ìš° ë§ìŒ ê²½ì‚¬ë¡œ ë†“ì„ ìˆ˜ ìˆëŠ” ê²½ìš° ë‚®ì€ ì¹¸ê³¼ ë†’ì€ ì¹¸ì˜ ì°¨ì´ê°€ 1ì¸ ê²½ìš° Lê°œì˜ ì¹¸ì´ ê°™ì€ ë†’ì´ë¡œ ì—°ì†ë˜ê²Œ ìˆì–´ì•¼ í•œë‹¤. Solutioní•œ í–‰ ë§¨ ì™¼ìª½ì—ì„œë¶€í„° ì˜¤ë¥¸ìª½ìœ¼ë¡œ íƒìƒ‰í•œë‹¤. (ì²« ë²ˆì§¸ ì›ì†Œë¶€í„° ë§ˆì§€ë§‰ ì›ì†Œ ë°”ë¡œ ì´ì „ê¹Œì§€) í˜„ì¬ íƒìƒ‰í•œ ì›ì†Œì™€ ë°”ë¡œ ë‹¤ìŒ ì›ì†Œì™€ì˜ ì°¨ì´ë¥¼ êµ¬í•œë‹¤. +1ì¸ ê²½ìš°ë‹¤ìŒ ì›ì†Œë¶€í„° ê²½ì‚¬ë¡œ ê¸¸ì´ë§Œí¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ íƒìƒ‰ì„ ì‹œì‘í•œë‹¤.íƒìƒ‰í•˜ë©´ì„œ ë‹¤ìŒ ê²½ìš°ë¥¼ í™•ì¸í•œë‹¤.ë²”ìœ„ë¥¼ ë²—ì–´ë‚  ê²½ìš°(nì´ìƒ) or ê²½ì‚¬ë¡œ ê¸¸ì´ë§Œí¼ ê°™ì€ ë†’ì´ê°€ ì•„ë‹ ë•Œ ì¢…ë£Œê·¸ê²Œ ì•„ë‹ˆë©´ ê²½ì‚¬ë¡œë¥¼ ë†“ëŠ”ë‹¤. -1ì¸ ê²½ìš°í˜„ì¬ ì›ì†Œë¶€í„° ê²½ì‚¬ë¡œ ê¸¸ì´ë§Œí¼ ì™¼ìª½ìœ¼ë¡œ íƒìƒ‰ì„ ì‹œì‘í•œë‹¤.íƒìƒ‰í•˜ë©´ì„œ ë‹¤ìŒ ê²½ìš°ë¥¼ í™•ì¸í•œë‹¤.ë²”ìœ„ë¥¼ ë²—ì–´ë‚  ê²½ìš°(0ë¯¸ë§Œ) or ê²½ì‚¬ë¡œ ê¸¸ì´ë§Œí¼ ê°™ì€ ë†’ì´ê°€ ì•„ë‹ ë•Œ or ê²½ì‚¬ë¡œê°€ ë†“ì—¬ìˆì„ ë•Œ ì¢…ë£Œê·¸ê²Œ ì•„ë‹ˆë©´ ê²½ì‚¬ë¡œë¥¼ ë†“ëŠ”ë‹¤. ì°¨ì´ê°€ 1 ì´ˆê³¼ -1 ë¯¸ë§Œì¸ ê²½ìš° ì¢…ë£Œ ê·¸ê²Œ ì•„ë‹ˆë¼ë©´ ì„±ê³µ ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ íƒìƒ‰í•˜ê¸°ì— í•œ ì—´ ë˜í•œ ìœ„ì™€ ë§ˆì°¬ê°€ì§€ë¡œ êµ¬í˜„í•œë‹¤. 1 Try í•˜â€¦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, len, ans;int map[101][101];bool check[101][101];bool checkRow(int row) &#123; for (int j = 0; j &lt; n - 1; ++j) &#123; if (map[row][j] - map[row][j + 1] == 1) &#123; for (int start = j + 1; start &lt;= j + len; ++start) &#123; if (start &gt;= n) return false; // ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš° if (map[row][j + 1] != map[row][start]) return false; // ì¹¸ì˜ ë†’ì´ê°€ ê°™ì§€ ì•Šì„ ë•Œ check[row][start] = true; // ê²½ì‚¬ë¡œ ë†“ê¸° &#125; &#125; else if (map[row][j] - map[row][j + 1] == -1) &#123; for (int start = j; start &gt; j - len; --start) &#123; if (start &lt; 0) return false; // ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš° if (map[row][j] != map[row][start]) return false; if (check[row][start]) return false; check[row][start] = true; &#125; &#125; else if (map[row][j] - map[row][j + 1] &gt; 1 || map[row][j] - map[row][j + 1] &lt; -1) return false; &#125; return true;&#125;bool checkCol(int col) &#123; for (int i = 0; i &lt; n - 1; ++i) &#123; if (map[i][col] - map[i + 1][col] == 1) &#123; for (int start = i + 1; start &lt;= i + len; ++start) &#123; if (start &gt;= n) return false; if (map[i + 1][col] != map[start][col]) return false; check[start][col] = true; &#125; &#125; else if (map[i][col] - map[i + 1][col] == -1) &#123; for (int start = i; start &gt; i - len; --start) &#123; if (start &lt; 0) return false; if (map[i][col] != map[start][col]) return false; if (check[start][col]) return false; check[start][col] = true; &#125; &#125; else if (map[i][col] - map[i + 1][col] &gt; 1 || map[i][col] - map[i + 1][col] &lt; -1) return false; &#125;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;len); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); &#125; &#125; for (int row = 0; row &lt; n; ++row) &#123; if(checkRow(row)) ans++; &#125; memset(check, 0, sizeof(check)); for (int col = 0; col &lt; n; ++col) &#123; if (checkCol(col)) ans++; &#125; printf(\"%d\\n\", ans); return 0;&#125; checkCol í•¨ìˆ˜ì— return true ì¦‰ ë°˜í™˜ê°’ì„ ë„£ì–´ì£¼ì§€ ì•Šì•˜ê¸°ì— í‹€ë ¸ë‹¤ê³  ë‚˜ì™”ë‹¤. bool í•¨ìˆ˜ëŠ” ë°˜ë“œì‹œ trueì™€ false ë‘˜ ë‹¤ ë°˜í™˜í•´ì£¼ì. ì´ê±¸ ëª°ë¼ì„œ ê³„ì† ë¬¸ì œë§Œ ì£¼êµ¬ì¥ì°½ ë´¤ìŒâ€¦ã…  2 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, len, ans;int map[101][101];bool check[101][101];bool checkRow(int row) &#123; for (int j = 0; j &lt; n - 1; ++j) &#123; if (map[row][j] - map[row][j + 1] == 1) &#123; for (int start = j + 1; start &lt;= j + len; ++start) &#123; if (start &gt;= n) return false; // ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš° if (map[row][j + 1] != map[row][start]) return false; // ì¹¸ì˜ ë†’ì´ê°€ ê°™ì§€ ì•Šì„ ë•Œ check[row][start] = true; // ê²½ì‚¬ë¡œ ë†“ê¸° &#125; &#125; else if (map[row][j] - map[row][j + 1] == -1) &#123; for (int start = j; start &gt; j - len; --start) &#123; if (start &lt; 0) return false; if (map[row][j] != map[row][start]) return false; if (check[row][start]) return false; // ê²½ì‚¬ë¡œê°€ ì´ë¯¸ ë†“ì—¬ì§„ ê²½ìš° check[row][start] = true; &#125; &#125; else if (map[row][j] - map[row][j + 1] &gt; 1 || map[row][j] - map[row][j + 1] &lt; -1) return false; &#125; return true;&#125;bool checkCol(int col) &#123; for (int i = 0; i &lt; n - 1; ++i) &#123; if (map[i][col] - map[i + 1][col] == 1) &#123; for (int start = i + 1; start &lt;= i + len; ++start) &#123; if (start &gt;= n) return false; if (map[i + 1][col] != map[start][col]) return false; check[start][col] = true; &#125; &#125; else if (map[i][col] - map[i + 1][col] == -1) &#123; for (int start = i; start &gt; i - len; --start) &#123; if (start &lt; 0) return false; if (map[i][col] != map[start][col]) return false; if (check[start][col]) return false; check[start][col] = true; &#125; &#125; else if (map[i][col] - map[i + 1][col] &gt; 1 || map[i][col] - map[i + 1][col] &lt; -1) return false; &#125; return true;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;len); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;map[i][j]); &#125; &#125; for (int row = 0; row &lt; n; ++row) &#123; if (checkRow(row)) ans++; &#125; memset(check, 0, sizeof(check)); for (int col = 0; col &lt; n; ++col) &#123; if (checkCol(col)) ans++; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 14889ë²ˆ ìŠ¤íƒ€íŠ¸ì™€ ë§í¬","slug":"Algorithm/BOJ/14889","date":"2020-01-25T08:03:12.000Z","updated":"2020-01-25T13:10:46.915Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14889/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14889/","excerpt":"","text":"#14889. ìŠ¤íƒ€íŠ¸ì™€ ë§í¬ë¬¸ì œë§í¬ Problem ì´ Nëª… ì¤‘ N/2ëª…ìœ¼ë¡œ ë‘ íŒ€ì„ ë§Œë“ ë‹¤. (Nì€ ì§ìˆ˜) Sij + Sji = ëŠ¥ë ¥ì¹˜ ( ië²ˆê³¼ jë²ˆ ì‚¬ëŒì´ ê°™ì€ íŒ€ì— ì†í–ˆì„ ë•Œ) Goal: ë‘ íŒ€ì˜ ëŠ¥ë ¥ì¹˜ì˜ ì°¨ì´ì˜ ìµœì†Ÿê°’ Solution ë¨¼ì € ë‘ íŒ€ì„ ë‚˜ëˆ ì•¼ í•œë‹¤.1~N ì¤‘ì— N/2ë¥¼ ê³¨ë¼ ë§Œë“¤ì–´ì•¼ í•˜ëŠ”ë° ì¤‘ë³µX + ì˜¤ë¦„ì°¨ìˆœì´ì–´ì•¼ í•œë‹¤.12345678910111213void selectTeam(int idx, int cnt) &#123; if (cnt == n / 2) &#123; // ì„±ê³µ ì¡°ê±´ // ëŠ¥ë ¥ì¹˜ ê³„ì‚° &#125; if (idx &gt; n) return; // ì‹¤íŒ¨ ì¡°ê±´ for (int i = idx; i &lt;= n; ++i) &#123; if (selected[i] == 0) &#123; selected[i] = i; selectTeam(i+1, cnt + 1); selected[i] = 0; &#125; &#125;&#125; 1~20ê°œì˜ ë²ˆí˜¸ë¥¼ ë‹´ì„ ìˆ˜ ìˆëŠ” selected ë°°ì—´ì„ ë§Œë“ ë‹¤. ì„ íƒ ë˜ë©´ ì„ íƒëœ ë²ˆí˜¸ì˜ ê°’ì„ ê°–ëŠ”ë‹¤. ì„ íƒë˜ì§€ ì•Šìœ¼ë©´ 0ê°’ì„ ê°–ëŠ”ë‹¤. ì¤‘ë³µ ì•ˆë˜ê³ , ì˜¤ë¦„ì°¨ ìˆœì´ê¸°ì— forë¬¸ì˜ ì‹œì‘ ì¡°ê±´ì„ ìœ„ì™€ ê°™ì´ í•œë‹¤. N/2 ë§Œí¼ ì„ íƒí•˜ë©´ ëŠ¥ë ¥ì¹˜ë¥¼ ê³„ì‚°í•œë‹¤. ëŠ¥ë ¥ì¹˜ ê³„ì‚° ë§í¬íŒ€: 0, 3, 5-&gt; ëŠ¥ë ¥ì¹˜(0, 3) (0, 5)(3, 0) (3, 5)(5, 0) (5, 3) ê·¸ë ‡ê¸°ì— ì„ íƒëœ ìˆ«ìë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‚˜ë¨¸ì§€ ì„ íƒëœ ìˆ«ì í•˜ë‚˜ë§Œ ê³ ë¥´ë©´ ëœë‹¤.123456iëŠ” ì•ì— ì„ íƒëœ ìˆ«ì (i, j)for (int j = 1; j &lt;= n; ++j) &#123; if (selected[j] == 0 &amp;&amp; i != j) &#123; team_start += ability[i-1][j-1]; &#125;&#125; 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int n, ans;int ability[21][21];int selected[21];void getDifference() &#123; int team_start = 0; int team_link = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (selected[i] == 0) &#123; // ì„ íƒë˜ì§€ ì•Šì€ ë„˜ë²„ê°€ ë‹¤ë¥¸ íŒ€ for (int j = 1; j &lt;= n; ++j) &#123; if (selected[j] == 0 &amp;&amp; i != j) &#123; team_start += ability[i-1][j-1]; &#125; &#125; &#125; else &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (selected[j] != 0 &amp;&amp; i != j) &#123; team_link += ability[i - 1][j - 1]; &#125; &#125; &#125; &#125; unsigned int diff = abs(team_start - team_link); if (ans &gt; diff) ans = diff;&#125;void selectTeam(int idx, int cnt) &#123; if (cnt == n / 2) &#123; getDifference(); &#125; if (idx &gt; n) return; for (int i = idx; i &lt;= n; ++i) &#123; if (selected[i] == 0) &#123; selected[i] = i; selectTeam(i+1, cnt + 1); selected[i] = 0; &#125; &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;ability[i][j]); &#125; &#125; ans = 1e9; selectTeam(1, 0); printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 14503ë²ˆ ë¡œë´‡ ì²­ì†Œê¸°","slug":"Algorithm/BOJ/14503","date":"2020-01-25T08:03:07.000Z","updated":"2020-01-25T13:10:46.913Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14503/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14503/","excerpt":"","text":"#14503. ë¡œë´‡ ì²­ì†Œê¸°ë¬¸ì œë§í¬ Problem N x M í¬ê¸°, ë²½ ë˜ëŠ” ë¹ˆì¹¸, ëª¨ë“  ì™¸ê³½ì€ ë²½ ì²­ì†Œê¸°ëŠ” ë°”ë¼ë³´ëŠ” ë°©í–¥ì´ ìˆìŒ(ìƒí•˜ì¢Œìš°) ì‘ë™ í˜„ì¬ ìœ„ì¹˜ ì²­ì†Œ í˜„ì¬ ë°©í–¥ì„ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ë¶€í„° íƒìƒ‰ì™¼ìª½ì— ì²­ì†Œí•˜ì§€ ì•Šì€ ê³µê°„ì´ ìˆìœ¼ë©´ ê·¸ ë°©í–¥ìœ¼ë¡œ íšŒì „, 1ì¹¸ ì „ì§„, 1ë²ˆ ì§„í–‰ì—†ë‹¤ë©´, ê·¸ ë°©í–¥ìœ¼ë¡œ íšŒì „ 2ë²ˆ ì§„í–‰ìƒí•˜ì¢Œìš° ëª¨ë‘ ì²­ì†Œ ë˜ì–´ ìˆê±°ë‚˜ ë²½ì´ë¼ë©´, ë°©í–¥ ìœ ì§€í•œ ì±„ í•œ ì¹¸ í›„ì§„ í›„ 2ë²ˆ ì§„í–‰ ( í˜„ì¬ ìœ„ì¹˜ì—ì„œ 4ë°©í–¥ ë‹¤ ì²­ì†Œë‚˜ ë²½ì¼ ë•Œ í˜„ì¬ ë°©í–¥ ìœ ì§€í•œ ì±„ í›„ì§„)ë°”ë¡œ ìœ„ì˜ ê²½ìš°ì—ì„œ ë’¤ìª½ì´ ë²½ì´ë¼ í›„ì§„ë„ ëª» í•˜ëŠ” ê²½ìš° ì‘ë™ ì¢…ë£Œ Goal: ë¡œë´‡ ì²­ì†Œê¸°ê°€ ì²­ì†Œí•˜ëŠ” ì¹¸ì˜ ê°œìˆ˜ ì¶œë ¥ ë°©í–¥: 0 â†’ ìœ„, 1 â†’ ìš°, 2 â†’ ì•„ë˜, 3 â†’ ì™¼ Solutionì‹œë®¬ë ˆì´ì…˜ ë¬¸ì œì´ë‹¤. ê° ìˆœì„œì— ë§ê²Œ ì˜ êµ¬í˜„í•˜ë©´ ëœë‹¤. í˜„ì¬ íƒìƒ‰ ì§€ì ì˜ ê°’ì´ 0ì´ë¼ë©´ ì²­ì†Œí•˜ëŠ” ì¹¸ì˜ ê°œìˆ˜ 1 ì¦ê°€ í›„ 2ë¡œ í‘œì‹œ ìµœëŒ€ 5ë²ˆ ë°©í–¥ì„ ë°”ê¾¸ê²Œ ëœë‹¤. (ìì‹ ìœ¼ë¡œ ëŒì•„ì˜¤ëŠ” ê²ƒê¹Œì§€ í¬í•¨) 0(ìœ„ìª½) â†’ 3(ì™¼ìª½) 1(ì˜¤ë¥¸ìª½) â†’ 0(ìœ„ìª½) 2(ì•„ë˜ìª½) â†’ 1(ì˜¤ë¥¸ìª½) 3(ì™¼ìª½) â†’ 2(ì•„ë˜ìª½) ìœ„ëŠ” í˜„ì¬ ë°©í–¥ì— ë”°ë¥¸ ì™¼ìª½ ë°©í–¥(ë‹¤ìŒ íƒìƒ‰ ë°©í–¥)ì´ë‹¤. í˜„ì¬ ë°©í–¥ì„ í† ëŒ€ë¡œ ë‹¤ìŒ ë°©í–¥ì„ ê²°ì •í•˜ê³  ë‹¤ìŒ ë°©í–¥ì— ë§ëŠ” ì¢Œí‘œë¥¼ êµ¬í•œë‹¤. íƒìƒ‰ ê°€ëŠ¥í•˜ë©´(ê°’ì´ 0ì´ë©´) í˜„ì¬ ë°©í–¥ì„ ì´ ë°©í–¥ìœ¼ë¡œ ë°”ê¾¸ê³  ì¢Œí‘œë¥¼ ë°”ê¾¸ê³  ë°˜ë³µë¬¸ ì¢…ë£Œ íƒìƒ‰ ë¶ˆê°€ëŠ¥í•˜ë©´ í˜„ì¬ ë°©í–¥ë§Œ ì´ ë°©í–¥ìœ¼ë¡œ ë°”ê¾¼ë‹¤. ì²˜ìŒ ë°©í–¥ê³¼ ê°™ê²Œ ë‚˜ì˜¤ë©´(5ë²ˆì§¸ì¼ ê²½ìš°) í›„ì§„ì´ ê°€ëŠ¥í•œì§€ ì¡°ì‚¬í•œë‹¤.ê°€ëŠ¥í•˜ë©´ ì¢Œí‘œë§Œ ë°”ê¿”ì£¼ê³  ì•„ë‹ˆë©´ ì‹œë®¬ë ˆì´ì…˜ì„ ì¢…ë£Œí•œë‹¤.12345678910111213141516171819202122for (int i = 0; i &lt; 5; ++i) &#123; int next_dir = left_dir[current_dir]; if (i == 4) &#123; int back_x = x + dx[back_dir[dir]]; int back_y = y + dy[back_dir[dir]]; if (map[back_x][back_y] == 1) return; else &#123; x = back_x; y = back_y; break; &#125; &#125; int d_x = x + dx[next_dir]; int d_y = y + dy[next_dir]; if (map[d_x][d_y] == 0) &#123; dir = next_dir; x = d_x; y = d_y; break; &#125; else &#123; current_dir = next_dir; &#125;&#125; 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;int n, m, ans;int map[51][51];int left_dir[4] = &#123; 3, 0, 1, 2 &#125;;int back_dir[4] = &#123; 2, 3, 0, 1 &#125;;int dx[4] = &#123; -1, 0, 1, 0 &#125;;int dy[4] = &#123; 0, 1, 0, -1 &#125;;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; n &amp;&amp; y &lt; m) return true; return false;&#125;void cleanMap(int x, int y, int dir) &#123; while (true) &#123; if (map[x][y] == 0) ans++; map[x][y] = 2; int current_dir = dir; for (int i = 0; i &lt; 5; ++i) &#123; int next_dir = left_dir[current_dir]; if (i == 4) &#123; int back_x = x + dx[back_dir[dir]]; int back_y = y + dy[back_dir[dir]]; if (map[back_x][back_y] == 1) return; else &#123; x = back_x; y = back_y; break; &#125; &#125; int d_x = x + dx[next_dir]; int d_y = y + dy[next_dir]; if (map[d_x][d_y] == 0) &#123; dir = next_dir; x = d_x; y = d_y; break; &#125; else &#123; current_dir = next_dir; &#125; &#125; &#125;&#125;int main() &#123; int start_x, start_y, dir; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; start_x &gt;&gt; start_y &gt;&gt; dir; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; cleanMap(start_x, start_y, dir); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 14502ë²ˆ ì—°êµ¬ì†Œ","slug":"Algorithm/BOJ/14502","date":"2020-01-25T08:03:04.000Z","updated":"2020-01-25T13:10:46.910Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14502/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14502/","excerpt":"","text":"#14502. ì—°êµ¬ì†Œë¬¸ì œë§í¬ Problem N x M í¬ê¸°, ë¹ˆ ì¹¸(0), ë²½(1), ë°”ì´ëŸ¬ìŠ¤(2) ì¡´ì¬ ë°”ì´ëŸ¬ìŠ¤ëŠ” ìƒí•˜ì¢Œìš° ë¹ˆì¹¸ìœ¼ë¡œë§Œ ì›€ì§ì„ ë²½ì„ ê¼­ 3ê°œ ì„¸ì›Œì•¼ í•œë‹¤. Goal: ë²½ì„ 3ê°œ ì„¸ìš´ ë’¤, ì–»ì„ ìˆ˜ ìˆëŠ” ì•ˆì „ ì˜ì—­ í¬ê¸°ì˜ ìµœëŒ“ê°’ì•ˆì „ ì˜ì—­ì€ ë²½ 3ê°œ ì„¸ìš´ ë’¤ 0ì˜ ê°œìˆ˜ Solution ë²½ì„ 3ê°œ ì„¸ìš°ëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ ëª¨ë‘ êµ¬í•œë‹¤. (ë¸Œë£¨íŠ¸ í¬ìŠ¤ - ì¬ê·€) 1234567891011void buildWall(int idx, int cnt) &#123; if (cnt == 3) &#123; spreadVirus(); return; &#125; if (idx == zero_point.size()) return; buildWall(idx + 1, cnt); wall[cnt].x = zero_point[idx].first; wall[cnt].y = zero_point[idx].second; buildWall(idx + 1, cnt+1);&#125; 0ì¸ ì§€ì ì„ ì €ì¥í•´ë†“ì€ ë²¡í„°ì—ì„œ 3ê°œë¥¼ ì„ íƒí•˜ë„ë¡ í•œë‹¤. ì›ë˜ì˜ mapì€ ë³´ì¡´í•´ì•¼ í•˜ë¯€ë¡œ ìƒˆë¡œìš´ ë°°ì—´ì— ë³µì‚¬ë¥¼ í•´ë†“ê³  ìœ„ì—ì„œ êµ¬í•œ ê²½ìš°ì˜ ìˆ˜ì— ë§ê²Œ ë²½ì„ ì„¸ìš´ë‹¤.1234copyMap(); // ìƒˆë¡œìš´ ë°°ì—´(tmp)ì— ë³µì‚¬for (int i = 0; i &lt; 3; ++i) &#123; tmp[wall[i].x][wall[i].y] = 1;&#125; ë²½ì„ ì„¸ìš´ ìƒˆë¡œìš´ mapì—ì„œ ë°”ì´ëŸ¬ìŠ¤ê°€ í¼ì§€ë„ë¡ í•œë‹¤. (BFS) 123456789101112131415161718192021222324252627void spreadVirus() &#123; // 2ë²ˆì§¸ ì‘ì—… // ì•„ë˜ë¶€í„° 3ë²ˆì§¸ ì‘ì—… queue&lt;pair&lt;int, int&gt; &gt; q; for (int i = 0; i &lt; total_virus; ++i) &#123; q.push(&#123; virus[i].x, virus[i].y &#125;); &#125; int minus_safe_area = 3; while (!q.empty()) &#123; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (isBound(d_x, d_y) &amp;&amp; tmp[d_x][d_y] == 0) &#123; q.push(&#123; d_x, d_y &#125;); tmp[d_x][d_y] = 2; minus_safe_area++; &#125; &#125; &#125; &#125; if (ans &lt; safe_area - minus_safe_area) ans = safe_area - minus_safe_area;&#125; BFS íƒìƒ‰ì´ ëë‚˜ë©´ queueê°€ ë¹„ì›Œì§€ê²Œ ë˜ë¯€ë¡œ, ë‹¤ìŒ íƒìƒ‰ì„ ìœ„í•´ ë°”ì´ëŸ¬ìŠ¤ ìœ„ì¹˜ë¥¼ ì €ì¥í•´ë†“ì„ ë°°ì—´ì´ í•„ìš”í•˜ë‹¤ëŠ” ê²ƒì— ì£¼ì˜í•œë‹¤. ì•ˆì „ì˜ì—­ í¬ê¸° = ì›ë˜ mapì˜ 0ì˜ ê°œìˆ˜ - ë²½ 3ê°œ - ëª¨ë‘ í¼ì§„ ë°”ì´ëŸ¬ìŠ¤ ìˆ˜ 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int n, m, ans, safe_area, total_virus;int tmp[9][9];vector&lt;vector&lt;int&gt; &gt; map;vector&lt;pair&lt;int, int&gt; &gt; zero_point;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;struct INFO &#123; int x, y;&#125;wall[3], virus[10];bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; n &amp;&amp; y &lt; m) return true; return false;&#125;void copyMap() &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; tmp[i][j] = map[i][j]; &#125; &#125;&#125;void spreadVirus() &#123; copyMap(); for (int i = 0; i &lt; 3; ++i) &#123; tmp[wall[i].x][wall[i].y] = 1; &#125; queue&lt;pair&lt;int, int&gt; &gt; q; for (int i = 0; i &lt; total_virus; ++i) &#123; q.push(&#123; virus[i].x, virus[i].y &#125;); &#125; int minus_safe_area = 3; while (!q.empty()) &#123; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (isBound(d_x, d_y) &amp;&amp; tmp[d_x][d_y] == 0) &#123; q.push(&#123; d_x, d_y &#125;); tmp[d_x][d_y] = 2; minus_safe_area++; &#125; &#125; &#125; &#125; if (ans &lt; safe_area - minus_safe_area) ans = safe_area - minus_safe_area;&#125;void buildWall(int idx, int cnt) &#123; if (cnt == 3) &#123; spreadVirus(); return; &#125; if (idx == zero_point.size()) return; buildWall(idx + 1, cnt); wall[cnt].x = zero_point[idx].first; wall[cnt].y = zero_point[idx].second; buildWall(idx + 1, cnt+1);&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; map.resize(n); for (int i = 0; i &lt; n; ++i) &#123; map[i].resize(m); for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; map[i][j]; if (map[i][j] == 0) zero_point.push_back(&#123; i, j &#125;); else if (map[i][j] == 2) &#123; virus[total_virus].x = i; virus[total_virus++].y = j; &#125; &#125; &#125; safe_area = zero_point.size(); buildWall(0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 14499ë²ˆ ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°","slug":"Algorithm/BOJ/14499","date":"2020-01-25T08:02:56.000Z","updated":"2020-01-25T13:10:46.912Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14499/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14499/","excerpt":"","text":"#14499. ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°ë¬¸ì œë§í¬ Problem N x M ì§€ë„ ìœ„ì— ì£¼ì‚¬ìœ„ í•˜ë‚˜ ì˜¤ë¥¸ìª½(ë™), ìœ„ìª½(ë¶) ì£¼ì‚¬ìœ„ ìœ„ì¹˜ëŠ” (x, y) ëª¨ë“  ë©´ì— 0 ì í˜€ ìˆìŒ ì§€ë„ì—ëŠ” ì •ìˆ˜ê°€ ì“°ì—¬ìˆê³ ì£¼ì‚¬ìœ„ê°€ ì´ë™í•œ ì¹¸ì— ì“°ì—¬ ìˆëŠ” ìˆ˜ê°€ 0ì´ë©´ ì£¼ì‚¬ìœ„ ë°”ë‹¥ë©´ ìˆ˜ê°€ ì§€ë„ë¡œ ë³µì‚¬0ì´ ì•„ë‹ˆë©´ ì§€ë„ìœ„ì— ì“°ì—¬ ìˆëŠ” ìˆ˜ê°€ ì£¼ì‚¬ìœ„ ë°”ë‹¥ë©´ìœ¼ë¡œ ë³µì‚¬, ì§€ë„ì— ì“°ì—¬ ìˆëŠ” ìˆ˜ëŠ” 0ì´ ëœë‹¤. Goal: ì£¼ì‚¬ìœ„ê°€ ì´ë™í–ˆì„ ë•Œë§ˆë‹¤ ì£¼ì‚¬ìœ„ì˜ ìœ— ë©´ì— ì“°ì—¬ ìˆëŠ” ìˆ˜ë¥¼ ì¶œë ¥ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ” ëª…ë ¹ì´ë©´ ì›€ì§ì´ì§€ ì•Šê³  ì¶œë ¥ë„ í•˜ì§€ ì•ŠëŠ”ë‹¤. 1: ì˜¤ë¥¸ìª½, 2: ì™¼ìª½, 3: ìœ„ìª½, 4: ì•„ë˜ìª½ìœ¼ë¡œ ì´ë™í•œë‹¤. Solution ì£¼ì‚¬ìœ„ 6ë©´ì˜ ì •ë³´ë¥¼ ê°€ì§€ê³  ìˆì–´ì•¼ í•œë‹¤.12345struct INFO &#123; int up = 0, down = 0, front = 0, back = 0, left = 0, right = 0; int x, y;&#125;dice;// ìœ—ë©´, ì•„ë«ë©´, ì•ë©´, ë’·ë©´, ì™¼ë©´, ì˜¤ë¥¸ë©´ ì£¼ì‚¬ìœ„ë¥¼ ì›€ì§ì¼ ë•Œ 6ë©´ì˜ ì •ë³´ê°€ ë°©í–¥ì— ë§ê²Œ ì—…ë°ì´íŠ¸ ë˜ì–´ì•¼ í•œë‹¤. ë¨¼ì € ë²”ìœ„ë¥¼ ê²€ì‚¬í•˜ê³  ê²€ì‚¬í•œ í›„ì— ì£¼ì‚¬ìœ„ ìœ„ì¹˜ë¥¼ ë³€ê²½í•´ì¤€ë‹¤. ì˜¤ë¥¸ìª½ ì´ë™ìœ„ â†’ ì˜¤ë¥¸ â†’ ì•„ë˜ â†’ ì™¼ â†’ ìœ„ ì™¼ìª½ ì´ë™ìœ„ â†’ ì™¼ â†’ ì•„ë˜ â†’ ì˜¤ë¥¸ â†’ ìœ„ ìœ„ìª½ ì´ë™ìœ„ â†’ ë’¤ â†’ ì•„ë˜ â†’ ì• â†’ ìœ„ ì•„ë˜ìª½ ì´ë™ìœ„ â†’ ì• â†’ ì•„ë˜ â†’ ë’¤ â†’ ìœ„ ê°’ì„ ì œëŒ€ë¡œ ì—…ë°ì´íŠ¸ í•˜ê¸° ìœ„í•´ì„œ ì‚¬ì´í´ì´ ì‹œì‘ë˜ê¸° ì „ ê°’ì„ ì €ì¥í•´ë†“ê³  ìˆœì„œëŒ€ë¡œ ë®ì–´ì”Œìš°ëŠ” ë°©ì‹ìœ¼ë¡œ ê°’ì„ ê°±ì‹ í•œë‹¤.1234567891011121314151617181920212223242526272829303132333435void moveDice(int dir) &#123; int d_x = dice.x + dx[dir - 1]; int d_y = dice.y + dy[dir - 1]; if (isBound(d_x, d_y)) &#123; dice.x = d_x; dice.y = d_y; int tmp = 0; if (dir == 1) &#123; // right tmp = dice.left; dice.left = dice.down; dice.down = dice.right; dice.right = dice.up; dice.up = tmp; &#125; else if (dir == 2) &#123; // left tmp = dice.right; dice.right = dice.down; dice.down = dice.left; dice.left = dice.up; dice.up = tmp; &#125; else if (dir == 3) &#123; // up tmp = dice.front; dice.front = dice.down; dice.down = dice.back; dice.back = dice.up; dice.up = tmp; &#125; else if (dir == 4) &#123; // down tmp = dice.back; dice.back = dice.down; dice.down = dice.front; dice.front = dice.up; dice.up = tmp; &#125;&#125; ì›€ì§ì˜€ì„ ë•Œ ì§€ë„ì˜ ì¹¸ì´ 0ì´ë©´, ì£¼ì‚¬ìœ„ ë°”ë‹¥ë©´ ìˆ˜ â†’ ì§€ë„ ì§€ë„ì˜ ì¹¸ì´ 0ì´ ì•„ë‹ˆë©´, ì§€ë„ â†’ ì£¼ì‚¬ìœ„ ë°”ë‹¥ë©´ ìˆ˜ &amp; 0 â†’ ì§€ë„123456if (map[dice.x][dice.y] == 0) map[dice.x][dice.y] = dice.down;else &#123; dice.down = map[dice.x][dice.y]; map[dice.x][dice.y] = 0;&#125;cout &lt;&lt; dice.up &lt;&lt; \"\\n\"; // ìœ—ë©´ ì¶œë ¥ 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, m;vector&lt;vector&lt;int&gt; &gt; map;int dx[4] = &#123; 0, 0, -1, 1 &#125;;int dy[4] = &#123; 1, -1, 0, 0 &#125;;struct INFO &#123; int up = 0, down = 0, front = 0, back = 0, left = 0, right = 0; int x, y;&#125;dice;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; n &amp;&amp; y &lt; m) return true; return false;&#125;void moveDice(int dir) &#123; int d_x = dice.x + dx[dir-1]; int d_y = dice.y + dy[dir-1]; if (isBound(d_x, d_y)) &#123; dice.x = d_x; dice.y = d_y; int tmp = 0; if (dir == 1) &#123; // right tmp = dice.left; dice.left = dice.down; dice.down = dice.right; dice.right = dice.up; dice.up = tmp; &#125; else if (dir == 2) &#123; // left tmp = dice.right; dice.right = dice.down; dice.down = dice.left; dice.left = dice.up; dice.up = tmp; &#125; else if (dir == 3) &#123; // up tmp = dice.front; dice.front = dice.down; dice.down = dice.back; dice.back = dice.up; dice.up = tmp; &#125; else if (dir == 4) &#123; // down tmp = dice.back; dice.back = dice.down; dice.down = dice.front; dice.front = dice.up; dice.up = tmp; &#125; if (map[dice.x][dice.y] == 0) map[dice.x][dice.y] = dice.down; else &#123; dice.down = map[dice.x][dice.y]; map[dice.x][dice.y] = 0; &#125; cout &lt;&lt; dice.up &lt;&lt; \"\\n\"; &#125;&#125;int main() &#123; int start_x, start_y, k, dir; cin &gt;&gt; n &gt;&gt; m &gt;&gt; start_x &gt;&gt; start_y &gt;&gt; k; dice.x = start_x; dice.y = start_y; map.resize(n); for (int i = 0; i &lt; n; ++i) &#123; map[i].resize(m); for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; for (int i = 0; i &lt; k; ++i) &#123; cin &gt;&gt; dir; moveDice(dir); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 14226ë²ˆ ì´ëª¨í‹°ì½˜","slug":"Algorithm/BOJ/14226","date":"2020-01-25T08:02:49.000Z","updated":"2020-01-25T13:10:46.908Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/14226/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/14226/","excerpt":"","text":"#14226. ì´ëª¨í‹°ì½˜Problem ë¬¸ì œë§í¬ Solution í™”ë©´ì— ìˆëŠ” ì´ëª¨í‹°ì½˜ ëª¨ë‘ í´ë¦½ë³´ë“œì— ì €ì¥ í´ë¦½ë³´ë“œì— ìˆëŠ” ì´ëª¨í‹°ì½˜ í™”ë©´ì— ë¶™ì—¬ë„£ê¸° í™”ë©´ì— ìˆëŠ” ì´ëª¨í‹°ì½˜ í•˜ë‚˜ ì‚­ì œ í´ë¦½ë³´ë“œì— ì´ëª¨í‹°ì½˜ì´ í•˜ë‚˜ë¼ë„ ìˆì–´ì•¼ 2ë²ˆ ì‘ì—… ê°€ëŠ¥ í™”ë©´ì— ì´ëª¨í‹°ì½˜ì´ í•˜ë‚˜ë¼ë„ ìˆì–´ì•¼ 3ë²ˆ ì‘ì—… ê°€ëŠ¥ 1ë²ˆ ì‘ì—…ì€ ì–¸ì œë‚˜ ìˆ˜í–‰ ê°€ëŠ¥ 2ë²ˆ ì‘ì—…ì€ í™”ë©´ì— ìˆëŠ” ì´ëª¨í‹°ì½˜ + í´ë¦½ë³´ë“œ ì´ëª¨í‹°ì½˜ì´ ëª©í‘œ(ë§Œë“¤ì–´ì•¼ í•  ì´ëª¨í‹°ì½˜ ìˆ˜)ì´í•˜ì—¬ì•¼ í•œë‹¤. 3ë²ˆ ì‘ì—…ì€ í™”ë©´ì— ìˆëŠ” ì´ëª¨í‹°ì½˜ - 1ì´ 0ì´ìƒì´ì–´ì•¼ í•œë‹¤. (ëª©í‘œ ì´ëª¨í‹°ì½˜ ìµœì†Œ ìˆ˜ê°€ 2ì´ê¸°ì— 1ì´ìƒì´ì–´ë„ ìƒê´€ ì—†ë‹¤.) ê° ì‘ì—…ì€ 1ì´ˆë¡œ ë™ì¼í•œ ì‹œê°„ì´ ê±¸ë¦¬ê¸°ì— BFSë¡œ í•´ê²°í•œë‹¤. queueì—ëŠ” &lt;í™”ë©´ì— ìˆëŠ” ì´ëª¨í‹°ì½˜ ìˆ˜, í´ë¦½ë³´ë“œì— ìˆëŠ” ì´ëª¨í‹°ì½˜ ìˆ˜&gt;ê°€ ì € ì¤‘ë³µë˜ì§€ ì•Šë„ë¡ distë¼ëŠ” ë°°ì—´ì— [í™”ë©´][í´ë¦½ë³´ë“œ] ì²¨ìë¥¼ ì´ìš©í•´ ì‹œê°„ì„ ì €ì¥í•œë‹¤. 1 Try123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;tuple&gt;using namespace std;queue&lt;pair&lt;int, int&gt;&gt; q;int dist[1001][1001];int main() &#123; int n; cin &gt;&gt; n; q.push(&#123; 1, 0 &#125;); while (!q.empty()) &#123; int s, c; tie(s, c) = q.front(); q.pop(); if (dist[s][s] == 0) &#123; // í™”ë©´ì— ìˆëŠ” ì´ëª¨í‹°ì½˜ í´ë¦½ë³´ë“œì— ë³µì‚¬ dist[s][s] = dist[s][c] + 1; q.push(&#123; s, s &#125;); &#125; if (s+c &lt;= n &amp;&amp; dist[s+c][c] == 0) &#123; // í´ë¦½ë³´ë“œ í™”ë©´ì— ë¶™ì—¬ë„£ê¸° dist[s + c][c] = dist[s][c] + 1; q.push(&#123; s + c, c &#125;); &#125; if (s - 1 &gt;= 0 &amp;&amp; dist[s - 1][c] == 0) &#123; // í™”ë©´ì— ìˆëŠ” ì´ëª¨í‹°ì½˜ -1 dist[s - 1][c] = dist[s][c] + 1; q.push(&#123; s - 1, c &#125;); &#125; &#125; int ans = 1e9; for (int i = 0; i &lt;= n; ++i) &#123; // ìµœì†Ÿê°’ ì°¾ê¸° if (ans &gt; dist[n][i] &amp;&amp; dist[n][i] != 0) ans = dist[n][i]; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 13913ë²ˆ ìˆ¨ë°”ê¼­ì§ˆ 4","slug":"Algorithm/BOJ/13913","date":"2020-01-25T08:02:43.000Z","updated":"2020-01-25T13:10:46.904Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/13913/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/13913/","excerpt":"","text":"#13913. ìˆ¨ë°”ê¼­ì§ˆ 4Problem ë¬¸ì œë§í¬ Solution BFS íƒìƒ‰ì„ í•˜ë˜, ê²½ë¡œë¥¼ ì•Œê³  ìˆì–´ì•¼ í•˜ê¸°ì— path[to] = from ì„ ì‚¬ìš©í•œë‹¤. ì¦‰, 5â†’6â†’8â†’10 ì´ë¼ë©´ path[10]ì—ëŠ” 8, path[8]ì—ëŠ” 6ì´ ì €ì¥ë˜ì–´ ìˆë‹¤. ê²½ë¡œë¥¼ ì¶œë ¥í•˜ê¸° ìœ„í•´ ì¬ê·€í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œë‹¤. 1234(5, 10) 4. ì¶œë ¥ (5, 8) 3. ì¶œë ¥ (5, 6) 2. ì¶œë ¥ (5, 5) 1. ì¶œë ¥ 1 Try code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define MAX 100000using namespace std;int N, K;bool end_flag;int dist[MAX+1];vector&lt;int&gt; path;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void Input() &#123; cin &gt;&gt; N &gt;&gt; K;&#125;void PrintPath() &#123; for (auto e : path) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; \"\\n\";&#125;void BFS() &#123; queue&lt;int&gt; q; q.push(N); while (!q.empty()) &#123; int n = q.front(); q.pop(); if (n == K) return; if (n &gt; 0 &amp;&amp; dist[n - 1] == 0) &#123; dist[n - 1] = dist[n] + 1; q.push(n - 1); &#125; if (n &lt; MAX &amp;&amp; dist[n + 1] == 0) &#123; dist[n + 1] = dist[n] + 1; q.push(n + 1); &#125; if (2 * n &lt;= MAX &amp;&amp; dist[2 * n] == 0) &#123; dist[2 * n] = dist[n] + 1; q.push(2 * n); &#125; &#125;&#125;void DFS(int n, int cnt) &#123; if (end_flag == true) return; if (dist[K] == cnt &amp;&amp; n == K) &#123; cout &lt;&lt; dist[K] &lt;&lt; \"\\n\"; PrintPath(); end_flag = true; return; &#125; if (dist[K] == cnt) return; if (n &gt; 0) &#123; path.push_back(n - 1); DFS(n - 1, cnt + 1); path.pop_back(); &#125; if (n &lt; MAX) &#123; path.push_back(n +1); DFS(n + 1, cnt + 1); path.pop_back(); &#125; if (2 * n &lt;= MAX) &#123; path.push_back(2 * n); DFS(2 * n, cnt + 1); path.pop_back(); &#125;&#125;void Solve() &#123; BFS(); path.push_back(N); DFS(N, 0);&#125;int main() &#123; Input(); Solve(); return 0;&#125; BFS + DFSë¡œ êµ¬í•˜ë‹ˆ ì‹œê°„ì´ˆê³¼ (BFSë¡œ depthë¥¼ êµ¬í•˜ê³  ê·¸ depthë§Œí¼ DFSë¥¼ ìˆ˜í–‰í•˜ë„ë¡ í•˜ì˜€ë‹¤.) 2 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define MAX 100000using namespace std;int N, K;int dist[MAX + 1];int path[MAX + 1];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void Input() &#123; cin &gt;&gt; N &gt;&gt; K;&#125;void PrintPath(int from, int to) &#123; if (from != to) &#123; PrintPath(from, path[to]); &#125; cout &lt;&lt; to &lt;&lt; \" \";&#125;void BFS() &#123; queue&lt;int&gt; q; q.push(N); while (!q.empty()) &#123; int n = q.front(); q.pop(); if (n == K) return; if (n &gt; 0 &amp;&amp; dist[n - 1] == 0) &#123; dist[n - 1] = dist[n] + 1; path[n - 1] = n; q.push(n - 1); &#125; if (n &lt; MAX &amp;&amp; dist[n + 1] == 0) &#123; dist[n + 1] = dist[n] + 1; path[n + 1] = n; q.push(n + 1); &#125; if (2 * n &lt;= MAX &amp;&amp; dist[2 * n] == 0) &#123; dist[2 * n] = dist[n] + 1; path[2 * n] = n; q.push(2 * n); &#125; &#125;&#125;void Solve() &#123; BFS(); cout &lt;&lt; dist[K] &lt;&lt; \"\\n\"; PrintPath(N, K);&#125;int main() &#123; Input(); Solve(); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 13460ë²ˆ êµ¬ìŠ¬ íƒˆì¶œ 2","slug":"Algorithm/BOJ/13460","date":"2020-01-25T08:02:37.000Z","updated":"2020-01-25T12:56:58.640Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/13460/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/13460/","excerpt":"","text":"#13460. êµ¬ìŠ¬ íƒˆì¶œ 2Problem ë¬¸ì œë§í¬ Solution ì‹œë®¬ë ˆì´ì…˜ ë¬¸ì œì´ë‹¤. ì–´ë–¤ ë°©í–¥ìœ¼ë¡œ ê¸°ìš¸ì¼ì§€ ì •í•´ì•¼ í•œë‹¤. (ëª¨ë“  ê²½ìš°ë¥¼ êµ¬í•´ì•¼ í•œë‹¤. - ì¬ê·€ ì‚¬ìš©)ì´ì „ ë°©í–¥ê³¼ ë°˜ëŒ€ë˜ëŠ” ë°©í–¥ìœ¼ë¡œ ì´ë™í•  í•„ìš”ëŠ” ì—†ë‹¤. ë§µì„ ê°±ì‹ í•  í•„ìš”ëŠ” ì—†ê³  êµ¬ìŠ¬ì˜ ìœ„ì¹˜ë§Œ ë³€ê²½í•˜ë©´ ëœë‹¤. ê° ê²½ìš°ë§ˆë‹¤ êµ¬ìŠ¬ì˜ ìœ„ì¹˜ë¥¼ ë‹¤ìŒ ì‘ì—…ì— ë„˜ê²¨ì£¼ì–´ì•¼ í•œë‹¤. (ì¬ê·€ í•¨ìˆ˜ ì¸ìë¡œ ë„˜ê¸°ê¸°) ê¸°ìš¸ì´ê¸° ì¬ê·€í•¨ìˆ˜123456789101112131415161718Move(ì´ë™ íšŸìˆ˜, ì´ì „ ë°©í–¥, ë¹¨ê°„ êµ¬ìŠ¬ ìœ„ì¹˜, íŒŒë€ êµ¬ìŠ¬ ìœ„ì¹˜) if ì´ë™ íšŸìˆ˜ &gt; 10 return if íŒŒë€ êµ¬ìŠ¬ì´ êµ¬ë©ì— ë“¤ì–´ê°„ ê²½ìš° return if ë¹¨ê°„ êµ¬ìŠ¬ë§Œ êµ¬ë©ì— ë“¤ì–´ê°„ ê²½ìš° ìµœì†Ÿê°’ ê°±ì‹  return 4 ë°©í–¥ ì´ë™ ë²½ì´ ì•„ë‹ ë•Œê¹Œì§€, êµ¬ë© ì¼ ë•Œê¹Œì§€ ì´ë™ // ë¹¨ê°„ êµ¬ìŠ¬ ì´ë™ // íŒŒë€ êµ¬ìŠ¬ ì´ë™ ì´ë™ì´ ëë‚˜ë©´ if ìœ„ì¹˜ê°€ ê²¹ì¹  ë•Œ if êµ¬ë©ì´ë©´ Move(ì´ë™ íšŸìˆ˜ + 1, ë°©í–¥, ìœ„ì¹˜) else ê°™ì€ í–‰ì¼ ë•Œ ê°™ì€ ì—´ì¼ ë•Œ ìœ„ì¹˜ ì´ë™ Move(ì´ë™íšŸìˆ˜ +1, ë°©í–¥, ìœ„ì¹˜) else Move(ì´ë™íšŸìˆ˜ +1, ë°©í–¥, ìœ„ì¹˜) ë¹¨ê°„ êµ¬ìŠ¬ì´ ë°©í–¥ì— ë§ê²Œ ì´ë™í•˜ê³ , ê·¸ í›„ íŒŒë€ êµ¬ìŠ¬ì´ ì´ë™í•œë‹¤. êµ¬ë©ì— ë“¤ì–´ê°”ê±°ë‚˜ ê°™ì€ í–‰ì´ê±°ë‚˜ ê°™ì€ ì—´ì´ë©´ ìœ„ì¹˜ê°€ ê°™ê²Œ ëœë‹¤. ì´ë•Œ ë°©í–¥ê³¼ ì²˜ìŒ ìœ„ì¹˜ì— ë§ê²Œ ë°©í–¥ì„ ë°”ê¿”ì¤€ë‹¤. ê°±ì‹ ì´ ëë‚¬ìœ¼ë©´ ì¬ê·€í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì¤€ë‹¤. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;using namespace std;int N, M, ans = 1e9;int g_x, g_y;char board[11][11];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;int count_dir[4] = &#123; 1, 0, 3, 2 &#125;;struct Red &#123; int x, y;&#125;;struct Blue &#123; int x, y;&#125;;void Move(int cnt, int prior_dir, Red r, Blue b) &#123; if (cnt &gt; 10) return; if (b.x == g_x &amp;&amp; b.y == g_y) return; // íŒŒë€ êµ¬ìŠ¬ êµ¬ë© í†µê³¼ if (r.x == g_x &amp;&amp; r.y == g_y) &#123; // ë¹¨ê°„ êµ¬ìŠ¬ë§Œ êµ¬ë© í†µê³¼ if (ans &gt; cnt) ans = cnt; return; &#125; for (int dir = 0; dir &lt; 4; ++dir) &#123; Red nr = &#123; r.x, r.y &#125;; Blue nb = &#123; b.x, b.y &#125;; // next if (prior_dir != -1 &amp;&amp; count_dir[prior_dir] == dir) continue; while (true) &#123; if (board[nr.x + dx[dir]][nr.y + dy[dir]] == '#') break; nr.x += dx[dir]; nr.y += dy[dir]; if (board[nr.x][nr.y] == 'O') break; &#125; while (true) &#123; if (board[nb.x + dx[dir]][nb.y + dy[dir]] == '#') break; nb.x += dx[dir]; nb.y += dy[dir]; if (board[nb.x][nb.y] == 'O') break; &#125; if (nr.x == nb.x &amp;&amp; nr.y == nb.y) &#123; // ê²¹ì¹  ë•Œ if (board[nr.x][nr.y] == 'O') Move(cnt + 1, dir, nr, nb); else &#123; if (r.x == b.x) &#123; // ê°™ì€ í–‰ if (r.y &lt; b.y) &#123; // R B if (dir == 2) nb.y++; else if (dir == 3) nr.y--; &#125; else &#123; // B R if (dir == 2) nr.y++; else if (dir == 3) nb.y--; &#125; &#125; else if (r.y == b.y) &#123; // ê°™ì€ ì—´ if (r.x &lt; b.x) &#123; // Rì´ Bë³´ë‹¤ ìœ„ if (dir == 0) nb.x++; else if (dir == 1) nr.x--; &#125; else &#123; // Rì´ Bë³´ë‹¤ ì•„ë˜ if (dir == 0) nr.x++; else if (dir == 1) nb.x--; &#125; &#125; Move(cnt + 1, dir, nr, nb); &#125; &#125; else &#123; Move(cnt + 1, dir, nr, nb); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M; Red r; Blue b; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; cin &gt;&gt; board[i][j]; if (board[i][j] == 'O') &#123; g_x = i; g_y = j; &#125; else if (board[i][j] == 'R') &#123; r.x = i; r.y = j; &#125; else if (board[i][j] == 'B') &#123; b.x = i; b.y = j; &#125; &#125; &#125; Move(0, -1, r, b); if (ans == 1e9) cout &lt;&lt; -1 &lt;&lt; \"\\n\"; else cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; ë¬¸ì œ í’€ê³ ë‚˜ì„œ ì°¾ì•„ë³¸ ê¹”ë”í•œ ì½”ë“œ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;int n, m;int rx, ry, bx, by;char a[11][11];int ans = 11;void go(int rx, int ry, int bx, int by, int mx, int my, int cnt)&#123; if (cnt &gt;= ans) return; int rm = 0, bm = 0; if (mx != my)&#123; while (a[bx + mx][by + my] - '#')&#123; bx += mx; by += my; bm++; if (!(a[bx][by] - 'O')) return; &#125; while (a[rx + mx][ry + my] - '#')&#123; rx += mx; ry += my; rm++; if (!(a[rx][ry] - 'O'))&#123; ans = ans &lt; cnt ? ans : cnt; return; &#125; &#125; &#125; if (rx == bx &amp;&amp; ry == by) if (rm &lt; bm) bx -= mx, by -= my; else rx -= mx, ry -= my; if (mx == 0)&#123; go(rx, ry, bx, by, 1, 0, cnt + 1); go(rx, ry, bx, by, -1, 0, cnt + 1); &#125; if (my == 0)&#123; go(rx, ry, bx, by, 0, 1, cnt + 1); go(rx, ry, bx, by, 0, -1, cnt + 1); &#125;&#125;int main()&#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf(\"%s\", a[i]); for (int i = 1; i &lt; n - 1; i++)&#123; for (int j = 1; j &lt; m - 1; j++)&#123; if (a[i][j] == 'R') rx = i, ry = j; if (a[i][j] == 'B') bx = i, by = j; &#125; &#125; go(rx, ry, bx, by, 0, 0, 0); printf(\"%d\", ans &lt; 11 ? ans : -1);&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 12851ë²ˆ ìˆ¨ë°”ê¼­ì§ˆ 2","slug":"Algorithm/BOJ/12851","date":"2020-01-25T08:02:32.000Z","updated":"2020-01-25T12:55:53.699Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/12851/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/12851/","excerpt":"","text":"#12851. ìˆ¨ë°”ê¼­ì§ˆ 2Problem ë¬¸ì œë§í¬ Solution ë°©ë²•ì˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ê²ƒì´ ì¶”ê°€ê°€ ë˜ì—ˆë‹¤. ì´ëŠ” DPë¥¼ í™œìš©í•˜ì—¬ êµ¬í•œë‹¤. ë°©ë¬¸í•˜ì§€ ì•Šì€ ê²½ë¡œë¼ë©´ ë°©ë²•ì˜ ìˆ˜ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€ ë°©ë¬¸í•œ ê²½ìš° + ê±°ë¦¬ ì°¨ì´ê°€ 1ì¸ ê²½ìš°ì—ë§Œ ë°©ë²•ì˜ ìˆ˜+1ê±°ë¦¬ ì°¨ì´ê°€ 1ì¸ ê²½ìš°ì—ë§Œ ìµœì†Œë¹„ìš©ì„ ë§Œì¡±í•˜ëŠ” ê²½ë¡œì´ê¸° ë•Œë¬¸ì´ë‹¤. 1 Try1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;queue&gt;#define MAX 100000using namespace std;int N, K;queue&lt;int&gt; q;bool visit[MAX+1];int dist[MAX + 1];int cnt[MAX + 1];void BFS() &#123; q.push(N); visit[N] = true; dist[N] = 0; cnt[N] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int next : &#123;x - 1, x + 1, x * 2&#125;) &#123; if (0 &lt;= next &amp;&amp; next &lt;= MAX) &#123; if (!visit[next]) &#123; visit[next] = true; dist[next] = dist[x] + 1; cnt[next] = cnt[x]; q.push(next); &#125; else if (dist[next] == dist[x] + 1) &#123; cnt[next] += cnt[x]; &#125; &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; K; BFS(); cout &lt;&lt; dist[K] &lt;&lt; \"\\n\" &lt;&lt; cnt[K] &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 12100ë²ˆ 2048(Easy)","slug":"Algorithm/BOJ/12100","date":"2020-01-25T08:02:27.000Z","updated":"2020-01-25T12:50:39.911Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/12100/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/12100/","excerpt":"","text":"#12100. 2048(Easy)ë¬¸ì œë§í¬ Problem N x N í¬ê¸°ì˜ ë³´ë“œíŒ í•œ ë²ˆì˜ ì´ë™ : ë³´ë“œíŒì— ìˆëŠ” ëª¨ë“  ë¸”ë¡ ìƒí•˜ì¢Œìš° ì¤‘ í•œ ë°©í–¥ìœ¼ë¡œ ì­‰ ì´ë™ë‹¨ìˆœíˆ í•œ ì¹¸ì´ ì•„ë‹Œ í•´ë‹¹ ë°©í–¥ ì´ë™í•  ìˆ˜ ìˆëŠ” ê³³ ëê¹Œì§€ ê°™ì€ ê°’ì„ ê°€ì§„ ë¸”ë¡ì´ ì¶©ëŒí•˜ë©´ í•˜ë‚˜ë¡œ í•©ì³ì§(í•œ ë²ˆ í•©ì³ì§€ë©´ ë‹¤ì‹œ í•©ì¹  ìˆ˜ ì—†ìŒ â†’ í•œ ë²ˆ ì´ë™í•  ë•Œ ì—°ì†ìœ¼ë¡œ í•©ì³ì§ˆ ìˆ˜ ì—†ìŒ 2ê°œ â†’ 1ê°œì¸ ê²½ìš°ë§Œ ì¡´ì¬)ë¸”ë¡ì´ í•©ì³ì§€ë©´ í•´ë‹¹ ë¸”ë¡ì˜ ìˆ«ìë¥¼ ë”í•œ ê°’ì´ ëœë‹¤. Goal: ìµœëŒ€ 5ë²ˆ ì´ë™í•´ì„œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ë¸”ë¡ì˜ ê°’ êµ¬í•˜ê¸° ì…ë ¥ N: ~20 0: ë¹ˆì¹¸ 2^i(i= 1, 2â€¦10): ë¸”ë¡ // ì ì–´ë„ í•˜ë‚˜ ì£¼ì–´ì§ Solution ìµœëŒ€ 5ë²ˆ ì´ë™ì´ë‹ˆ í•œ ë²ˆ ì´ë™í•˜ë©´ì„œ ìµœëŒ€ ë¸”ë¡ ê°’ì„ ê°±ì‹ í•´ì£¼ì–´ì•¼ í•œë‹¤.(ê¼­ ì•ˆê·¸ë˜ë„ ë˜ê² ì§€ë§Œ) 5ë²ˆ ì´ë™í•˜ëŠ” ì¡°í•©ì„ êµ¬í•œë‹¤. ê·¸ ì´ë™ì— ë§ê²Œ ë¸”ë¡ì„ ì´ë™ì‹œí‚¨ë‹¤. í•´ë‹¹ ë²ˆì§¸ì˜ ë°©í–¥ì„ ì €ì¥í•  ë°°ì—´ì„ ì´ìš©í•´ 5ê°œì˜ ë°©í–¥ì„ ì €ì¥í•´ë†“ê³ , ëª¨ë‘ ì €ì¥í–ˆì„ ë•Œ ë³´ë“œíŒì„ ì›€ì§ì´ë„ë¡ í•œë‹¤.1234567891011121314151617void dfs(int idx) &#123; if (idx == 5) &#123; // ë°©í–¥ 5ê°œê°€ ì €ì¥ë˜ì—ˆì„ ë•Œ for (int i = 0; i &lt; n; ++i) &#123; // ì…ë ¥ê°’ì¸ tempë¥¼ boardë¡œ ì˜®ê¸°ê³  ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤. for (int j = 0; j &lt; n; ++j) &#123; board[i][j] = temp[i][j]; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; moveBlock(í•´ë‹¹ ë°©í–¥); &#125; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; direction[idx] = i; dfs(idx+1); &#125;&#125; moveBlock() ë¸”ëŸ­ ì´ë™ ì›€ì§ì´ëŠ” ë°©í–¥ì´ ì¢Œìš°ë©´ í•œ í–‰ì˜ ì—´ì´ ë°”ë€Œë©´ì„œ boardìœ„ì˜ ë¸”ëŸ­ë“¤ì´ ë°”ë€ë‹¤.ì´ë•Œ ì¢Œë¡œ ì´ë™í•˜ë©´ ì˜¤ë¥¸ìª½ë¶€í„° íƒìƒ‰, ìš°ë¡œ ì´ë™í•˜ë©´ ì™¼ìª½ë¶€í„° íƒìƒ‰í•´ì•¼ í•œë‹¤. ì›€ì§ì´ëŠ” ë°©í–¥ì´ ìƒí•˜ì¼ ë•Œë„ ìœ„ì™€ ê°™ì€ ë°©ì‹ì´ë‹¤. ì´ë¥¼ ì˜ êµ¬ë¶„í•´ì£¼ì–´ updateí•  ë•Œ í–‰, ì—´ì˜ ì¸ë±ìŠ¤ë¥¼ ë°˜ì˜í•œë‹¤. update() ì•„ë˜ ì½”ë“œëŠ” ì¢Œìš°ë¡œ ì´ë™í•  ë•Œ ë¸”ëŸ­ë“¤ì„ ê°±ì‹ í•˜ëŠ” í•¨ìˆ˜ë‹¤.12345678910111213141516171819202122232425void updateCol(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[i][j] == 0) &#123; // 0ì˜ ìœ„ì¹˜ zero.push(j); &#125; else if (board[i][j] != 0 &amp;&amp; board[i][j] == value) &#123; // ë¸”ëŸ­ ê°’ì´ ê°™ì„ ë•Œ value = 0; // í•œ ë²ˆì— í•œ ë²ˆë§Œ í•©ì¹˜ë„ë¡ 0ìœ¼ë¡œ ì´ˆê¸°í™” board[i][value_idx] *= 2; answer = max(answer, board[i][value_idx]); board[i][j] = 0; zero.push(j); &#125; else if (board[i][j] != 0) &#123; value_idx = j; value = board[i][j]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[i][j] = 0; board[i][zero_idx] = value; zero.push(j); value_idx = zero_idx; // ë³€ê²½ &#125; &#125;&#125; 3ê°€ì§€ ê²½ìš°ë¥¼ í™•ì¸í•˜ê³  ê° ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤. ë¸”ëŸ­ì´ ì—†ëŠ” ë¹ˆ ê³³: queueì— í•´ë‹¹ ìœ„ì¹˜ë¥¼ ë„£ì–´ì¤€ë‹¤. (ë¸”ëŸ­ì„ ì˜®ê¸¸ ë•Œ ì“°ì„) í•©ì¹  ëŒ€ìƒì´ ë˜ëŠ” ë¸”ëŸ­: ì´ì „ì— ì €ì¥í•´ë†“ì€ ë¸”ëŸ­ ê°’ê³¼ ê°™ìœ¼ë©´ í•©ì¹  ìˆ˜ ìˆë‹¤.ì´ì „ì— ì €ì¥í•´ë†“ì€ ë¸”ëŸ­ì˜ ê°’ì„ 2ë°°ë¡œ í•˜ê³  í•©ì¹  ëŒ€ìƒì´ ë˜ëŠ” ë¸”ëŸ­ì€ 0ìœ¼ë¡œ ë°”ê¾¼ë’¤ ì´ ìœ„ì¹˜ë¥¼ queueì— ë„£ì–´ì¤€ë‹¤. í•©ì³ì§ˆ ê°€ëŠ¥ì„±ì´ ìˆëŠ” ë¸”ëŸ­: ì´ ê°’ì€ ë‚˜ì¤‘ì— í•©ì³ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ í•´ë‹¹ ê°’ê³¼ ìœ„ì¹˜ë¥¼ ì €ì¥í•´ ë†“ëŠ”ë‹¤.ë‹¨, queueê°€ ë¹„ì–´ìˆì§€ ì•Šë‹¤ë©´ ì´ ë¸”ëŸ­ì˜ ìœ„ì¹˜ë¥¼ ì˜®ê²¨ì£¼ì–´ì•¼ í•˜ê¸°ì— queueì—ì„œ popí•œ 0ì˜ ìœ„ì¹˜ë¡œ í•´ë‹¹ ë¸”ëŸ­ ê°’ì„ ë„£ì–´ì¤€ë‹¤.ì´ë ‡ê²Œ ë˜ë©´ ë°”ë€Œê¸° ì „ ë¸”ëŸ­ì€ 0ì´ ë˜ê³  ì´ ìœ„ì¹˜ë¥¼ ë‹¤ì‹œ queueì— ë„£ì–´ì£¼ì–´ì•¼ í•œë‹¤.ë§ˆì§€ë§‰ìœ¼ë¡œ ìœ„ì¹˜ê°€ ë°”ë€ ì§€ì ì„ ê°±ì‹ í•´ì£¼ë©´ ëœë‹¤. 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define MAX 20using namespace std;int n, value, value_idx, zero_idx, answer = 2;int board[MAX][MAX];int temp[MAX][MAX];int direction[5]; // ë°©í–¥ ì¡°í•© 0:ìƒ, 1:í•˜, 2:ì¢Œ, 3:ìš°void updateCol(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[i][j] == 0) &#123; // 0ì˜ ìœ„ì¹˜ zero.push(j); &#125; else if (board[i][j] != 0 &amp;&amp; board[i][j] == value) &#123; // ë¸”ëŸ­ ê°’ì´ ê°™ì„ ë•Œ value = 0; // í•œ ë²ˆì— í•œ ë²ˆë§Œ í•©ì¹˜ë„ë¡ 0ìœ¼ë¡œ ì´ˆê¸°í™” board[i][value_idx] *= 2; answer = max(answer, board[i][value_idx]); board[i][j] = 0; if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[i][zero_idx] = value; &#125; zero.push(j); &#125; else if (board[i][j] != 0) &#123; value_idx = j; value = board[i][j]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[i][j] = 0; board[i][zero_idx] = value; zero.push(j); &#125; &#125;&#125;void updateRow(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[j][i] == 0) &#123; // 0ì˜ ìœ„ì¹˜ zero.push(j); &#125; else if (board[j][i] != 0 &amp;&amp; board[j][i] == value) &#123; // ë¸”ëŸ­ ê°’ì´ ê°™ì„ ë•Œ value = 0; // í•œ ë²ˆì— í•œ ë²ˆë§Œ í•©ì¹˜ë„ë¡ 0ìœ¼ë¡œ ì´ˆê¸°í™” board[value_idx][i] *= 2; answer = max(answer, board[value_idx][i]); board[j][i] = 0; if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[zero_idx][i] = value; &#125; zero.push(j); &#125; else if (board[j][i] != 0) &#123; value_idx = j; value = board[j][i]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[j][i] = 0; board[zero_idx][i] = value; zero.push(j); &#125; &#125;&#125;void moveBlock(int move) &#123; for (int i = 0; i &lt; n; ++i) &#123; queue&lt;int&gt; zero; value = 0; value_idx = 0; zero_idx = 0; if (move % 2 == 0) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (move == 0) &#123; updateRow(i, j, zero); &#125; else &#123; updateCol(i, j, zero); &#125; &#125; &#125; else &#123; for (int j = n-1; j &gt;= 0; --j) &#123; if (move == 1) &#123; updateRow(i, j, zero); &#125; else &#123; updateCol(i, j, zero); &#125; &#125; &#125; &#125;&#125;void dfs(int idx) &#123; if (idx == 5) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; board[i][j] = temp[i][j]; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; moveBlock(direction[i]); &#125; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; direction[idx] = i; dfs(idx+1); &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;temp[i][j]); &#125; &#125; dfs(0); printf(\"%d\\n\", answer); return 0;&#125; ìœ„ì˜ ì½”ë“œê°€ í‹€ë¦° Test case 7 2 2 2 2 2 2 2 2 0 2 2 2 2 2 2 0 2 2 2 2 2 2 0 2 2 2 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 0 2 2 2 2 2 2 0 -&gt; 32 // output ë””ë²„ê¹…ìš© ì½”ë“œë¥¼ ë³´ë©´ ì•Œê² ì§€ë§Œ ë°©í–¥ì„ 3(ì˜¤ë¥¸ìª½)ìœ¼ë¡œ í–ˆì„ ë•Œ boardì˜ ë¸”ëŸ­ë“¤ì„ í™•ì¸í•´ë³´ë‹ˆì‹¤ì œë¡œ ì˜ í•©ì³ì§€ì§€ ì•Šì•˜ë˜ ê²ƒì´ë‹¤. (solutionì—ëŠ” ì •ë‹µ ì½”ë“œë¥¼ ë°˜ì˜) ìœ„ ì½”ë“œì˜ ë¹¨ê°„ ì¤„ì„ ì—†ì• ì£¼ì—ˆë‹¤. í•©ì³ì§€ë©´ 0ì´ ìˆëŠ” ê³³ì„ ì°¾ì•„ ë„£ëŠ” ì‘ì—…ì„ í•˜ë©´ ì•ˆë˜ê¸° ë•Œë¬¸ì´ë‹¤. ì´ ë¸”ëŸ­ì€ í•©ì³ì¡Œê³ , ì´ ìœ„ì¹˜ëŠ” 0ìœ¼ë¡œ ì±„ìš°ê³  ì´ ì¸ë±ìŠ¤ë¥¼ queueì— ë„£ì–´ì£¼ê¸°ë§Œ í•˜ë©´ ëœë‹¤. queueê°€ ë¹„ì–´ìˆì§€ ì•Šë‹¤ë©´ í•´ë‹¹ ì§€ì ì— ë¸”ëŸ­ì„ ë†“ëŠ” ì‘ì—…ì´ ìˆëŠ”ë°ì´ë•Œ, value_idx = zero_idx ë¥¼ ì¶”ê°€í•´ì£¼ì–´ì•¼ í•´ë‹¹ ë¸”ëŸ­ì˜ ë°”ë€ ìœ„ì¹˜ë„ ì•Œ ìˆ˜ ìˆë‹¤.ì´ë¥¼ ì¶”ê°€í•˜ì§€ ì•Šìœ¼ë©´ ë°”ë€Œê¸° ì „ ìœ„ì¹˜ê°€ ë‚¨ì•„ìˆì–´ í•©ì³ì§€ì§€ ì•ŠëŠ”ë‹¤. Debug ì½”ë“œ ë³´ê¸°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define MAX 20using namespace std;int n, value, value_idx, zero_idx, answer = 2;int board[MAX][MAX];int temp[MAX][MAX];int direction[5]; // ë°©í–¥ ì¡°í•© 0:ìƒ, 1:í•˜, 2:ì¢Œ, 3:ìš°void updateCol(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[i][j] == 0) &#123; // 0ì˜ ìœ„ì¹˜ zero.push(j); &#125; else if (board[i][j] != 0 &amp;&amp; board[i][j] == value) &#123; // ë¸”ëŸ­ ê°’ì´ ê°™ì„ ë•Œ value = 0; // í•œ ë²ˆì— í•œ ë²ˆë§Œ í•©ì¹˜ë„ë¡ 0ìœ¼ë¡œ ì´ˆê¸°í™” board[i][value_idx] *= 2; answer = max(answer, board[i][value_idx]); board[i][j] = 0; zero.push(j); &#125; else if (board[i][j] != 0) &#123; value_idx = j; value = board[i][j]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[i][j] = 0; board[i][zero_idx] = value; zero.push(j); value_idx = zero_idx; // ë³€ê²½ &#125; &#125; //printf(\"%d-%dë²ˆì¬: \\n\", i, j); //for (int i = 0; i &lt; n; ++i) &#123; // for (int j = 0; j &lt; n; ++j) &#123; // printf(\"%d \", board[i][j]); // &#125; // printf(\"\\n\"); //&#125;&#125;void updateRow(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[j][i] == 0) &#123; // 0ì˜ ìœ„ì¹˜ zero.push(j); &#125; else if (board[j][i] != 0 &amp;&amp; board[j][i] == value) &#123; // ë¸”ëŸ­ ê°’ì´ ê°™ì„ ë•Œ value = 0; // í•œ ë²ˆì— í•œ ë²ˆë§Œ í•©ì¹˜ë„ë¡ 0ìœ¼ë¡œ ì´ˆê¸°í™” board[value_idx][i] *= 2; answer = max(answer, board[value_idx][i]); board[j][i] = 0; zero.push(j); &#125; else if (board[j][i] != 0) &#123; value_idx = j; value = board[j][i]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[j][i] = 0; board[zero_idx][i] = value; zero.push(j); value_idx = zero_idx; // ë³€ê²½ &#125; &#125;&#125;void moveBlock(int move) &#123; for (int i = 0; i &lt; n; ++i) &#123; queue&lt;int&gt; zero; value = 0; value_idx = 0; zero_idx = 0; if (move % 2 == 0) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (move == 0) &#123; updateRow(i, j, zero); &#125; else &#123; updateCol(i, j, zero); &#125; &#125; &#125; else &#123; for (int j = n-1; j &gt;= 0; --j) &#123; if (move == 1) &#123; updateRow(i, j, zero); &#125; else &#123; updateCol(i, j, zero); &#125; &#125; &#125; &#125;&#125;void dfs(int idx) &#123; if (idx == 5) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; board[i][j] = temp[i][j]; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; moveBlock(direction[i]); &#125; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; direction[idx] = i; dfs(idx+1); &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;temp[i][j]); &#125; &#125; //dfs(0); direction[0] = 3; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; board[i][j] = temp[i][j]; &#125; &#125; moveBlock(direction[0]) printf(\"\\n\"); printf(\"%d\\n\", answer); return 0;&#125; 2 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define MAX 20using namespace std;int n, value, value_idx, zero_idx, answer = 2;int board[MAX][MAX];int temp[MAX][MAX];int direction[5]; // ë°©í–¥ ì¡°í•© 0:ìƒ, 1:í•˜, 2:ì¢Œ, 3:ìš°void updateCol(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[i][j] == 0) &#123; // 0ì˜ ìœ„ì¹˜ zero.push(j); &#125; else if (board[i][j] != 0 &amp;&amp; board[i][j] == value) &#123; // ë¸”ëŸ­ ê°’ì´ ê°™ì„ ë•Œ value = 0; // í•œ ë²ˆì— í•œ ë²ˆë§Œ í•©ì¹˜ë„ë¡ 0ìœ¼ë¡œ ì´ˆê¸°í™” board[i][value_idx] *= 2; answer = max(answer, board[i][value_idx]); board[i][j] = 0; zero.push(j); &#125; else if (board[i][j] != 0) &#123; value_idx = j; value = board[i][j]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[i][j] = 0; board[i][zero_idx] = value; zero.push(j); value_idx = zero_idx; // ë³€ê²½ &#125; &#125;&#125;void updateRow(int i, int j, queue&lt;int&gt; &amp;zero) &#123; if (board[j][i] == 0) &#123; // 0ì˜ ìœ„ì¹˜ zero.push(j); &#125; else if (board[j][i] != 0 &amp;&amp; board[j][i] == value) &#123; // ë¸”ëŸ­ ê°’ì´ ê°™ì„ ë•Œ value = 0; // í•œ ë²ˆì— í•œ ë²ˆë§Œ í•©ì¹˜ë„ë¡ 0ìœ¼ë¡œ ì´ˆê¸°í™” board[value_idx][i] *= 2; answer = max(answer, board[value_idx][i]); board[j][i] = 0; zero.push(j); &#125; else if (board[j][i] != 0) &#123; value_idx = j; value = board[j][i]; answer = max(answer, value); if (!zero.empty()) &#123; zero_idx = zero.front(); zero.pop(); board[j][i] = 0; board[zero_idx][i] = value; zero.push(j); value_idx = zero_idx; // ë³€ê²½ &#125; &#125;&#125;void moveBlock(int move) &#123; for (int i = 0; i &lt; n; ++i) &#123; queue&lt;int&gt; zero; value = 0; value_idx = 0; zero_idx = 0; if (move % 2 == 0) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (move == 0) &#123; updateRow(i, j, zero); &#125; else &#123; updateCol(i, j, zero); &#125; &#125; &#125; else &#123; for (int j = n-1; j &gt;= 0; --j) &#123; if (move == 1) &#123; updateRow(i, j, zero); &#125; else &#123; updateCol(i, j, zero); &#125; &#125; &#125; &#125;&#125;void dfs(int idx) &#123; if (idx == 5) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; board[i][j] = temp[i][j]; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; moveBlock(direction[i]); &#125; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; direction[idx] = i; dfs(idx+1); &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;temp[i][j]); &#125; &#125; dfs(0); printf(\"%d\\n\", answer); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 11729ë²ˆ í•˜ë…¸ì´ íƒ‘ ì´ë™ ìˆœì„œ","slug":"Algorithm/BOJ/11729","date":"2020-01-25T08:02:10.000Z","updated":"2020-01-25T12:47:56.227Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/11729/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/11729/","excerpt":"","text":"#11729. í•˜ë…¸ì´ íƒ‘ ì´ë™ ìˆœì„œProblem Nê°œì˜ ì›íŒ ì²« ë²ˆì§¸ ì¥ëŒ€ â†’ ì„¸ ë²ˆì§¸ ì¥ëŒ€ í•œ ë²ˆì— í•œ ê°œì˜ ì›íŒë§Œ ë‹¤ë¥¸ íƒ‘ìœ¼ë¡œ ì´ë™ ê°€ëŠ¥ ì›íŒ ìœ„ &lt; ì›íŒ ì•„ë˜ ì›íŒ ì´ë™ ìˆœì„œ ìµœì†Œí™” Solutionêµ³ì´ ì´ë¥¼ ìµœì†Œí™”ì‹œí‚¤ëŠ” ë°©ë²•ì„ ìƒê°í•˜ê¸°ë³´ë‹¤ ì»´í“¨í„°ê°€ ì•Œì•„ì„œ ìµœì†Œì˜ ë°©ë²•ì„ ê³„ì‚°í•˜ë„ë¡ í•˜ì. â†’ í•˜ë…¸ì´ íƒ‘ë„ ì•Œê³ ë¦¬ì¦˜ì´ ì¡´ì¬ ë¨¼ì € í•˜ë‚˜ì˜ ì›íŒë§Œ ìˆì„ ë•Œë¥¼ ìƒê°í•´ë³´ì ë³´ì¡° ê¸°ë‘¥ í•„ìš”ì—†ì´ ë°”ë¡œ ëª©í‘œ ê¸°ë‘¥ìœ¼ë¡œ ì´ë™í•˜ë©´ ëœë‹¤.1234567// recursive framevoid move(ì›ë°˜ ê°œìˆ˜, ì‹œì‘, ë³´ì¡°, ëª©í‘œ) &#123; &#125;if(ì›ë°˜ì˜ ê°œìˆ˜ == 1) &#123; ì‹œì‘-&gt;ëª©í‘œ return;&#125;ì›ë°˜ì˜ ê°œìˆ˜ê°€ 1ë³´ë‹¤ í´ë•ŒëŠ” ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œ? ê°€ì¥ í° ì›ë°˜ì„ ì œì™¸í•œ ëª¨ë“  ì›ë°˜ì´ ë³´ì¡° ê¸°ë‘¥ì— ìˆì–´ì•¼ í•œë‹¤. â†’ ì´ê²Œ í¬ì¸íŠ¸ 12// ë§¨ ì•„ë˜ì— ìˆëŠ” ì›ë°˜ì„ ì œì™¸í•œ ëª¨ë“  ì›ë°˜ì„ ë³´ì¡° ê¸°ë‘¥ìœ¼ë¡œ ì˜®ê¸´ë‹¤.move(ì›ë°˜ê°œìˆ˜-1, ì‹œì‘, ëª©í‘œ, ë³´ì¡°); // ì‹œì‘ -&gt; ë³´ì¡°ê·¸ëŸ¬ë©´ ê°€ì¥ í° ì›ë°˜ì€ ì´ ë¶€ë¶„ì´ ì ìš©ëœë‹¤.1234if(ì›ë°˜ì˜ ê°œìˆ˜ == 1) &#123; ì‹œì‘-&gt;ëª©í‘œ return;&#125;ê°€ì¥ í° ì›ë°˜ì´ ëª©í‘œ ê¸°ë‘¥ìœ¼ë¡œ ì´ë™í•˜ì˜€ê³ , ì´ì œ ì´ ì›ë°˜ì€ ì—†ëŠ” ê²ƒìœ¼ë¡œ ë³´ì•„ë„ ë¬´ë°©í•˜ë‹¤. ë‚˜ë¨¸ì§€ ì›ë°˜ë“¤ì´ ëª¨ë“  ê¸°ë‘¥ì„ ì´ë™í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤. ê·¸ëŸ¬ë©´ ì´ì œ ë‹¤ì‹œ n-1ê°œì˜ ì›ë°˜ì„ ê°€ì§€ê³  ìœ„ì™€ ê°™ì€ ì‘ì—…ì„ ì§„í–‰í•œë‹¤.ì´ë•ŒëŠ” ì›ë˜ ë³´ì¡° ê¸°ë‘¥ì„ ì‹œì‘ ê¸°ë‘¥ìœ¼ë¡œ, ì‹œì‘ ê¸°ë‘¥ì„ ë³´ì¡° ê¸°ë‘¥ìœ¼ë¡œ ìƒê°í•´ì•¼ í•œë‹¤. 1move(ì›ë°˜ê°œìˆ˜-1, ë³´ì¡°, ì‹œì‘, ëª©í‘œ);Recursive frameì˜ ë‚´ìš©ì„ ì™„ì„±í•´ë³´ì.123456789void move(int count, int start, int temp, int goal) &#123; if(count == 1) &#123; // start -&gt; goal return; &#125; move(count-1, start, goal, temp); // start-&gt;temp // start -&gt; goal move(count-1, temp, start, goal); // temp-&gt;goal&#125;ì£¼ì„ìœ¼ë¡œ ë˜ì–´ ìˆëŠ” ë¶€ë¶„ì€ ì‹¤ì§ˆì ìœ¼ë¡œ ì–´ë–¤ ê¸°ë‘¥ì—ì„œ ì–´ë–¤ ê¸°ë‘¥ìœ¼ë¡œ ì›ë°˜ì´ ì›€ì§ì˜€ëŠ”ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¶€ë¶„ì´ë‹¤. ì¢€ ë” ê¹Šì€ ì´í•´ë¥¼ ìœ„í•´ ì›ë°˜ì˜ ê°œìˆ˜ê°€ 3ê°œì¼ ë•Œ ì¬ê·€í•¨ìˆ˜ í˜¸ì¶œ ìˆœì„œë¥¼ ì‘ì„±í•˜ì˜€ë‹¤.1234567891011121314move(3, 1, 2, 3) move(2, 1, 3, 2) // 1, 2ë²ˆ ì›ë°˜ì´ 2ë²ˆ ê¸°ë‘¥ìœ¼ë¡œ ê°€ëŠ” ê³¼ì • move(1, 1, 2, 3) 1ì—ì„œ 3ìœ¼ë¡œ ì´ë™ (1ë²ˆ ì›ë°˜) 1ì—ì„œ 2ë¡œ ì´ë™ (2ë²ˆ ì›ë°˜) move(1, 3, 1, 2) 3ì—ì„œ 2ë¡œ ì´ë™(1ë²ˆ ì›ë°˜) 1ì—ì„œ 3ìœ¼ë¡œ ì´ë™(3ë²ˆ ì›ë°˜) move(2, 2, 1, 3) // 1, 2ë²ˆ ì›ë°˜ì´ 3ë²ˆ ê¸°ë‘¥ìœ¼ë¡œ ê°€ëŠ” ê³¼ì • move(1, 2, 3, 1) 2ì—ì„œ 1ë¡œ ì´ë™(1ë²ˆ ì›ë°˜) 2ì—ì„œ 3ìœ¼ë¡œ ì´ë™(2ë²ˆ ì›ë°˜) move(1, 1, 2, 3) 1ì—ì„œ 3ìœ¼ë¡œ ì´ë™ (1ë²ˆ ì›ë°˜) ì „ì²´ ì½”ë“œ123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; answer;void move(int count, int start, int temp, int goal) &#123; if(count == 1) &#123; answer.push_back(make_pair(start, goal)); return; &#125; move(count-1, start, goal, temp); // start-&gt;temp answer.push_back(make_pair(start, goal)); move(count-1, temp, start, goal); // temp-&gt;goal&#125;int main() &#123; int n; cin &gt;&gt; n; move(n, 1, 2, 3); cout &lt;&lt; answer.size() &lt;&lt; \"\\n\"; for(auto v : answer) &#123; cout &lt;&lt; v.first &lt;&lt; \" \" &lt;&lt; v.second &lt;&lt; \"\\n\"; &#125; return 0;&#125; ì´ë™ íšŸìˆ˜ë¶€í„° ì¶œë ¥í•´ì•¼ í•˜ë¯€ë¡œ, pairë¥¼ ë§Œë“¤ì–´ vectorì— ë„£ì–´ì£¼ì—ˆë‹¤.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 11651ë²ˆ ì¢Œí‘œ ì •ë ¬í•˜ê¸° 2","slug":"Algorithm/BOJ/11651","date":"2020-01-25T08:02:05.000Z","updated":"2020-01-25T12:42:24.520Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/11651/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/11651/","excerpt":"","text":"#11651. ì¢Œí‘œ ì •ë ¬í•˜ê¸° 2Problem 2ì°¨ì› í‰ë©´ ìœ„ì˜ ì  Nê°œ yì¢Œí‘œ ì¦ê°€ ìˆœìœ¼ë¡œ ì •ë ¬ ê°™ë‹¤ë©´ xì¢Œí‘œ ì¦ê°€ ìˆœìœ¼ë¡œ ì •ë ¬ ì¦‰, yì¢Œí‘œ ì˜¤ë¦„ì°¨ìˆœ(ê°™ë‹¤ë©´ xì¢Œí‘œ ì˜¤ë¦„ì°¨ìˆœ)ìœ¼ë¡œ ì •ë ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤. Solution 2ì°¨ì› vectorì— (y, x)ë¥¼ ë‹´ëŠ”ë‹¤. â†’ ì •ë ¬ ë•Œë¬¸ sortí•¨ìˆ˜ë¥¼ ì‚¬ìš© (ìœ„ ë¬¸ì œ ì¡°ê±´ì²˜ëŸ¼ ì •ë ¬ëœë‹¤.) ì¶œë ¥ì€ ê±°ê¾¸ë¡œ í•œë‹¤. iostream í—¤ë” íŒŒì¼ì˜ cinê³¼ coutì„ ì“°ë©´ ì‹œê°„ì´ˆê³¼ ë˜ê¸°ì— cstdioë¥¼ ì‚¬ìš©í•˜ì˜€ë‹¤.1234567891011121314151617181920212223#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; positions;int main() &#123; int n, x, y; scanf(\" %d\", &amp;n); positions.resize(n); for(int i = 0; i &lt; n; ++i) &#123; scanf(\" %d %d\", &amp;x, &amp;y); positions[i].push_back(y); positions[i].push_back(x); &#125; sort(positions.begin(), positions.end()); for(auto v : positions) &#123; for(int i = v.size()-1; i &gt;= 0; --i) &#123; printf(\"%d \", v[i]); &#125; printf(\"\\n\"); &#125; return 0;&#125; 92msê°€ ìƒë‹¹íˆ ë¹ ë¥¸ ê²ƒì€ ì•„ë‹ˆê¸°ì— ë‹¤ë¥¸ ìµœì ì˜ ì •ë ¬ ë°©ë²•ì´ ìˆì„ì§€ë„ ëª¨ë¥¸ë‹¤.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 11650ë²ˆ ì¢Œí‘œ ì •ë ¬í•˜ê¸°","slug":"Algorithm/BOJ/11650","date":"2020-01-25T08:01:58.000Z","updated":"2020-01-25T12:33:43.318Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/11650/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/11650/","excerpt":"","text":"#11650. ì¢Œí‘œ ì •ë ¬í•˜ê¸°ë¬¸ì œë§í¬ Problem 2ì°¨ì› í‰ë©´ (x, y) x ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ xê°€ ê°™ë‹¤ë©´ y ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ Solution ë¥¼ pairë¥¼ ì‚¬ìš©í•˜ì—¬ ì €ì¥í•œë‹¤. pairë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ë ¬í•˜ë©´ ìœ„ ë¬¸ì œì˜ ì¡°ê±´ëŒ€ë¡œ ì •ë ¬ëœë‹¤. 1 Try12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n, x, y; vector&lt;pair&lt;int, int&gt; &gt; answer; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; answer.push_back(make_pair(x, y)); &#125; sort(answer.begin(), answer.end()); for(auto ans : answer) &#123; cout &lt;&lt; ans.first &lt;&lt; \" \" &lt;&lt; ans.second &lt;&lt; '\\n'; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 11559ë²ˆ Puyo Puyo","slug":"Algorithm/BOJ/11559","date":"2020-01-25T04:30:32.000Z","updated":"2020-01-25T08:58:11.135Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/11559/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/11559/","excerpt":"","text":"#11559. Puyo Puyoë¬¸ì œë§í¬ Problem ë¿Œìš”ëŠ” ë°”ë‹¥ì´ë‚˜ ë‹¤ë¥¸ ë¿Œìš”ê°€ ìˆì„ ë•Œê¹Œì§€ ì•„ë˜ë¡œ ë–¨ì–´ì§ ë¿Œìš”ê°€ ë†“ì—¬ì§€ê³  ê°™ì€ ìƒ‰ ë¿Œìš”ê°€ 4ê°œ ì´ìƒ ìƒí•˜ì¢Œìš°ë¡œ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ì—°ê²°ëœ ê°™ì€ ìƒ‰ ë¿Œìš”ë“¤ì´ ëª¨ë‘ ì‚¬ë¼ì§„ë‹¤. ìœ„ ê³¼ì •ì´ ë°˜ë³µë˜ë©´ 1ì—°ì‡„ì”© ëŠ˜ì–´ë‚œë‹¤. (í„°ì§€ëŠ” ê·¸ë£¹ì´ ë™ì‹œì— ì—¬ëŸ¿ì´ë¼ë„ 1ì—°ì‡„) ì…ë ¥ 12*6ì˜ ë¬¸ì .ì€ ë¹ˆê³µê°„ ì´ì™¸ ë¿Œìš” ìƒ‰ê¹” R, G, B, P, Y ë¿Œìš”ë“¤ì´ ì „ë¶€ ì•„ë˜ë¡œ ë–¨ì–´ì§„ ë’¤ì˜ ìƒíƒœê°€ ì£¼ì–´ì§ Goal: ëª‡ ì—°ì‡„ê°€ ë˜ëŠ”ì§€ ì¶œë ¥, ì•ˆí„°ì§€ë©´ 0 ì¶œë ¥ Solutionë‹¤ìŒê³¼ ê°™ì€ ê³¼ì •ì´ ì¼ì–´ë‚œë‹¤. í˜„ì¬ mapì—ì„œ í„°ëœ¨ë¦´ ìˆ˜ ìˆëŠ” ê²ƒë“¤ í„°ëœ¨ë¦¬ê¸° ì•„ë˜ë¡œ ë–¨ì–´ëœ¨ë¦¬ê¸° ìœ„ ê³¼ì • ë°˜ë³µí•˜ê¸°(ë”ì´ìƒ í„°ëœ¨ë¦´ ìˆ˜ ì—†ëŠ” ê²½ìš° ì¢…ë£Œ) í„°ëœ¨ë¦¬ê¸° BFSë¥¼ í™œìš©í•˜ì—¬ 4ê°œ ì´ìƒ ì—°ì†ì¸ì§€ í™•ì¸ì„ í•œë‹¤. void bfs(í˜„ì¬ ìœ„ì¹˜) íƒìƒ‰ìš©ë„ queueì™€ ì§€ìš¸(í„°ëœ¨ë¦´)ìš©ë„ queue ì„ ì–¸ í˜„ì¬ ìœ„ì¹˜ ë„£ì–´ì£¼ê³ , check íƒìƒ‰ìš©ë„ queueë¥¼ ì „ë¶€ ë¹„ìš¸ ë•Œê¹Œì§€ íƒìƒ‰ íƒìƒ‰ì´ ëë‚˜ë©´(ë”ì´ìƒ ê°ˆ ë•Œê°€ ì—†ëŠ” ê²ƒ) ì§€ìš¸ ìš©ë„ì˜ queue í¬ê¸°ê°€ 4ì´ìƒì´ë©´ í„°ëœ¨ë¦¬ê¸° bfs íƒìƒ‰ì´ ëë‚˜ë©´ ë‹¤ìŒê³¼ ê°™ì´ 4ê°œ ì—°ì†ì¸ ê²ƒë“¤ í„°ëœ¨ë¦¬ê¸° 12345678void changeMap(queue&lt;pair&lt;int, int&gt;&gt; &amp;erase) &#123; while (!erase.empty()) &#123; int r = erase.front().first; int c = erase.front().second; erase.pop(); map[r][c] = '.'; &#125;&#125; ì´ ê³¼ì •ì´ ëª¨ë“  mapì˜ ê° í–‰ê³¼ ì—´ì—ì„œ ì´ë£¨ì–´ì§€ë©´ ê·¸ë•Œ ì•„ë˜ë¡œ ë–¨ì–´ëœ¨ë¦°ë‹¤.(ëª¨ë“  ìœ„ì¹˜ì—ì„œ BFSíƒìƒ‰ì´ ëë‚œ ê²½ìš°) ì•„ë˜ë¡œ ë–¨ì–´ëœ¨ë¦¬ê¸° Queueë¥¼ ì´ìš©í•˜ì—¬ ë§¨ ì•„ë˜ì—ì„œ ë¶€í„° ìœ„ë¡œ íƒìƒ‰ì„ ì‹œì‘í•˜ì—¬ . ì¸ ì§€ì ì„ ìˆœì„œëŒ€ë¡œ ë„£ì–´ì¤€ë‹¤. . ì´ ì•„ë‹ˆë¼ë©´ queueì— ë“¤ì–´ê°„ ìˆœì„œëŒ€ë¡œ ìœ„ì¹˜ë¥¼ êµí™˜í•œë‹¤.1234567891011121314151617void update() &#123; for (int i = 0; i &lt; 6; ++i) &#123; queue&lt;pair&lt;int, int&gt;&gt; point; for (int j = 11; j &gt;= 0; --j) &#123; if (map[j][i] == '.') point.push(&#123; j, i &#125;); else &#123; if (point.empty()) continue; int x = point.front().first; int y = point.front().second; point.pop(); map[x][y] = map[j][i]; map[j][i] = '.'; point.push(&#123; j, i &#125;); &#125; &#125; &#125;&#125; 1 Try í‹€ë¦° ì½”ë“œ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;char map[12][6];bool check[12][6];int answer, len;bool flag, loop = true;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; 12 &amp;&amp; c &lt; 6) return true; return false;&#125;void update() &#123; for (int i = 0; i &lt; 6; ++i) &#123; queue&lt;pair&lt;int, int&gt;&gt; point; for (int j = 11; j &gt;= 0; --j) &#123; if (map[j][i] == '.') point.push(&#123; j, i &#125;); else &#123; if (point.empty()) continue; int x = point.front().first; int y = point.front().second; point.pop(); map[x][y] = map[j][i]; map[j][i] = '.'; point.push(&#123; j, i &#125;); &#125; &#125; &#125;&#125;void changeMap(queue&lt;pair&lt;int, int&gt;&gt; erase) &#123; while (!erase.empty()) &#123; int r = erase.front().first; int c = erase.front().second; erase.pop(); map[r][c] = '.'; &#125;&#125;void dfs(int r, int c, queue&lt;pair&lt;int, int&gt;&gt; erase) &#123; check[r][c] = true; erase.push(&#123; r, c &#125;); bool flag = false; for (int i = 0; i &lt; 4; ++i) &#123; int x = r + dx[i]; int y = c + dy[i]; if (isBound(x, y) &amp;&amp; !check[x][y] &amp;&amp; map[x][y] == map[r][c] &amp;&amp; map[r][c] != '.') &#123; check[x][y] = true; flag = true; erase.push(&#123; x, y &#125;); len++; dfs(x, y, erase); &#125; &#125; if (!flag &amp;&amp; len &gt;= 4) &#123; loop = true; changeMap(erase); &#125;&#125;int main() &#123; for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; scanf(\" %c\", &amp;map[i][j]); &#125; &#125; queue&lt;pair&lt;int, int&gt;&gt; erase; while (loop) &#123; loop = false; memset(check, 0, sizeof(check)); for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; if (map[i][j] != '.' &amp;&amp; !check[i][j]) &#123; len = 1; dfs(i, j, erase); &#125; &#125; &#125; if (loop) &#123; update(); answer++; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; DFSë¡œ í•˜ë‹ˆê¹Œ mapì—ì„œ ì—°ì†ì¸ ê²ƒë“¤ì„ ì œëŒ€ë¡œ ì§€ìš°ì§€ ëª» í•œë‹¤ëŠ” ê²ƒì„ ê¹¨ë‹«ê³ (ì‹¤ì œ ê°’ í™•ì¸í•´ë³´ë©´ erase queueì— ì—°ì†ì ìœ¼ë¡œ ëª» ë„£ê³  returní•˜ê²Œ ë¨) BFSë¥¼ ì‚¬ìš©í•˜ì—¬ ì‰½ê²Œ í’€ì—ˆë‹¤..(ì§„ì‘ì— í• ê±¸) 2 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;char map[12][6];bool check[12][6];bool loop = true;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; 12 &amp;&amp; c &lt; 6) return true; return false;&#125;void update() &#123; for (int i = 0; i &lt; 6; ++i) &#123; queue&lt;pair&lt;int, int&gt;&gt; point; for (int j = 11; j &gt;= 0; --j) &#123; if (map[j][i] == '.') point.push(&#123; j, i &#125;); else &#123; if (point.empty()) continue; int x = point.front().first; int y = point.front().second; point.pop(); map[x][y] = map[j][i]; map[j][i] = '.'; point.push(&#123; j, i &#125;); &#125; &#125; &#125;&#125;void changeMap(queue&lt;pair&lt;int, int&gt;&gt; &amp;erase) &#123; while (!erase.empty()) &#123; int r = erase.front().first; int c = erase.front().second; erase.pop(); map[r][c] = '.'; &#125;&#125;void bfs(int r, int c)&#123; queue&lt;pair&lt;int, int&gt;&gt; q, erase; q.push(&#123; r, c &#125;); erase.push(&#123; r, c &#125;); check[r][c] = true; while (!q.empty()) &#123; int length = q.size(); for (int i = 0; i &lt; length; ++i) &#123; r = q.front().first; c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; !check[x][y] &amp;&amp; map[x][y] == map[r][c] &amp;&amp; map[x][y] != '.') &#123; check[x][y] = true; q.push(&#123; x, y &#125;); erase.push(&#123; x, y &#125;); &#125; &#125; &#125; &#125; if (erase.size() &gt;= 4) &#123; loop = true; changeMap(erase); &#125;&#125;int main() &#123; for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; scanf(\" %c\", &amp;map[i][j]); &#125; &#125; int answer = 0; while (loop) &#123; loop = false; memset(check, 0, sizeof(check)); for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; if (map[i][j] != '.' &amp;&amp; !check[i][j]) &#123; bfs(i, j); &#125; &#125; &#125; if (loop) &#123; update(); answer++; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; Debug ë””ë²„ê¹…ìš© ì½”ë“œ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;char map[12][6];bool check[12][6];int answer;bool loop = true;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; 12 &amp;&amp; c &lt; 6) return true; return false;&#125;void update() &#123; for (int i = 0; i &lt; 6; ++i) &#123; queue&lt;pair&lt;int, int&gt;&gt; point; for (int j = 11; j &gt;= 0; --j) &#123; if (map[j][i] == '.') point.push(&#123; j, i &#125;); else &#123; if (point.empty()) continue; int x = point.front().first; int y = point.front().second; point.pop(); map[x][y] = map[j][i]; map[j][i] = '.'; point.push(&#123; j, i &#125;); &#125; &#125; &#125; /*printf(\"start\\n\"); for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; printf(\"%c\", map[i][j]); &#125; printf(\"\\n\"); &#125;*/&#125;void changeMap(queue&lt;pair&lt;int, int&gt;&gt; &amp;erase) &#123; //printf(\"erase\\n\"); while (!erase.empty()) &#123; int r = erase.front().first; int c = erase.front().second; //printf(\"%d %d\\n\", r, c); erase.pop(); map[r][c] = '.'; &#125;&#125;void bfs(int r, int c)&#123; queue&lt;pair&lt;int, int&gt;&gt; q, erase; q.push(&#123; r, c &#125;); erase.push(&#123; r, c &#125;); check[r][c] = true; while (!q.empty()) &#123; int length = q.size(); for (int i = 0; i &lt; length; ++i) &#123; r = q.front().first; c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; !check[x][y] &amp;&amp; map[x][y] == map[r][c] &amp;&amp; map[x][y] != '.') &#123; check[x][y] = true; q.push(&#123; x, y &#125;); erase.push(&#123; x, y &#125;); &#125; &#125; &#125; &#125; if (erase.size() &gt;= 4) &#123; loop = true; changeMap(erase); &#125;&#125;int main() &#123; for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; scanf(\" %c\", &amp;map[i][j]); &#125; &#125; while (loop) &#123; loop = false; memset(check, 0, sizeof(check)); for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; if (map[i][j] != '.' &amp;&amp; !check[i][j]) &#123; bfs(i, j); &#125; &#125; &#125; if (loop) &#123; update(); answer++; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; ë””ë²„ê¹…ìš© Test case 1. output : 14Y..... B..... R.R... G.R... YG.... YBR..Y RR...Y YYRBRB YRBGBB GBRBGR GBRBGR GBRBGR 2. output : 1...... ...... ...... ...... ...... ...... ...... ...... R..... ...... RRYYGG RRYYGG 3. output: 2...... ..R... ..R.GG ...GG. ..R... ...... ..R... ...... R..... ....G. RRY..G RRYYGG","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 11047ë²ˆ ë™ì „ 0","slug":"Algorithm/BOJ/11047","date":"2020-01-25T04:23:59.000Z","updated":"2020-01-25T08:58:11.151Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/11047/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/11047/","excerpt":"","text":"#11047. ë™ì „ 0ë¬¸ì œë§í¬ Problem ë™ì „ì˜ ì¢…ë¥˜ N ë™ì „ì„ ì ì ˆíˆ ì‚¬ìš©í•´ í•©ì„ Kë¡œ ë§Œë“œë ¤ê³  í•œë‹¤. Goal: Kë¥¼ ë§Œë“œëŠ”ë° í•„ìš”í•œ ë™ì „ ê°œìˆ˜ì˜ ìµœì†Ÿê°’ êµ¬í•˜ê¸° Solution ë™ì „ì˜ ê°€ì¹˜ëŠ” ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì£¼ì–´ì§€ê³ ì´ì „ ê°€ì¹˜ë³´ë‹¤ í•­ìƒ ëª‡ ë°° ë” í¬ë‹¤. 4200 1000 4 100 2 6ê°œ 4790 4000 4 790 500 1 290 100 2 90 50 1 40 10 * 4 12ê°œ 12 1, 3, 4, 5 5 2 2 1 2 4ê°œ í•˜ì§€ë§Œ 4 * 3 3ê°œ ìœ„ì™€ ê°™ì€ ìƒí™©ì´ ì¼ì–´ë‚ ê¹Œ?ë™ì „ì˜ ê°€ì¹˜ê°€ ì´ì „ ê°€ì¹˜ì˜ ë°°ìˆ˜ì´ê¸°ì— ì¼ì–´ë‚  ìˆ˜ ì—†ì„ ê²ƒì´ë‹¤. 1 Try123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; costs;int main()&#123; int i, n, goal, answer = 0; cin &gt;&gt; n &gt;&gt; goal; costs.resize(n); for(i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; costs[i]; &#125; while(goal != 0) &#123; if(goal &gt;= costs[i-1]) &#123; goal -= costs[i-1]; answer++; &#125; else i--; &#125; cout &lt;&lt; answer &lt;&lt; '\\n'; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 10989ë²ˆ ìˆ˜ ì •ë ¬í•˜ê¸° 3","slug":"Algorithm/BOJ/10989","date":"2020-01-25T04:21:51.000Z","updated":"2020-01-25T08:58:11.156Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/10989/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/10989/","excerpt":"","text":"#10989. ìˆ˜ ì •ë ¬í•˜ê¸° 3ë¬¸ì œë§í¬ Problem ì‹œê°„ ì œí•œ 3ì´ˆ ë©”ëª¨ë¦¬ ì œí•œ 8MB Goal : ì£¼ì–´ì§„ ìˆ˜ë¥¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê¸° Solution ë©”ëª¨ë¦¬ ì œí•œì´ 8MBë¼ëŠ” ì ì— ì£¼ì˜í•œë‹¤. ì£¼ì–´ì§„ ìˆ˜ëŠ” ìµœëŒ€ ì²œë§Œìˆ˜ì˜ ìµœëŒ“ê°’ì€ ìµœëŒ€ ë§Œ int í˜• ë°°ì—´ì„ ì²œë§Œê°œ í¬ê¸°ë¡œ ë§Œë“¤ë©´10000000 * 4 = 4ì²œë§Œ byte = 38â€¦MB(ì´ë¯¸ ì´ˆê³¼ í•˜ì§€ë§Œ 10001 í¬ê¸°ì˜ ë°°ì—´ë§Œìœ¼ë¡œ ë¬¸ì œë¥¼ í’€ ìˆ˜ ìˆë‹¤.40004 = 0.038..MB(ì¶©ë¶„íˆ í†µê³¼) ìœ„ì˜ í¬ê¸°ë§Œ ê°€ì§€ê³  ë¬¸ì œë¥¼ í‘¸ë ¤ë©´ counting sortê°€ ì ì ˆí•˜ë‹¤. ì…ë ¥ìœ¼ë¡œ ë°›ì€ ìˆ˜ë¥¼ ê°ê° ì„¸ì–´ì¤€ë‹¤. â†’ ë ??? ì§„ì§œ ëì´ë‹¤. ë‚¨ì€ê±´ í•´ë‹¹ ìˆ«ìë§Œí¼ ì°¨ë¡€ëŒ€ë¡œ ì¹´ìš´íŠ¸í•œ íšŸìˆ˜ë§Œí¼ ì¶œë ¥í•´ì£¼ë©´ ëœë‹¤. 1 Try12345678910111213141516171819#include &lt;cstdio&gt;#define MAX 10000using namespace std; // ì´ê±° ì•ˆì¨ë„ ëœë‹¤...int cnt[MAX+1];int main()&#123; int n, input; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;input); cnt[input]++; &#125; for(int i = 1; i &lt;= MAX; ++i) &#123; for(int j = 0; j &lt; cnt[i]; j++) &#123; printf(\"%d\\n\", i); &#125; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 10814ë²ˆ ë‚˜ì´ìˆœ ì •ë ¬","slug":"Algorithm/BOJ/10814","date":"2020-01-25T04:21:45.000Z","updated":"2020-01-25T08:58:11.129Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/10814/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/10814/","excerpt":"","text":"#10814. ë‚˜ì´ìˆœ ì •ë ¬ë¬¸ì œë§í¬ Problem ë‚˜ì´ì™€ ì´ë¦„ì´ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§„ë‹¤. ë‚˜ì´ìˆœìœ¼ë¡œ ì •ë ¬ ë‚˜ì´ê°€ ê°™ë‹¤ë©´ ê°€ì…í•œ ìˆœì„œë¡œ ì •ë ¬(ì…ë ¥ ìˆœìœ¼ë¡œ) Solution ìœ¼ë¡œ keyê°€ ì¤‘ë³µë  ìˆ˜ ìˆìœ¼ë‹ˆ multimapì„ ì‚¬ìš©í•œë‹¤. map ìì²´ê°€ keyê°€ ì˜¤ë¦„ì°¨ìˆœì„ ìœ ì§€í•˜ë„ë¡ dataë¥¼ ë„£ì–´ì¤€ë‹¤.ê°™ë‹¤ë©´ ì…ë ¥ìˆœìœ¼ë¡œ ëœë‹¤. 1 Try12345678910111213141516171819#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;int main()&#123; int n, age; string name; multimap&lt;int, string&gt; answer; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; age &gt;&gt; name; answer.insert(make_pair(age, name)); &#125; for(auto ans : answer) &#123; cout &lt;&lt; ans.first &lt;&lt; \" \" &lt;&lt; ans.second &lt;&lt; '\\n'; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 9019ë²ˆ DSLR","slug":"Algorithm/BOJ/9019","date":"2020-01-25T04:21:38.000Z","updated":"2020-01-25T08:58:11.154Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/9019/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/9019/","excerpt":"","text":"#9019. DSLRProblem ë¬¸ì œë§í¬ Solution ì´ ë¬¸ì œëŠ” ëª…ë ¹ì–´ â€˜Lâ€™ê³¼ â€˜Râ€™ì„ ì–´ë–»ê²Œ ìˆ˜í–‰í•˜ëŠëƒê°€ ì œì¼ ì¤‘ìš”í•˜ë‹¤. ì²˜ìŒì— dequeë¥¼ ì‚¬ìš©í•˜ì—¬ ìˆ«ìë¥¼ ë°°ì—´ë¡œ ë‚˜ëˆ„ê³  í•©ì¹˜ê³  ì´ëŸ¬ë‹¤ê°€ ì‹œê°„ì´ˆê³¼â€¦ ì‚¬ì‹¤ ì‚¬ì¹™ì—°ì‚°ë§Œ ì‚¬ìš©í•˜ë©´ ìœ„ ëª…ë ¹ì–´ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤. L ëª…ë ¹ì–´ Next = (Now % 1000 * 10) + (Now / 1000) R ëª…ë ¹ì–´ Next = (Now / 10) + (Now % 10 * 1000) ì£¼ì˜í•´ì•¼ í•  ì‚¬í•­ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ ì—¬ëŸ¬ ë²ˆ ìˆ˜í–‰í•˜ëŠ” ë¬¸ì œì´ë¯€ë¡œ ì´ˆê¸°í™”ê°€ í•„ìš”í•œ ë³€ìˆ˜ë‚˜ ë°°ì—´ì€ ì´ˆê¸°í™”ë¥¼ í•´ì¤˜ì•¼ í•œë‹¤. ëª…ë ¹ì–´ë¥¼ ì €ì¥í•˜ê³  ìˆì–´ì•¼ í•˜ë¯€ë¡œ, í•´ë‹¹ ìˆ«ìë¥¼ ì–´ë–»ê²Œ ë§Œë“¤ì—ˆëŠ”ì§€ ê²½ë¡œë¥¼ ì €ì¥í•  ë°°ì—´ì„, ê·¸ ìˆ«ìë¥¼ ë§Œë“¤ ë•Œ ì“´ ëª…ë ¹ì–´ê°€ ë¬´ì—‡ì¸ì§€ ì €ì¥í•  ë°°ì—´ì„ ë§Œë“ ë‹¤. from[a] = b aë¥¼ ë§Œë“¤ê¸° ì´ì „ ìˆ«ì b how[a] = &#39;b&#39; aë¥¼ ë§Œë“¤ ë•Œ ìˆ˜í–‰ëœ ëª…ë ¹ì–´ b 1 Try code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define MAX 10000using namespace std;char cmd[4] = &#123; 'D', 'S', 'L', 'R' &#125;;bool check[MAX];int from[MAX];char how[MAX];int A, B;void Init() &#123; memset(check, 0, sizeof(check));&#125;void PrintCmd(int a, int b) &#123; if (a != b) &#123; PrintCmd(a, from[b]); cout &lt;&lt; how[b]; &#125; &#125;void BFS() &#123; queue&lt;int&gt; q; q.push(A); check[A] = true; while (!q.empty()) &#123; int a = q.front(); q.pop(); if (a == B) &#123; PrintCmd(A, B); cout &lt;&lt; \"\\n\"; return; &#125; int d = a * 2 &gt; MAX - 1 ? a * 2 % MAX : a * 2; if (!check[d]) &#123; check[d] = true; how[d] = 'D'; from[d] = a; q.push(d); &#125; int s = a == 0 ? MAX - 1 : a - 1; if (!check[s]) &#123; check[s] = true; how[s] = 'D'; from[s] = a; q.push(s); &#125; int cur = a; deque&lt;int&gt; ld, rd; for (int i = 0, div = 1000; i &lt; 4; ++i, div /= 10) &#123; int num = cur / div; cur %= div; ld.push_back(num); rd.push_back(num); &#125; int tmp = ld.front(); ld.pop_front(); ld.push_back(tmp); tmp = rd.back(); rd.pop_back(); rd.push_front(tmp); int l = 0, r = 0; for (int i = 0, div = 1; i &lt; 4; ++i, div *= 10) &#123; l += ld.back() * div; r += rd.back() * div; ld.pop_back(); rd.pop_back(); &#125; if (!check[l]) &#123; check[l] = true; how[l] = 'L'; from[l] = a; q.push(l); &#125; if (!check[r]) &#123; check[r] = true; how[r] = 'R'; from[r] = a; q.push(r); &#125; &#125;&#125;int main() &#123; int T; cin &gt;&gt; T; for (int t = 0; t &lt; T; ++t) &#123; Init(); cin &gt;&gt; A &gt;&gt; B; BFS(); &#125; return 0;&#125; ì‹œê°„ì´ˆê³¼ 2 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define MAX 10000using namespace std;char cmd[4] = &#123; 'D', 'S', 'L', 'R' &#125;;bool check[MAX];int from[MAX];char how[MAX];int A, B;void Init() &#123; memset(check, 0, sizeof(check));&#125;void PrintCmd(int a, int b) &#123; if (a != b) &#123; PrintCmd(a, from[b]); cout &lt;&lt; how[b]; &#125; &#125;void BFS() &#123; queue&lt;int&gt; q; q.push(A); check[A] = true; while (!q.empty()) &#123; int a = q.front(); q.pop(); if (a == B) &#123; PrintCmd(A, B); cout &lt;&lt; \"\\n\"; return; &#125; int d = a * 2 % MAX; if (!check[d]) &#123; check[d] = true; how[d] = 'D'; from[d] = a; q.push(d); &#125; int s = a == 0 ? MAX - 1 : a - 1; if (!check[s]) &#123; check[s] = true; how[s] = 'S'; from[s] = a; q.push(s); &#125; int l = (a % 1000 * 10) + (a / 1000); if (!check[l]) &#123; check[l] = true; how[l] = 'L'; from[l] = a; q.push(l); &#125; int r = (a / 10) + (a % 10 * 1000); if (!check[r]) &#123; check[r] = true; how[r] = 'R'; from[r] = a; q.push(r); &#125; &#125;&#125;int main() &#123; int T; cin &gt;&gt; T; for (int t = 0; t &lt; T; ++t) &#123; Init(); cin &gt;&gt; A &gt;&gt; B; BFS(); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 3190ë²ˆ ë±€","slug":"Algorithm/BOJ/3190","date":"2020-01-25T04:21:13.000Z","updated":"2020-01-25T08:58:11.149Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/3190/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/3190/","excerpt":"","text":"#3190. ë±€ë¬¸ì œë§í¬ Problem N x N ë³´ë“œíŒ ì–‘ ë ëª¨ì„œë¦¬ì— ë²½ì´ ìˆìŒ ë±€ì˜ ê¸¸ì´ 1, ì‹œì‘ ìœ„ì¹˜ (1, 1), ë°©í–¥: â†’ ë§¤ ì´ˆë§ˆë‹¤ ì´ë™ ë¨¸ë¦¬ë¥¼ ë‹¤ìŒ ì¹¸ì— ìœ„ì¹˜ ì´ë™í•œ ì¹¸ì— ì‚¬ê³¼ê°€ ìˆìœ¼ë©´ ì‚¬ê³¼ ë¨¹ê³  ê¼¬ë¦¬ ì›€ì§ì´ì§€ ì•ŠìŒ(ëª¸ê¸¸ì´ ëŠ˜ì–´ë‚¨) ê¼¬ë¦¬ ì›€ì§ì¸ë‹¤. (ëª¸ê¸¸ì´ ê·¸ëŒ€ë¡œ) Goal: ì‚¬ê³¼ì˜ ìœ„ì¹˜ì™€ ë±€ì˜ ì´ë™ê²½ë¡œê°€ ì£¼ì–´ì§ˆ ë•Œ ê²Œì„ì´ ëª‡ ì´ˆë§Œì— ëë‚˜ëŠ”ì§€ ê³„ì‚° ê²Œì„ì€ ë²½ì´ë‚˜ ìê¸°ìì‹ ì˜ ëª¸ê³¼ ë¶€ë”ªíˆë©´ ëë‚œë‹¤. ë±€ì˜ ì´ë™ ê²½ë¡œëŠ” (ì™¼ìª½ ì˜¤ë¥¸ìª½ ìœ¼ë¡œ 90ë„ ë°©í–¥ íšŒì „) ì…ë ¥ ë°©í–¥ ë³€í™˜ ì •ë³´ì—ì„œ ì£¼ì–´ì§„ ì´ˆëŠ” ê²Œì„ ì‹œì‘ ì‹œê°„ìœ¼ë¡œë¶€í„° Xì´ˆê°€ ëë‚œ ë’¤ë¥¼ ë§í•œë‹¤. Solution ì£¼ì–´ì§„ ë¬¸ì œëŒ€ë¡œ êµ¬í˜„í•˜ë©´ ëœë‹¤. (ì‹œë®¬ë ˆì´ì…˜) ë°©í–¥ì „í™˜ ì‹œê°„ì€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì£¼ì–´ì§€ê¸°ì— queueì— ì €ì¥ ì‚¬ê³¼ê°€ ìˆëŠ” ê³³ì€ -1ë¡œ í‘œì‹œ ë±€ì´ ìˆëŠ” ê³³ì€ 1ë¶€í„°~í˜„ì¬ ê¸¸ì´ê¹Œì§€ í‘œì‹œ (ë¨¸ë¦¬ê°€ ê°€ì¥ í° ìˆ˜) ë¨¸ë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í˜„ì¬ ë°©í–¥ì— ë§ê²Œ ì›€ì§ì¸ë‹¤. ë¨¸ë¦¬ê°€ ì›€ì§ì˜€ì„ ë•Œ ê·¸ê³³ì´ ë²½ì´ê±°ë‚˜ ìì‹ ì˜ ëª¸ì¸ì§€ í™•ì¸í•œë‹¤.í•„ìëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš°ì— ë±€ì´ ë™ì‹œì— ì›€ì§ì¼ê±°ë¼ ìƒê°í•˜ì—¬ ê²Œì„ì´ ì•ˆëë‚œë‹¤ê³  ìƒê°í–ˆë‹¤. // 4ê°€ ë¨¸ë¦¬ì´ê³  ë¨¸ë¦¬ê°€ ìœ„ìª½ìœ¼ë¡œ ê°€ëŠ” ê²½ìš°ì¼ ë•Œ 1 2 -&gt; 4 1 4 3 3 2 í•˜ì§€ë§Œ ë™ì‹œì— ì›€ì§ì´ì§€ ì•Šê³  ë¨¸ë¦¬ë¶€í„° ì›€ì§ì—¬ì„œ ê¼¬ë¦¬ê°€ ë”°ë¼ì˜¨ë‹¤. ê·¸ë ‡ê¸°ì— ìœ„ì™€ ê°™ì€ ê²½ìš°ëŠ” ê²Œì„ì´ ì¢…ë£Œëœë‹¤. ë°©í–¥ ì „í™˜ ì‹œê°„ì¸ì§€ í™•ì¸í•œë‹¤.í•´ë‹¹ ê²½ìš°ì— ë§ê²Œ ë°©í–¥ì„ ë³€ê²½í•œë‹¤. ì‚¬ê³¼ê°€ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.ì‚¬ê³¼ê°€ ìˆìœ¼ë©´ ê¸¸ì´ê°€ 1 ëŠ˜ì–´ë‚˜ê³  ì´ë™í•˜ì§€ ì•ŠëŠ”ë‹¤. ì´ë™í•œë‹¤.ì´ë™ë°©ë²•: ë¨¸ë¦¬ì—ì„œë¶€í„° ì‹œì‘í•´ì„œ ìì‹ ë³´ë‹¤ 1 ì ì€ ìˆ˜ë¥¼ ì°¾ëŠ”ë‹¤. ì°¾ìœ¼ë©´ ê·¸ ê°’ì„ ë„£ëŠ”ë‹¤. ì´ë¥¼ ì´ ê¸¸ì´-1ë§Œí¼ ë°˜ë³µí•˜ê³ (ë¨¸ë¦¬ë¥¼ ì œì™¸í•˜ê¸° ë•Œë¬¸) ë‹¤ìŒ íƒìƒ‰ ë¶€ë¶„ì— ë¨¸ë¦¬ë¥¼, ì›ë˜ ê¼¬ë¦¬ ë¶€ë¶„ì„ 0ìœ¼ë¡œ ë³€ê²½í•´ì¤€ë‹¤. 1 2 3 4 â€”&gt; 1 1 2 3 â€”&gt; 0 1 2 3 5 4 5 4 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt; #include &lt;queue&gt;using namespace std;int n, k, l;int board[101][101];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;int d_left[4] = &#123; 2, 3, 1, 0 &#125;; // 'L'int d_right[4] = &#123; 3, 2, 0, 1 &#125;; // 'D'queue&lt;pair&lt;int, char&gt; &gt; direction;bool isWall(int x, int y) &#123; // ë²½ì´ë©´ true if (x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; n) return true; return false;&#125;bool isBound(int x, int y) &#123; if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &lt;= n) return true; return false;&#125;int game() &#123; int x = 1; int y = 1; // ì‹œì‘ìœ„ì¹˜ int dir = 3; // ì‹œì‘ë°©í–¥: ì˜¤ë¥¸ìª½ int len = 1; // ë±€ì˜ ê¸¸ì´ int time = 0; // ê²Œì„ ì‹œì‘ ì‹œê°„ board[x][y] = 1; while (true) &#123; int convert = 0; if (!direction.empty()) &#123; convert = direction.front().first; &#125; time++; // í˜„ì¬ ë°©í–¥ì— ë§ëŠ” í•œ ì¹¸ ì´ë™ int d_x = x + dx[dir]; int d_y = y + dy[dir]; // ë²½ì¸ì§€ ìì‹ ì˜ ëª¸ì¸ì§€ í™•ì¸ if (isWall(d_x, d_y) || board[d_x][d_y] &gt; 0) return time; // ë°©í–¥ ì „í™˜ ì‹œê°„ì¸ì§€ í™•ì¸ if (time == convert) &#123; if (direction.front().second == 'D') &#123; dir = d_right[dir]; &#125; else &#123; dir = d_left[dir]; &#125; direction.pop(); &#125; // ì‚¬ê³¼ ìˆëŠ”ì§€ í™•ì¸ if (board[d_x][d_y] == -1) &#123; board[d_x][d_y] = ++len; x = d_x; y = d_y; continue; &#125; // ì´ë™ int tmp_x = x, tmp_y = y; for (int i = 1; i &lt; len; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; int d_tmp_x = tmp_x + dx[j]; int d_tmp_y = tmp_y + dy[j]; if (isBound(d_tmp_x, d_tmp_y)) &#123; if (board[d_tmp_x][d_tmp_y] == board[tmp_x][tmp_y] - 1) &#123; board[tmp_x][tmp_y] = board[d_tmp_x][d_tmp_y]; tmp_x = d_tmp_x; tmp_y = d_tmp_y; break; &#125; &#125; &#125; &#125; board[d_x][d_y] = len; board[tmp_x][tmp_y] = 0; x = d_x; y = d_y; &#125;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;k); for (int i = 0; i &lt; k; ++i) &#123; int r, c; scanf(\"%d %d\", &amp;r, &amp;c); board[r][c] = -1; &#125; scanf(\"%d\", &amp;l); for (int i = 0; i &lt; l; ++i) &#123; int x; char dir; scanf(\"%d %c\", &amp;x, &amp;dir); direction.push(&#123; x, dir &#125;); &#125; printf(\"%d\\n\", game()); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 3055ë²ˆ íƒˆì¶œ","slug":"Algorithm/BOJ/3055","date":"2020-01-25T04:18:12.000Z","updated":"2020-01-25T08:58:11.137Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/3055/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/3055/","excerpt":"","text":"#3055. íƒˆì¶œProblem ë¬¸ì œë§í¬ Solution ì¡°ê±´ ì¤‘ì— â€œë¬¼ì´ ì°° ì˜ˆì •ì¸ ì¹¸ì— ê³ ìŠ´ë„ì¹˜ê°€ ì›€ì§ì¼ ìˆ˜ ì—†ë‹¤.â€œì— ì§‘ì¤‘í•˜ì˜€ë‹¤. ë¬¼ì´ ì´ë™í•  queueì™€ ê³ ìŠ´ë„ì¹˜ê°€ ì´ë™í•  queueë¥¼ ë”°ë¡œ ë‘ì–´ íƒìƒ‰ì„ ì‹œì‘í•œë‹¤. ë‹¨, ë¬¼ì´ ë¨¼ì € ì´ë™í•´ì•¼ í•œë‹¤.(ìœ„ ì¡°ê±´ ë•Œë¬¸ì—) ëª¨ë“  íƒìƒ‰ì€ BFSë¡œ ì´ë£¨ì–´ì§€ë©°, ë¬¼ì€ ì´ë™í•  ë•Œë§ˆë‹¤ mapì„ ê°±ì‹ í•œë‹¤. ê³ ìŠ´ë„ì¹˜ëŠ” ê°±ì‹  ì•ˆí•œë‹¤. ê³ ìŠ´ë„ì¹˜ê°€ â€˜Dâ€™ì— ë„ì°©í•˜ì§€ ëª» í•˜ê³  íƒìƒ‰í•  ì§€ì ì´ ì—†ì„ ë•Œ -1ì„ ë¦¬í„´í•˜ì—¬ ë„ì°©í•  ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì„ í‘œì‹œí•œë‹¤. â€˜Dâ€™ì— ë„ì°©í•˜ë©´ ê·¸ë•Œ ì‹œê°„ì„ ë°”ë¡œ ì¶œë ¥í•˜ë„ë¡ í•œë‹¤. 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;tuple&gt;#include &lt;queue&gt;using namespace std;int R, C;char map[51][51];bool visit[50][50];queue&lt;pair&lt;int, int&gt;&gt; q;queue&lt;pair&lt;int, int&gt;&gt; water;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void Input() &#123; scanf(\"%d %d\", &amp;R, &amp;C); for (int i = 0; i &lt; R; ++i) &#123; for (int j = 0; j &lt; C; ++j) &#123; scanf(\" %c\", &amp;map[i][j]); if (map[i][j] == 'S') &#123; q.push(&#123; i, j &#125;); visit[i][j] = true; &#125; else if (map[i][j] == '*') water.push(&#123; i, j &#125;); &#125; &#125;&#125;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; R &amp;&amp; y &lt; C) return true; return false;&#125;int BFS() &#123; int time = 0; while (!q.empty()) &#123; // ê³ ìŠ´ë„ì¹˜ê°€ íƒìƒ‰í•  ì§€ì ì´ ì—†ì„ ë•Œê¹Œì§€ ì§„í–‰ int w_len = water.size(); for (int i = 0; i &lt; w_len; ++i) &#123; // ë¬¼ì˜ ì´ë™ int water_x, water_y; tie(water_x, water_y) = water.front(); water.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_w_x = water_x + dx[dir]; int d_w_y = water_y + dy[dir]; if (isBound(d_w_x, d_w_y)) &#123; if (map[d_w_x][d_w_y] == '.' || map[d_w_x][d_w_y] == 'S') &#123; map[d_w_x][d_w_y] = '*'; water.push(&#123; d_w_x, d_w_y &#125;); &#125; &#125; &#125; &#125; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; // ê³ ìŠ´ë„ì¹˜ ì´ë™ int x, y; tie(x, y) = q.front(); q.pop(); if (map[x][y] == 'D') return time; // ëª©ì ì§€ ë„ì°©í•˜ë©´ ì‹œê°„ ë¦¬í„´ for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (isBound(d_x, d_y) &amp;&amp; !visit[d_x][d_y]) &#123; if (map[d_x][d_y] != 'X' &amp;&amp; map[d_x][d_y] != '*') &#123; visit[d_x][d_y] = true; q.push(&#123; d_x, d_y &#125;); &#125; &#125; &#125; &#125; time++; &#125; return -1;&#125;void Solve() &#123; int ans = BFS(); if (ans == -1) printf(\"KAKTUS\\n\"); else printf(\"%d\\n\", ans);&#125;int main() &#123; Input(); Solve(); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 2869ë²ˆ ë‹¬íŒ½ì´ëŠ” ì˜¬ë¼ê°€ê³  ì‹¶ë‹¤","slug":"Algorithm/BOJ/2869","date":"2020-01-25T04:11:45.000Z","updated":"2020-01-25T08:58:11.145Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2869/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2869/","excerpt":"","text":"#2869. ë‹¬íŒ½ì´ëŠ” ì˜¬ë¼ê°€ê³  ì‹¶ë‹¤Problemë†’ì´ Vë¯¸í„°ì¸ ë‚˜ë¬´ë§‰ëŒ€ ë‚®ì— Aë¯¸í„° ì˜¬ë¼ê° ë°¤ì— Bë¯¸í„° ë‚´ë ¤ê° ì •ìƒì—ì„œëŠ” ì•ˆë‚´ë ¤ê° ë‚˜ë¬´ ë§‰ëŒ€ ëª¨ë‘ ì˜¬ë¼ê°€ëŠ”ë° ê±¸ë¦¬ëŠ” ì¼ ìˆ˜ í•˜ë£¨ì— +A -B B &lt; A â‰¤ V â‰¤ 10ì–µ ì–´ì°¨í”¼ ê°’ì€ 10ì–µì„ ë„˜ì„ ìˆ˜ ì—†ìœ¼ë‹ˆ int ì‚¬ìš©í•´ë„ ë¬´ë°© Ex. input 2 1 5 output 4 ì„¤ëª… 1ì¼: 0+2 = 2 2ì¼: 2-1+2 =3 3ì¼: 3-1+2 = 4 4ì¼: 4-1+2 = 5 í•˜ì§€ë§Œ ì œí•œì‹œê°„ì´ 0.15ì´ˆì´ê¸°ì— ì´ëŸ° ë‹¨ê³„ë¡œ í’€ë©´ ì•ˆëœë‹¤.í•˜ë£¨ëŠ” ë¬´ì¡°ê±´ Aê°€ ë˜ê³  ê·¸ í›„ëŠ” -B+Aê°€ ë°˜ë³µì´ë‹ˆ ë‹¤ìŒì´ ì„±ë¦½í•œë‹¤. V = A + (A-B)xx \\ge \\frac {V-A}{A-B}í•˜ì§€ë§Œ xëŠ” ì •ìˆ˜ì´ë¯€ë¡œ ìœ„ì™€ ê°™ì€ ë¶€ë“±í˜¸ë¥¼ ë¶™ì—¬ì£¼ì–´ì•¼ í•œë‹¤. 3 1 6 1ì¼: 3 2ì¼: 3-1+3 = 5 3ì¼: 5-1+3 = 7 ê³µì‹: x â‰¥ 1.xx ë”°ë¼ì„œ xëŠ” 2, ì´ ì¼ ìˆ˜ëŠ” 2+1 = 3ì¼ì´ëœë‹¤. ê·¼ë° ì´ ê³µì‹ ì ìš©í•˜ë©´ Vê°€ ë˜ì—ˆë‹¤ê°€ ë‹¤ì‹œ ì¤„ì–´ë“œëŠ” ê²½ìš°ê°€ ìˆì–´ì„œ ë‹µì— ì˜í–¥ì„ ì£¼ë‚˜? â†’ NO ceil() ë•Œë¬¸ì— í”¼ì—°ì‚°ìëŠ” doubleí˜•ìœ¼ë¡œ, ê²°ê³¼ê°’ì€ intí˜•ìœ¼ë¡œ ë‘ì—ˆë‹¤.(ê²°ê³¼ê°’ì„ doubleë¡œ ì„¤ì •í•˜ë©´ ì¶œë ¥ê°’ì´ í° ê²½ìš° ë¶€ë™ì†Œìˆ˜ì  ë°©ì‹ìœ¼ë¡œ ì¶œë ¥ë˜ì–´ í‹€ë¦° ë‹µì´ ëœë‹¤.)12345678910111213#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; double a, b, v; int day = 1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; v; double ans = (v-a) / (a-b); ans = ceil(ans); day += ans; cout &lt;&lt; day &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 2798ë²ˆ ë¸”ë™ì­","slug":"Algorithm/BOJ/2798","date":"2020-01-25T04:11:38.000Z","updated":"2020-01-25T08:58:11.147Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2798/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2798/","excerpt":"","text":"#2798. ë¸”ë™ì­ Nì¥ì˜ ì¹´ë“œ M : ëª©í‘œ Nì¥ì˜ ì¹´ë“œ ì¤‘ 3ê°œ ì„ íƒ 3ê°œì˜ ìˆ«ì í•©ì´ Mì— ìµœëŒ€í•œ ê°€ê¹ë„ë¡(Mì„ ë„˜ì–´ì„œë©´ ì•ˆë¨) Nì€ ìµœëŒ€ 100ì´ê¸°ì— 100ì¥ ì¤‘ 3ì¥ì„ ì„ íƒí•˜ëŠ” ê²½ìš°ì˜ ìˆ˜ 100 x 99 x 98 = 970,200â€¬ê°€ ìµœëŒ€ì´ë‹¤.ê·¸ëŸ¬ë¯€ë¡œ ì¶©ë¶„íˆ ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•´ ë‹µì„ ì°¾ì•„ë‚¼ ìˆ˜ ìˆëŠ” ë¬¸ì œì´ë‹¤. ì¬ê·€ë‚˜ forë¬¸ì„ ì´ìš©í•˜ì—¬ í’€ ìˆ˜ ìˆì„ ê²ƒì´ë‹¤. í•„ìëŠ” ì¬ê·€ë¥¼ ì‚¬ìš©í•˜ì˜€ë‹¤. Mì€ ìµœëŒ€ 300000ì´ê¸°ì— MAX ê°’ìœ¼ë¡œ ë‘ì—ˆê³  ì¬ê·€ì˜ ë‚´ìš©ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. ë§¤ê°œë³€ìˆ˜ numbers : Nê°œì˜ ìˆ«ìë¥¼ ë‹´ì„ vector goal : M ans : ìˆ«ì í•© index : numbersì˜ ì¸ë±ìŠ¤ selected : ë‚¨ì€ ì¹´ë“œ ì„ íƒ íšŸìˆ˜ ì‹¤íŒ¨ ì¡°ê±´ ìˆ«ì í•©ì´ Më³´ë‹¤ í´ ë•Œ indexê°€ numbersì˜ í¬ê¸°ë¥¼ ë„˜ì—ˆì„ ë•Œ ì„±ê³µ ì¡°ê±´ 3ë²ˆì„ ë½‘ì•˜ì„ ê²½ìš°, goalê³¼ ansì˜ ì°¨ì´ê°€ ìµœì†Œì¸ ê°’ ì¬ê·€í•¨ìˆ˜ ì¹´ë“œë¥¼ ì„ íƒí•˜ì§€ ì•Šì„ ë•Œ ì¹´ë“œë¥¼ ì„ íƒí–ˆì„ ë•Œansì— ì„ íƒí•œ ì¹´ë“œê°€ ë”í•´ì§12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;#define MAX 300000;using namespace std;int min_diff = MAX;vector&lt;int&gt; numbers;void doCombination(vector&lt;int&gt; numbers, int goal, int ans, int index, int selected) &#123; if(ans &gt; goal) return; if(selected == 0) &#123; min_diff = min_diff &gt; goal-ans ? goal-ans : min_diff; return; &#125; if(index &gt;= numbers.size()) &#123; return; &#125; doCombination(numbers, goal, ans, index+1, selected); // not selected ans += numbers[index]; doCombination(numbers, goal, ans, index+1, selected-1); // selected&#125;int main() &#123; int n, m, answer = 0; cin &gt;&gt; n &gt;&gt; m; numbers.resize(n); for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; numbers[i]; &#125; doCombination(numbers, m, 0, 0, 3); answer = m - min_diff; cout &lt;&lt; answer &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 2748ë²ˆ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ 2","slug":"Algorithm/BOJ/2748","date":"2020-01-25T04:11:30.000Z","updated":"2020-01-25T08:58:11.143Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2748/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2748/","excerpt":"","text":"#2748. í”¼ë³´ë‚˜ì¹˜ ìˆ˜ 2ë¬¸ì œë§í¬ Problem Goal : në²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ë¥¼ êµ¬í•˜ì—¬ë¼ condition ìµœëŒ€ 90ë²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ë¥¼ êµ¬í•  ìˆ˜ ìˆì–´ì•¼ í•¨ ì‹œê°„ ì œí•œ 1ì´ˆ SolutionF_n = F_{n-1} + F_{n-2}ìˆ˜ì‹ ê·¸ëŒ€ë¡œ DPë¥¼ ì ìš©í•œë‹¤.12// dp[n]ì€ në²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜dp[n] = dp[n-1] + dp[n-2]; 1 Try1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;long long dp[91]; long long fibo(int n)&#123; dp[0] = 0, dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125;int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; fibo(n) &lt;&lt; endl; return 0;&#125; ì£¼ì˜í•  ì ì€ 90ë²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜(10ì˜ 18ìŠ¹ë³´ë‹¤ í¼)ë¥¼ ë‹´ìœ¼ë ¤ë©´ long longì„ ì¨ì•¼ í•œë‹¤ëŠ” ì ì´ë‹¤.(longì€ ì•ˆëœë‹¤.)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 2468ë²ˆ ì•ˆì „ ì˜ì—­","slug":"Algorithm/BOJ/2468","date":"2020-01-25T04:11:03.000Z","updated":"2020-01-25T08:58:11.158Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2468/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2468/","excerpt":"","text":"#2468. ì•ˆì „ ì˜ì—­Problem ë¬¸ì œë§í¬ Solution ë†’ì´ 1ë¶€í„° ìµœëŒ€ ë†’ì´ê¹Œì§€ ì‘ì—…ì„ ì§„í–‰í•œë‹¤. â†’ setì— ë†’ì´ ì •ë³´ë¥¼ ë‹´ê³  ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ë©´ ë” ë¹ ë¥¼ë“¯ ê° ë†’ì´ë§ˆë‹¤ ëª¨ë“  ì˜ì—­ì„ íƒìƒ‰í•œë‹¤. (ë§ì´ ëª¨ë“  ì˜ì—­ì´ì§€ ì´ë¯¸ ë†’ì´ë³´ë‹¤ ê°™ê±°ë‚˜ ì‘ì€ ì˜ì—­ì´ë‚˜ ë°©ë¬¸í•œ ì˜ì—­ì´ë©´ íƒìƒ‰ì„ í•˜ì§€ ì•ŠëŠ”ë‹¤.)íƒìƒ‰ì€ BFSë¡œ ì•ˆì „ì˜ì—­ì„ í‘œì‹œí•œë‹¤. íƒìƒ‰ì´ ëë‚˜ë©´ ì•ˆì „ ì˜ì—­ì˜ ìˆ˜ë¥¼ 1ì¦ê°€í•œë‹¤. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;int N, max_height, ans = 1;int arr[100][100];bool visited[100][100];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void BFS(int x, int y, int h) &#123; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123; x, y &#125;); visited[x][y] = true; while (!q.empty()) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int nx = x + dx[dir]; int ny = y + dy[dir]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= N) continue; if (visited[nx][ny] || arr[nx][ny] &lt;= h) continue; visited[nx][ny] = true; q.push(&#123; nx, ny &#125;); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++)&#123; for (int j = 0; j &lt; N; j++)&#123; cin &gt;&gt; arr[i][j]; if (max_height &lt; arr[i][j]) max_height = arr[i][j]; &#125; &#125; for (int h = 1; h &lt;= max_height; ++h) &#123; int area = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; if (visited[i][j] || arr[i][j] &lt;= h) continue; BFS(i, j, h); area++; &#125; &#125; if (ans &lt; area) ans = area; memset(visited, false, sizeof(visited)); &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 2251ë²ˆ ë¬¼í†µ","slug":"Algorithm/BOJ/2251","date":"2020-01-25T04:10:51.000Z","updated":"2020-01-25T08:58:11.148Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2251/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2251/","excerpt":"","text":"#2251. ë¬¼í†µProblem ë¬¸ì œë§í¬ Solution ì²« ì‹œì‘ì€ C ë¬¼í†µë§Œ ê°€ë“ ì°¨ ìˆìœ¼ë‹ˆ ì „ì²´ í•©ì€ Cì˜ ë¬¼í†µì´ë‹¤. ë¬¼ì„ ì˜®ê¸°ëŠ” ê²½ìš°ëŠ” ì´ 6ê²½ìš°ë¡œ 0ì„ A, 1ì„ B, 2ë¥¼ Cë¼ê³  í–ˆì„ ë•Œ ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš°ê°€ ì¡´ì¬í•œë‹¤.1230 -&gt; 1, 0 -&gt; 21 -&gt; 0, 1 -&gt; 22 -&gt; 0, 2 -&gt; 1 ê²½ìš°ì˜ ìˆ˜ê°€ ì¤‘ë³µë˜ì§€ ì•Šë„ë¡ í‘œì‹œí•´ì£¼ëŠ” ë°°ì—´ì€ 2ì°¨ì›ìœ¼ë¡œë„ í•´ê²° ê°€ëŠ¥í•˜ë‹¤. (ì „ì²´ ì–‘ì€ ì¼ì •í•˜ë‹ˆ A, Bë§Œ ì•Œì•„ë„ Cë¥¼ ì•Œ ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.) ì²˜ìŒ A, B, Cì˜ ë¶€í”¼ë¥¼ ì €ì¥í•œë‹¤. ì‹œì‘ì€ (0, 0)ì—ì„œ ì‹œì‘í•˜ê³ , ans[C ë¬¼ì˜ ì–‘]ì´ trueì„ì„ í‘œì‹œí•´ Aê°€ 0ì¼ ë•Œ Cì˜ ë¬¼ì˜ì–‘ì„ì„ ë‚˜íƒ€ë‚¸ë‹¤. BFS íƒìƒ‰ì„ ì‹œì‘í•œë‹¤. ê° ê²½ìš°ì—ì„œ ê³„ì†í•´ì„œ ë‚˜ì•„ê°€ëŠ” ë°©ì‹ì´ê¸°ì— ì í•©í•˜ë‹¤. (ê²½ìš°ì˜ ìˆ˜ë„ ë§ì§€ ì•ŠìŒ) ë¬¼ì„ ì˜®ê¸°ëŠ” ê±´ 2ê°€ì§€ ê²½ìš°ê°€ ì¡´ì¬í•œë‹¤. from x â†’ to y x + y â‰¤ Yx + yì˜ ê°’ì´ yë¥¼ ê°€ì§„ ë¬¼í†µì˜ ë¶€í”¼(Y)ì´í•˜ì¼ ë•Œxë¥¼ ë‹¤ ì˜®ê¸¸ ìˆ˜ ìˆìœ¼ë¯€ë¡œ xë¥¼ ê°€ì¡Œë˜ ë¬¼í†µì˜ ë¬¼ì˜ ì–‘ì€ 0ì´ ëœë‹¤.yë¥¼ ê°€ì§„ ë¬¼í†µì˜ ë¬¼ì˜ ì–‘ì€ x+yê°€ ëœë‹¤. x + y &gt; Yx + yì˜ ê°’ì´ Yë³´ë‹¤ í´ ë•Œ xë¥¼ ë‹¤ ì˜®ê¸¸ ìˆ˜ ì—†ìœ¼ë¯€ë¡œxë¥¼ ê°€ì¡Œë˜ ë¬¼í†µì˜ ë¬¼ì˜ ì–‘ì€ x + y - Yê°€ëœë‹¤.yë¥¼ ê°€ì¡Œë˜ ë¬¼í†µì˜ ë¬¼ì˜ ì–‘ì€ Yê°€ ëœë‹¤. checkì™€ Aì˜ ë¬¼ì˜ ì–‘ì´ 0ì¸ì§€ íŒë‹¨í•˜ì—¬ BFS íƒìƒ‰ì„ í•œë‹¤. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int bucket[3]; // ë¬¼í†µ ë¶€í”¼bool check[201][201]; // A, Bë§Œ ì•Œì•„ë„ Cë¥¼ ì•Œ ìˆ˜ ìˆìŒbool ans[201]; // Aê°€ ë¹„ì–´ìˆì„ ë•Œ Cì˜ ë¬¼ì˜ ì–‘queue&lt;pair&lt;int, int&gt;&gt; q;int from[6] = &#123; 0, 0, 1, 1, 2, 2 &#125;; // 0: A, 1: B, 2: Cint to[6] = &#123; 1, 2, 0, 2, 0, 1 &#125;;void Output() &#123; for (int i = 0; i &lt;= 200; ++i) &#123; if (ans[i]) cout &lt;&lt; i &lt;&lt; \" \"; &#125; cout &lt;&lt; \"\\n\";&#125;void BFS() &#123; int sum = bucket[2]; q.push(&#123; 0, 0 &#125;); check[0][0]= true; ans[sum] = true; while (!q.empty()) &#123; int cur[3]; cur[0] = q.front().first; cur[1] = q.front().second; cur[2] = sum - cur[0] - cur[1]; q.pop(); for (int i = 0; i &lt; 6; ++i) &#123; int next[3] = &#123; cur[0], cur[1], cur[2] &#125;; if (next[from[i]] + next[to[i]] &lt;= bucket[to[i]]) &#123; next[to[i]] += next[from[i]]; next[from[i]] = 0; &#125; else &#123; // ì˜®ê¸´ ë¬¼ì˜ ì–‘ì´ í•´ë‹¹ ë¬¼í†µ ë¶€í”¼ë³´ë‹¤ í´ ë•Œ next[from[i]] += next[to[i]] - bucket[to[i]]; next[to[i]] = bucket[to[i]]; &#125; if (!check[next[0]][next[1]]) &#123; check[next[0]][next[1]] = true; q.push(&#123; next[0], next[1] &#125;); if (next[0] == 0) ans[next[2]] = true; &#125; &#125; &#125; &#125;int main() &#123; for (int i = 0; i &lt; 3; ++i) cin &gt;&gt; bucket[i]; BFS(); Output(); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 2231ë²ˆ ë¶„í•´í•©","slug":"Algorithm/BOJ/2231","date":"2020-01-25T04:10:46.000Z","updated":"2020-01-25T08:58:11.160Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2231/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2231/","excerpt":"","text":"#2231. ë¶„í•´í•©ë¬¸ì œë§í¬ Problem ìì—°ìˆ˜ Nì˜ ë¶„í•´í•©ì€ Nê³¼ Nì„ ì´ë£¨ëŠ” ê° ìë¦¬ìˆ˜ì˜ í•© 245ì˜ ë¶„í•´í•© : 245+2+4+5 = 256245ëŠ” 256ì˜ ìƒì„±ì ìƒì„±ìëŠ” ì—†ì„ ìˆ˜ë„ ì—¬ëŸ¬ ê°œì¼ ìˆ˜ë„ ìˆìŒ ì—†ë‹¤ë©´ 0 ì¶œë ¥ Goal: Nì´ ì£¼ì–´ì¡Œì„ ë•Œ Nì˜ ê°€ì¥ ì‘ì€ ìƒì„±ì ì¶œë ¥ Solution 1ë¶€í„° ìµœëŒ€ N-1ê¹Œì§€ ë¶„í•´í•©ì„ êµ¬í•˜ë©´ì„œ í’€ì–´ë³´ë©´ ì–´ë–»ê²Œ ë ê¹Œ? 1ë¶€í„° ë¶„í•´í•©ì„ êµ¬í•˜ë‹¤ê°€ Nì´ ë˜ì—ˆì„ ë•Œ ì¢…ë£Œí•˜ë©´ ê°€ì¥ ì‘ì€ ìƒì„±ìë¥¼ ì¶œë ¥í•  ìˆ˜ ìˆë‹¤. ë¶„í•´í•© êµ¬í•˜ê¸°1234567891011121314151617181920212223242526272829303132212ì˜ ë¶„í•´í•© êµ¬í•˜ê¸°212 ìë¦¿ìˆ˜ 3// #1.212 / 10^2 = 2 -&gt; 212+2212 - 2*10^2 = 12// #2.12 / 10^1 = 1 -&gt; 212+2+112 - 1*10^1 = 2 -&gt; 212+2+1+211ì˜ ë¶„í•´í•© êµ¬í•˜ê¸°11 ìë¦¿ìˆ˜ 2div = 10 (10ì˜ ì œê³± ìˆ˜)sum = 11 (ë¶„í•´í•©)// #1.temp = 11 / 10 = 1 (ê³„ì‚° ìš©ë„)num = 11 - 10 = 1sum = 11 + 1 = 12div = 1// #2.temp = 1 / 1 = 1num = 1 - 1 = 0sum = 12 + 1 = 13div = 0ê·¸ëƒ¥ ë” ê°„ë‹¨í•œ ë°©ë²•ì´ ìƒê°ë‚¬ë‹¤. (2 Try ì°¸ê³ )sum, temp = 11sum = 11 + 11 % 10temp = 11 / 10 = 1sum = 12 + 1 % 10 = 13ì¦‰, sum += temp % 10temp /= 10 1 Try12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;// ìë¦¿ ìˆ˜ ì²´í¬int getLength(int num) &#123; int count = 0; do &#123; count++; &#125;while(num/=10); return count;&#125;// ë¶„í•´í•© ê²Œì‚° int distributeSum(int num) &#123; int length = getLength(num); int div = pow(10, length-1); int sum = num; int temp; for(int i = 0; i &lt; length; ++i) &#123; temp = num / div; num = num - temp * div; sum += temp; div /= 10; &#125; return sum;&#125;int main()&#123; int n, i; cin &gt;&gt; n; for(i = 1; i &lt; n; ++i) &#123; if(n == distributeSum(i)) &#123; cout &lt;&lt; i &lt;&lt; '\\n'; break; &#125; &#125; if(i == n) cout &lt;&lt; 0 &lt;&lt; '\\n'; return 0;&#125; 108ms 2 Try12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int distributeSum(int num) &#123; int sum, temp; sum = temp = num; do &#123; sum += temp % 10; &#125;while(temp /= 10); return sum;&#125;int main() &#123; int n, i; cin &gt;&gt; n; for(i = 1; i &lt; n; ++i) &#123; if(n == distributeSum(i)) &#123; cout &lt;&lt; i &lt;&lt; '\\n'; break; &#125; &#125; if(i == n) cout &lt;&lt; 0 &lt;&lt; '\\n'; return 0;&#125; 8ms","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 2206ë²ˆ ë²½ ë¶€ìˆ˜ê³  ì´ë™í•˜ê¸°","slug":"Algorithm/BOJ/2206","date":"2020-01-25T04:10:43.000Z","updated":"2020-01-25T08:58:11.132Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2206/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2206/","excerpt":"","text":"#2206. ë²½ ë¶€ìˆ˜ê³  ì´ë™í•˜ê¸°ë¬¸ì œë§í¬ Problem N x M í¬ê¸°ì˜ ë§µ 0ì€ ì´ë™ê°€ëŠ¥ 1ì€ ë²½ì„ ë‚˜íƒ€ëƒ„ (0, 0) â†’ (N-1, M-1)ê¹Œì§€ ì´ë™ (ìƒí•˜ì¢Œìš°) ë²½ì„ 1ê°œê¹Œì§€ ë¶€ìˆ˜ê³  ì´ë™ ê°€ëŠ¥ Goal: (0, 0)ì—ì„œ (N-1, M-1)ê¹Œì§€ ì´ë™í•˜ëŠ”ë° ê±¸ë¦¬ëŠ” ê²½ë¡œ ì¤‘ ìµœë‹¨ ê²½ë¡œ êµ¬í•˜ê¸° Solution ì´ë™í•˜ê¸° ì‹œì‘ì§€ì (0, 0)ì—ì„œë¶€í„° ìƒí•˜ì¢Œìš°ë¡œ ê°ˆ ìˆ˜ ìˆëŠ” ë°©í–¥ì„ íƒìƒ‰í•œë‹¤.ë„ì°©ì§€ì ê¹Œì§€ ëª¨ë“  ê³³ì„ íƒìƒ‰í•´ì•¼ í•˜ë©°, ì´ë•Œ BFSë¥¼ ì‚¬ìš©í•œë‹¤.í˜„ì¬ ì§€ì ì—ì„œ ìƒí•˜ì¢Œìš°ë¡œ ê°€ëŠ”ë° ê±¸ë¦¬ëŠ” ë¹„ìš©ì´ ë™ì¼í•˜ê¸° ë•Œë¬¸ì´ë‹¤. ë²½ì„ ë¶€ìˆ˜ì—ˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ê²½ë¡œë¥¼ ê°±ì‹ í•  ë•Œë§ˆë‹¤ ê°€ì§€ê³  ìˆì–´ì•¼ í•œë‹¤. íƒìƒ‰í•  ë•Œ ì´ë¯¸ ê°’ì´ ìˆë‹¤ë©´ ì´ë¯¸ ì§€ë‚˜ì˜¨ ê²½ë¡œì´ë¯€ë¡œ ë‹¤ë¥¸ ì§€ì ì„ íƒìƒ‰í•´ì•¼ í•œë‹¤. ê·¸ì™¸ëŠ” ë‹¤ìŒì„ í™•ì¸í•˜ê³  ê²½ë¡œë¥¼ ê°±ì‹ í•œë‹¤. íƒìƒ‰í•  ì§€ì ì´ 0ì´ë¼ë©´ ê²½ë¡œ ê°±ì‹  íƒìƒ‰í•  ì§€ì ì´ 1ì¸ë° ì´ì „ê¹Œì§€ ë²½ì„ ë¶€ìˆ˜ì§€ ì•Šì•˜ë‹¤ë©´ ê²½ë¡œ ê°±ì‹  ìœ„ì™€ ê°™ì€ ì‘ì—…ìœ¼ë¡œ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;queue&gt;#define MAX 1001using namespace std;int n, m;int map[MAX][MAX];int path[MAX][MAX][2]; // ë²½ì„ ì•ˆë¶€ìˆœ ê²½ë¡œ, ë²½ì„ ë¶€ìˆœ ê²½ë¡œint dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;struct INFO &#123; int r, c; bool break_wall = false;&#125;;int bfs() &#123; queue&lt;INFO&gt; q; q.push(&#123; 0, 0, false &#125;); path[0][0][0] = 1; while (!q.empty()) &#123; int r = q.front().r; int c = q.front().c; bool bw = q.front().break_wall; q.pop(); if (r == n - 1 &amp;&amp; c == m - 1) return path[r][c][bw]; for (int i = 0; i &lt; 4; ++i) &#123; int x = r + dx[i]; int y = c + dy[i]; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; n &amp;&amp; y &lt; m) &#123; if (path[x][y][bw]) continue; if (map[x][y] == 0) &#123; path[x][y][bw] = path[r][c][bw] + 1; q.push(&#123; x, y, bw &#125;); &#125; else if(map[x][y] == 1 &amp;&amp; bw == 0) &#123; path[x][y][1] = path[r][c][bw] + 1; q.push(&#123; x, y, true &#125;); &#125; &#125; &#125; &#125; return -1;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; scanf(\"%1d\", &amp;map[i][j]); &#125; &#125; printf(\"%d\\n\", bfs()); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 2146ë²ˆ ë‹¤ë¦¬ ë§Œë“¤ê¸°","slug":"Algorithm/BOJ/2146","date":"2020-01-25T04:10:23.000Z","updated":"2020-01-25T08:58:11.152Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2146/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2146/","excerpt":"","text":"2146. ë‹¤ë¦¬ ë§Œë“¤ê¸°Problem ë¬¸ì œë§í¬ Solution ê° ì„¬ì˜ idë¥¼ ë§¤ê¸´ë‹¤. â†’ DFS ì´ìš© ê°€ì¥ ì§§ì€ ë‹¤ë¦¬ì˜ ê¸¸ì´ë¥¼ êµ¬í•œë‹¤. â†’ BFS ì´ìš© 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int map[100][100];bool visited[100][100];int N, ans =1e9;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void DFS(int x, int y, int idx) &#123; visited[x][y] = true; map[x][y] = idx; for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; N &amp;&amp; d_y &lt; N) &#123; if (map[d_x][d_y] == 0 || visited[d_x][d_y]) continue; DFS(d_x, d_y, idx); &#125; &#125;&#125;int BFS(int x, int y) &#123; memset(visited, false, sizeof(visited)); queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123; x, y &#125;); int temp = map[x][y]; int res = 0; while (int len = q.size()) &#123; while(len--) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; N &amp;&amp; d_y &lt; N) &#123; if (map[d_x][d_y] != 0 &amp;&amp; map[d_x][d_y] != temp) return res; if (map[d_x][d_y] == 0 &amp;&amp; !visited[d_x][d_y]) &#123; visited[d_x][d_y] = true; q.push(&#123; d_x, d_y &#125;); &#125; &#125; &#125; &#125; res++; &#125; return ans;&#125;int main() &#123; cin &gt;&gt; N; int idx = 1; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; // ê° ì„¬ì— ë²ˆí˜¸ ë§¤ê¸°ê¸° for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (visited[i][j] || map[i][j] == 0) continue; DFS(i, j, idx++); &#125; &#125; // ê°€ì¥ ì§§ì€ ë‹¤ë¦¬ ê¸¸ì´ êµ¬í•˜ê¸° for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (map[i][j] == 0) continue; ans = min(ans, BFS(i, j)); &#125; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 1938ë²ˆ í†µë‚˜ë¬´ ì˜®ê¸°ê¸°","slug":"Algorithm/BOJ/1938","date":"2020-01-25T04:09:53.000Z","updated":"2020-01-25T06:28:02.580Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/1938/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/1938/","excerpt":"","text":"#1938. í†µë‚˜ë¬´ ì˜®ê¸°ê¸°Problem ë¬¸ì œë§í¬ Solution í†µë‚˜ë¬´ ì¤‘ì  ì¢Œí‘œë¥¼ í† ëŒ€ë¡œ BFS íƒìƒ‰ì„ í•˜ì˜€ë‹¤.ì¤‘ì‹¬ì„ ê¸°ì¤€ìœ¼ë¡œ ê·¸ëŒ€ë¡œ(íšŒì „), ìƒ, í•˜, ì¢Œ, ìš°ë¡œ ì´ë™í•˜ë©´ ê°ê° ì‘ë™íšŸìˆ˜ + 1ì´ê¸°ì—BFSë¡œ íƒìƒ‰í•˜ëŠ”ê²Œ ìµœì ì´ë‹¤.ì¤‘ë³µ íƒìƒ‰ì„ ë§‰ê¸° ìœ„í•´ 3ì°¨ì› ë°©ë¬¸ ë°°ì—´ì„ ë‘ì–´ ì¤‘ì  ì¢Œí‘œì˜ ê° ëª¨ì–‘(íƒ€ì…)ì— ë”°ë¼ í‘œì‹œë¥¼ í•˜ì˜€ë‹¤. ì¤‘ì  ì¢Œí‘œë¡œ ì´ë™í•˜ë‹¤ë³´ë‹ˆ ì´ë™ í›„ ë‹¤ìŒì„ ê¼­ í™•ì¸í•´ì•¼ í•œë‹¤. í‰ì§€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•ŠëŠ”ì§€ì„¸ ì¢Œí‘œ ëª¨ë‘ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šë„ë¡ í™•ì¸í•´ì•¼í•œë‹¤. ë°©ë¬¸í•œ ì§€ì ì¸ì§€ ì›€ì§ì¼ ìˆ˜ ìˆëŠ”ì§€ìƒí•˜ì¢Œìš° â†’ ì›€ì§ì¸ ì„¸ ì¢Œí‘œì— â€˜1â€™ì´ ì—†ëŠ”ì§€ í™•ì¸íšŒì „ â†’ ì›€ì§ì¸ ì¤‘ì ì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ 3x3dp â€˜1â€™ì´ ì—†ëŠ”ì§€ í™•ì¸ ë„ì°© ì§€ì ì— ë„ì°©í•˜ë©´ ì¢…ë£Œ 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define endl \"\\n\"#define MAX 50using namespace std;int N, ans = 1e9;char land[MAX + 1][MAX + 1];bool visited[MAX + 1][MAX + 1][2];vector&lt;pair&lt;int, int&gt;&gt; start_point;vector&lt;pair&lt;int, int&gt;&gt; end_point;int dr[5] = &#123; 0, -1, 1, 0, 0 &#125;;int dc[5] = &#123; 0, 0, 0, -1, 1 &#125;;struct Log &#123; int type; // 0 : ê°€ë¡œ, 1 : ì„¸ë¡œ int r, c; // ì¤‘ì  ì¢Œí‘œ&#125;;bool isIn(int r, int c, int type) &#123; // í†µë‚˜ë¬´ê°€ í‰ì§€ ë²”ìœ„ì¸ì§€ if (type == 0) c--; else r--; for (int i = 0; i &lt; 3; ++i) &#123; if (r &lt; 0 || c &lt; 0 || r &gt; N - 1 || c &gt; N - 1) return false; if (type == 0) c++; else r++; &#125; return true;&#125;bool isEnd(int r, int c, int type) &#123; // EEEì— ë„ì°©í–ˆëŠ”ì§€ if (type == 0) c--; else r--; for (int i = 0; i &lt; end_point.size(); i++) &#123; if (end_point[i].first != r || end_point[i].second != c) return false; if (type == 0) c++; else r++; &#125; return true;&#125;bool Check(int r, int c, int type) &#123; // ì´ë™ì´ ê°€ëŠ¥í•œì§€ if (type == 0) c--; else r--; for (int i = 0; i &lt; 3; ++i) &#123; if (land[r][c] == '1') return false; if (type == 0) c++; else r++; &#125; return true;&#125;bool CheckRotate(int r, int c, int type) &#123; // íšŒì „ì´ ê°€ëŠ¥í•œì§€ int sr = r - 1, sc = c - 1; for (int i = sr; i &lt; sr + 3; ++i) &#123; for (int j = sc; j &lt; sc+ 3; ++j) &#123; if (land[i][j] == '1') return false; &#125; &#125; return true;&#125;void BFS() &#123; queue&lt;Log&gt; q; int type, r, c; if (start_point[0].first == start_point[1].first) &#123; type = 0; r = start_point[0].first; c = start_point[1].second; &#125; else &#123; type = 1; c = start_point[0].second; r = start_point[1].first; &#125; q.push(&#123; type, r, c &#125;); visited[r][c][type] = true; int cnt = 0; while (int s = q.size()) &#123; while (s--) &#123; int r = q.front().r, c = q.front().c; int type = q.front().type; if (isEnd(r, c, type)) &#123; ans = cnt; return; &#125; q.pop(); for (int dir = 0; dir &lt; 5; ++dir) &#123; if (dir == 0 || dir == 1) type = (type+1) % 2; // íšŒì „ í›„ íƒ€ì… ì›ë˜ëŒ€ë¡œ int nr = r + dr[dir]; int nc = c + dc[dir]; if (!isIn(nr, nc, type)) continue; if (visited[nr][nc][type]) continue; if (dir == 0) if (!CheckRotate(nr, nc, type)) continue; // 3 x 3 í™•ì¸ í›„ íšŒì „ if (Check(nr, nc, type)) &#123; visited[nr][nc][type] = true; q.push(&#123; type, nr, nc &#125;); &#125; &#125; &#125; cnt++; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; cin &gt;&gt; land[i][j]; if (land[i][j] == 'B') start_point.push_back(&#123; i, j &#125;); else if (land[i][j] == 'E') end_point.push_back(&#123; i, j &#125;); &#125; &#125; BFS(); if (ans == 1e9) ans = 0; cout &lt;&lt; ans &lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 1932ë²ˆ ì •ìˆ˜ ì‚¼ê°í˜•","slug":"Algorithm/BOJ/1932","date":"2020-01-25T04:09:30.000Z","updated":"2020-01-25T06:54:13.895Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/1932/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/1932/","excerpt":"","text":"#1932. ì •ìˆ˜ ì‚¼ê°í˜•ë¬¸ì œë§í¬ Problem ë§¨ ìœ„ì¸µë¶€í„° ì‹œì‘ â†’ ë§¨ ì•„ë˜ ì¸µì„ íƒëœ ìˆ˜ë“¤ì„ í•©í•˜ë©´ì„œ ë‚´ë ¤ì˜´ í˜„ì¬ ì¸µì—ì„œ ì„ íƒëœ ìˆ˜ì˜ ëŒ€ê°ì„ (ì™¼ or ì˜¤)ë§Œ ê°€ëŠ¥ condition ì¸µì€ ìµœëŒ€ 500 ìˆ˜ì˜ ë²”ìœ„ 0~9999 Goal : í•©ì´ ìµœëŒ€ê°€ ë˜ëŠ” ìˆ˜ Solution ì…ë ¥ì„ ë³´ë©´ ì•Œê² ì§€ë§Œ ìê¸° ìì‹  ë°”ë¡œ ì•„ë˜ì™€ ì˜¤ë¥¸ìª½ë§Œ ê°€ëŠ¥123456&#x2F;&#x2F; input73 88 1 02 7 4 44 5 2 6 5 ê·¸ëƒ¥ ì¬ê·€í•¨ìˆ˜ë¥¼ ì“°ë©´ ë°˜ë³µë˜ëŠ” í˜¸ì¶œì´ ë§ì´ ì¼ì–´ë‚œë‹¤.DPë¥¼ ì‚¬ìš©í•´ì•¼ í•¨ì„ ì•Œ ìˆ˜ ìˆë‹¤.12345678910&#x2F;&#x2F; #07&#x2F;&#x2F; #17+3 &#x2F; 7+8&#x2F;&#x2F; #27+3+8, 7+3+1 &#x2F; 7+8+1, 7+8+0&#x2F;&#x2F; #37+3+8+2, 7+3+8+7 &#x2F; 7+3+1+7, 7+3+1+4 &#x2F; 7+8+1+7, 7+8+1+4 &#x2F; 7+8+0+4, 7+8+0 +4&#x2F;&#x2F; #420+4, 20+5 &#x2F; 25+5, 25+2 &#x2F; 18+5, 18+2 &#x2F; 14+2, 14+6 &#x2F; 23+5, 23+2 &#x2F; ... ê²½ìš°ì˜ ìˆ˜ëŠ” 1â†’2â†’4â†’8â†’16ìœ¼ë¡œ ëŠ˜ì–´ë‚œë‹¤. 500ì¼ ë•Œ ìµœëŒ€ 500^2 = 250000(25ë§Œ)ì˜ ê²½ìš°ì˜ ìˆ˜ê°€ ë‚˜ì˜¨ë‹¤. ë¬¼ë¡  ì¬ê·€í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ì´ë³´ë‹¤ ë” ë§ì€ í•¨ìˆ˜ í˜¸ì¶œì´ ì¼ì–´ë‚˜ ì‹œê°„ì´ˆê³¼ê°€ ë°œìƒí•  ê²ƒì´ë‹¤. 6ê°œì›” ì „ì— í’€ì—ˆë˜ ê²ƒì„ ë‹¤ì‹œ í’€ì–´ë³´ë ¤ë‹ˆâ€¦ìƒê°ì´ ì•ˆë‚œë‹¤. dp[a][b] 1 Try (6ê°œì›” ì „ ì½”ë“œ)1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int t[500][500];int d[500][500];int main()&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; cin &gt;&gt; t[i][j]; &#125; &#125; d[0][0] = t[0][0]; for (int k = 1; k &lt; n; k++) &#123; for (int h = 0; h &lt; n; h++) &#123; if (h == 0) &#123; d[k][0] = d[k - 1][0] + t[k][0]; //ë°”ë¡œ ìœ„ì˜ ìµœëŒ€ê²½ë¡œë§Œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŒ. &#125; else if (k == h) &#123; d[k][h] = d[k - 1][h - 1] + t[k][h]; // ë°”ë¡œ ìœ„ ì™¼ìª½ì˜ ìµœëŒ€ê²½ë¡œë§Œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŒ. &#125; else &#123; d[k][h] = max(d[k - 1][h - 1], d[k - 1][h]) + t[k][h]; &#125; &#125; &#125; int max_cost = 0; // 0ë³´ë‹¤ ì‘ì„ ìˆ˜ ì—†ìŒ. for (int index = 0; index &lt; n; index++) &#123; max_cost = max(d[n - 1][index], max_cost); &#125; cout &lt;&lt; max_cost &lt;&lt; endl; return 0;&#125; 12345678910111213141516171819202122232425262728#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int max_sum = 0;vector&lt;vector&lt;int&gt;&gt; dp;int main() &#123; int n, input; scanf(\" %d\", &amp;n); dp.resize(n); vector&lt;vector&lt;int&gt;&gt; tri(n); for(int i = 0; i &lt; n; ++i) &#123; for(int j = i; j &gt;= 0; --j) &#123; scanf(\" %d\", &amp;input); tri[i].push_back(input); &#125; &#125; dp[0][0] = tri[0][0]; for(int i = 1; i &lt; n; ++i) &#123; for(int j = 0; j &lt;= i; ++j) &#123; dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]); &#125; &#125; cout &lt;&lt; max_sum &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 1525ë²ˆ í¼ì¦","slug":"Algorithm/BOJ/1525","date":"2020-01-25T04:04:59.000Z","updated":"2020-01-25T04:49:31.051Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/1525/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/1525/","excerpt":"","text":"1525. í¼ì¦Problem ë¬¸ì œë§í¬ Solution ìƒë‹¹íˆ ì–´ë ¤ìš´ ë¬¸ì œë‹¤. (ì ‘ê·¼ë²•ì„ ì•Œì•„ë‘˜ í•„ìš”ê°€ ìˆë‹¤.) ì ‘ê·¼ë²• 2ì°¨ì› ë°°ì—´ì„ 1ì°¨ì› ë°°ì—´ë¡œ ìƒê°í•˜ê¸° í¼ì¦ì— ì í˜€ìˆëŠ” ìˆ«ìë¥¼ í•˜ë‚˜ë¡œ ì­‰ ì´ì–´ì§„ ìˆ˜ë¡œ ìƒê°í•œë‹¤. ì´ì–´ì§„ ìˆ˜ í•˜ë‚˜ê°€ ê²½ìš°ì˜ ìˆ˜ë¼ê³  ìƒê°í•œë‹¤. (ë¬¸ì œ ëª©í‘œëŠ” 123456789ì¸ ìˆ˜(ê²½ìš°)ë¥¼ ì°¾ëŠ” ê²ƒ) map&lt;í•´ë‹¹ ê²½ìš°(ìˆ˜), ì´ë™ íšŸìˆ˜&gt;ë¥¼ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ ê²½ìš°ì— ë„ë‹¬í•˜ê¸°ê¹Œì§€ ê±¸ë¦¬ëŠ” ì´ë™ íšŸìˆ˜ë¥¼ ì €ì¥í•œë‹¤. 9(0)ì´ ìˆëŠ” ìœ„ì¹˜ì—ì„œ ì‹œì‘í•˜ì—¬ BFS íƒìƒ‰ì„ í•˜ê³  íƒìƒ‰ ì‹œì— swapì„ í•´ì•¼ í•œë‹¤. (ì´ë™ì„ í•  ë•Œ ì¸ë±ìŠ¤ ê³„ì‚°ì— ì£¼ì˜í•œë‹¤.) swapì„ ìœ„í•´ stringì„ ì‚¬ìš©í•œë‹¤.123456789101112ex) í˜„ì¬ 193425786 (0ëŒ€ì‹  9ë¥¼ í•´ì•¼ ê° ìë¦¿ ìˆ˜ê°€ ëª¨ë‘ ì±„ì›Œì§„ë‹¤. 0123...ìœ¼ë¡œ í•˜ë©´ 0ì´ ì‚¬ë¼ì§)193425786 -&gt; 913425786 (ì™¼ìª½ ì´ë™)-&gt; 123495786 (ì•„ë˜ìª½ ì´ë™)-&gt; 149425786 (ì˜¤ë¥¸ìª½ ì´ë™)3 x 3 0 1 23 4 56 7 8í–‰ &#x3D; 9ë²ˆ ìœ„ì¹˜(0~8 ì¤‘) &#x2F; 3ì—´ &#x3D; 9ë²ˆ ìœ„ì¹˜ % 3 ì£¼ì˜ ì•„ë˜ ì½”ë“œì—ì„œ dist.count(next_num) == 0 ëŒ€ì‹  dist[next_num] == 0 ì„ í•˜ë©´ í‹€ë¦¬ë‹¤.dist[í•´ë‹¹ ìˆ˜]ì—ëŠ” ì´ë™ íšŸìˆ˜ê°€ ë“¤ì–´ìˆê³  dist.count(í•´ë‹¹ ìˆ˜)ëŠ” í•´ë‹¹ ê²½ìš°ì˜ ìˆ˜ê°€ ëª‡ ë²ˆ ë‚˜ì™”ëŠ”ì§€ ì•Œë ¤ì£¼ê¸° ë•Œë¬¸ì´ë‹¤. mapì—ì„œ í•´ë‹¹ í‚¤, ê°’ì„ ë„£ì–´ì£¼ì§€ ì•Šì•˜ëŠ”ë° ë°”ë¡œ í•´ë‹¹ í‚¤ì— ëŒ€í•œ ê°’ì„ ì°¸ì¡°í•˜ë ¤ê³ (dist[next_num] == 0) í•˜ë©´ ì œëŒ€ë¡œ ì—°ì‚°ì´ ìˆ˜í–‰ë˜ì§€ ì•Šì„ ê²ƒì´ë‹¤. 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;queue&lt;int&gt; q;map&lt;int, int&gt; dist;void BFS(int start) &#123; q.push(start); dist[start] = 0; while (!q.empty()) &#123; int now_num = q.front(); q.pop(); string now = to_string(now_num); int zero = now.find('9'); // 0ì˜ ìœ„ì¹˜ int x = zero / 3; // í–‰ int y = zero % 3; // ì—´ for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; 3 &amp;&amp; d_y &lt; 3) &#123; string next = now; swap(next[x * 3 + y], next[d_x * 3 + d_y]); // ë¬¸ìì—´ ì¸ë±ìŠ¤(2ì°¨ì›-&gt;1ì°¨ì›) int next_num = stoi(next); if (dist.count(next_num) == 0) &#123; q.push(next_num); dist[next_num] = dist[now_num] + 1; &#125; &#125; &#125; &#125;&#125;int main() &#123; string s = \"\"; for (int i = 0; i &lt; 3; ++i) &#123; for (int j = 0; j &lt; 3; ++j) &#123; int num; cin &gt;&gt; num; if (num == 0) num = 9; s += to_string(num); &#125; &#125; int start = stoi(s); BFS(start); if (dist.count(123456789) == 0) cout &lt;&lt; -1 &lt;&lt; \"\\n\"; else cout &lt;&lt; dist[123456789] &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"ë°±ì¤€ 1261ë²ˆ ì•Œê³ ìŠ¤íŒŸ","slug":"Algorithm/BOJ/1261","date":"2020-01-25T04:04:31.000Z","updated":"2020-01-25T08:57:02.058Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/1261/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/1261/","excerpt":"","text":"1261. ì•Œê³ ìŠ¤íŒŸProblem ë¬¸ì œë§í¬ Solution ë²½ì„ ìµœì†Œí•œìœ¼ë¡œ ë¶€ìˆ˜ë©´ì„œ ëª©ì ì§€ì— ë„ì°©í•´ì•¼ í•œë‹¤. ë²½ì„ ë¶€ìˆ˜ì§€ ì•Šê³  ê°ˆ ê²½ìš° ë¹„ìš©ì€ 0 ë²½ì„ ë¶€ìˆ˜ê³  ê°ˆ ê²½ìš° ë¹„ìš©ì€ 1 ë”°ë¼ì„œ dequeë¥¼ ì‚¬ìš©í•˜ì—¬ BFS íƒìƒ‰ì„ í•œë‹¤. ë²½ì„ ë¶€ìˆ˜ì§€ ì•ŠëŠ” ê²½ìš° frontì— ë„£ëŠ”ë‹¤. ë²½ì„ ë¶€ìˆ˜ëŠ” ê²½ìš° backì— ë„£ëŠ”ë‹¤. front ë¶€ë¶„ì„ íƒìƒ‰í•˜ê³  popí•œë‹¤.ê·¸ë˜ì•¼ ë²½ì„ ìµœì†Œí•œìœ¼ë¡œ ë¶€ìˆ˜ë©´ì„œ visit(ë°©ë¬¸) í‘œì‹œê°€ ê°€ëŠ¥í•˜ë‹¤. 1 Try 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;tuple&gt;#include &lt;deque&gt;using namespace std;int N, M;int map[100][100];bool visit[100][100];int cnt[100][100];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1 ,1 &#125;;void Input() &#123; scanf(\"%d %d\", &amp;N, &amp;M); for (int i = 0; i &lt; M; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; scanf(\"%1d\", &amp;map[i][j]); &#125; &#125;&#125;void BFS() &#123; deque &lt;pair&lt;int, int&gt;&gt; q; q.push_front(&#123; 0, 0 &#125;); visit[0][0] = true; while (!q.empty()) &#123; int x, y; tie(x, y) = q.front(); q.pop_front(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x == N - 1 &amp;&amp; d_y == M - 1) &#123; cnt[d_x][d_y] = cnt[x][y]; return; &#125; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; M &amp;&amp; d_y &lt; N) &#123; if (visit[d_x][d_y]) continue; if (map[d_x][d_y] == 1) &#123; cnt[d_x][d_y] = cnt[x][y] + 1; q.push_back(&#123; d_x, d_y &#125;); &#125; else &#123; cnt[d_x][d_y] = cnt[x][y]; q.push_front(&#123; d_x, d_y &#125;); &#125; visit[d_x][d_y] = true; &#125; &#125; &#125;&#125;int main() &#123; Input(); BFS(); printf(\"%d\\n\", cnt[M - 1][N - 1]); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"Jenkins, NAVER Cloud Platform, Dockerë¡œ CI/CD ë¬´ì¤‘ë‹¨ ë°°í¬ í™˜ê²½ êµ¬ì¶•í•˜ê¸° - 2í¸","slug":"DevOps/cicd-2","date":"2020-01-21T13:06:11.000Z","updated":"2020-01-25T04:56:07.289Z","comments":true,"path":"2020/01/21/DevOps/cicd-2/","link":"","permalink":"https://doyuni.github.io/2020/01/21/DevOps/cicd-2/","excerpt":"","text":"2í¸ì—ì„œëŠ” CDì—ì„œ ë¬´ì¤‘ë‹¨ ë°°í¬ê¹Œì§€ êµ¬ì¶•í•œë‹¤. (1í¸ì—ì„œëŠ” Github Push í›„ì— Jenkinsê°€ ìë™ìœ¼ë¡œ ë¹Œë“œë˜ë„ë¡ ì„¤ì •í•˜ì˜€ë‹¤.) 2. Jenkinsë¡œ Node.jsê¸°ë°˜ í”„ë¡œì íŠ¸ ë°°í¬ ì„¤ì •í•˜ê¸°ë°°í¬ë¥¼ ìœ„í•´ scpë¥¼ ì‚¬ìš©í•˜ì—¬ Jenkinsì— ìˆëŠ” í”„ë¡œì íŠ¸ ì½”ë“œë¥¼ NAVER Cloud ì„œë²„ì— ë³µì‚¬í•´ì•¼ í•œë‹¤.Node.js ê¸°ë°˜ì˜ í”„ë¡œì íŠ¸ëŠ” Tomcatê³¼ ê°™ì€ WAS(ì›¹ ì„œë²„+ì›¹ ì»¨í…Œì´ë„ˆ)ê°€ ì¡´ì¬í•˜ì§€ ì•Šì•„ sshë¡œ ì ‘ì†, scpë¡œ íŒŒì¼ì„ ì£¼ê³  ë°›ëŠ” ì‘ì—…ìœ¼ë¡œ ë¹„êµì  ê°„ë‹¨íˆ ë°°í¬í•  ìˆ˜ ìˆë‹¤. 2-1. NAVER Cloud ì„œë²„ì—ë„ ssh í‚¤ë¥¼ ìƒì„±í•œë‹¤.1ssh-keygen -t rsa í‚¤ê°€ ìƒì„±ë˜ë©´ authorized_keys, id_rsa, id_rsa.pub, known_hosts ê°€ ìƒì„±ë˜ì–´ ìˆëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤. scpë¡œ íŒŒì¼ì„ ì£¼ê³  ë°›ëŠ”ë‹¤ í•˜ì˜€ëŠ”ë° ì´ë•Œ ë³µì‚¬ ë°›ì„ ì„œë²„ì˜ ì ‘ì† ë¹„ë°€ë²ˆí˜¸ë¥¼ ì•Œì•„ì•¼ í•œë‹¤. ê·¸ë ‡ê²Œë˜ë©´ ë³µì‚¬í•  ë•Œë§ˆë‹¤ ë§¤ë²ˆ ë¹„ë°€ë²ˆí˜¸ë¥¼ ìš”êµ¬í•˜ì—¬ ìë™í™” ë°°í¬ëŠ” ë¶ˆê°€ëŠ¥í•˜ê²Œ ëœë‹¤. ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ìœ„ì˜ 4ê°œì˜ í‚¤ë¥¼ ì´ìš©í•œë‹¤.Jenkinsì—ì„œëŠ” NAVER Cloud ì„œë²„ë¥¼ í˜¸ìŠ¤íŠ¸ë¡œ, NAVER Cloud ì„œë²„ì—ì„œëŠ” Jenkins ì„œë²„ì˜ ê³µê°œ í‚¤ë¥¼ í—ˆê°€ë°›ì€ í‚¤ë¡œ ë“±ë¡í•œë‹¤. ì´ëŸ¬ë©´ ë¹„ë°€ë²ˆí˜¸ë¥¼ ìš”êµ¬í•˜ì§€ ì•Šê³  ìë™í™” ë°°í¬ê°€ ê°€ëŠ¥í•˜ë‹¤. 2-2. Jenkins ì„œë²„ì—ì„œ NAVER Cloud ì„œë²„ë¥¼ known_hostsë¡œ ë“±ë¡í•œë‹¤.1ssh-keyscan -H (NAVER CLOUD ì„œë²„)ip &gt;&gt; ~/.ssh/known_hosts 2-3. Jenkinsì—ì„œ ìƒì„±í•œ í‚¤ ì¤‘ì— ê³µê°œ í‚¤(id_rsa.pub)ë¥¼ NAVER Cloud ì„œë²„ì—ì„œ ìƒì„±í•œ authorized_keysì— ì…ë ¥í•œë‹¤. Jenkins ì„œë²„ì˜ ê³µê°œ í‚¤ NAVER Cloud ì„œë²„ì˜ authorized_keys 1vi ~/.ssh/authorized_keys scpë¡œ í…ŒìŠ¤íŠ¸í•˜ê¸°ì ‘ì† ë¹„ë°€ë²ˆí˜¸ë¥¼ ìš”êµ¬í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ì„±ê³µì´ë‹¤. Jenkins ì„œë²„ì—ì„œ test.txt íŒŒì¼ì„ ìƒì„±í•œë‹¤. Jenkins ì„œë²„ì—ì„œ scpë¥¼ ì‚¬ìš©í•´ test.txtë¥¼ NAVER Cloud ì„œë²„ì˜ /root/test í´ë”ì— ë³µì‚¬í•œë‹¤.ë¹„ë°€ë²ˆí˜¸ë¥¼ ìš”êµ¬í•˜ì§€ ì•Šìœ¼ë©´ ì„±ê³µ. NAVER Cloud ì„œë²„ì—ì„œ ë³µì‚¬ëœ íŒŒì¼ì„ í™•ì¸í•œë‹¤. 3. NAVER Cloud ì„œë²„ì— Docker, NGINX ì„¤ì •í•˜ê¸°ì´ì œ í”„ë¡œì íŠ¸ê°€ ë°°í¬ë˜ëŠ” NAVER Cloud ì„œë²„ì—ì„œ ì„¤ì •í•´ì•¼ í•  ë¶€ë¶„ì´ë‹¤.(*Docker ë° NGINX ì„¤ì¹˜ëŠ” ìƒëµí•œë‹¤.) 3-1. Dockerfile ì‘ì„±.sshë¡œ ì„œë²„ì— ì ‘ì†í•˜ê³  Dockerfileì„ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•œë‹¤. 123456789101112131415FROM ì´ë¯¸ì§€ í™˜ê²½ MAINTAINER ê°œë°œì VOLUME í˜¸ìŠ¤íŠ¸ì™€ ê³µìœ í•  í´ë” RUN mkdir -p /app WORKDIR /app COPY ./í”„ë¡œì íŠ¸ ì†ŒìŠ¤ì½”ë“œ í´ë”/ /app RUN npm install CMD npm start FROM: Node ì´ë¯¸ì§€(Node version ëª…ì‹œ) MAINTAINER: ê°œë°œì(íŒ€ëª…) VOLUME: hostì™€ ì»¨í…Œì´ë„ˆê°€ ê³µìœ í•  í´ë” ê²½ë¡œ RUN: í•´ë‹¹ ëª…ë ¹ì–´ ì‹¤í–‰( ìœ„ì—ì„  app í´ë” ìƒì„± ) WORKDIR: ì‘ì—… ë””ë ‰í† ë¦¬ ì„¤ì •(ìœ„ì—ì„œ ë§Œë“  app í´ë”ë¡œ ì„¤ì •) COPY: NAVER Cloud ì„œë²„ì— ìˆëŠ” íŒŒì¼ì„ ì»¨í…Œì´ë„ˆ í´ë”ì— ë³µì‚¬ì„œë²„ì— ìˆëŠ” íŒŒì¼ì€ Dockerfileì´ ì¡´ì¬í•˜ëŠ” í˜„ì¬ ê²½ë¡œ ë‚´ì— ì¡´ì¬í•˜ëŠ” ê²ƒë§Œ ê°€ëŠ¥í•˜ë‹¤.(ì¦‰, ì ˆëŒ€ ê²½ë¡œëŠ” Dockerfileì´ ìˆëŠ” ê²½ë¡œ ì´ë‚´ê°€ ì•„ë‹ˆë¼ë©´ ë¶ˆê°€ëŠ¥) ê·¸ ë‹¤ìŒì€ íŒ¨í‚¤ì§€ íŒŒì¼ë“¤ì„ ì„¤ì¹˜í•˜ê³  ì„œë²„ë¥¼ ì‹¤í–‰í•œë‹¤. docker image build -t ë„ì»¤ì´ë¯¸ì§€ì´ë¦„ .ë¥¼ ì…ë ¥í•˜ì—¬ ì´ë¯¸ì§€ë¥¼ ë¹Œë“œí•œë‹¤. 3-2. Docker-compose ì‘ì„±í•˜ê¸°docker-compose(ì»¨í…Œì´ë„ˆ ê´€ë¦¬)ë¥¼ ì„¤ì¹˜í•˜ì—¬ í¸í•˜ê²Œ ì»¨í…Œì´ë„ˆë¥¼ ì„¤ì •í•œë‹¤.ì—¬ê¸°ì„œ blue-green ë°°í¬ ë°©ì‹ì´ ì‚¬ìš©ë˜ëŠ”ë°, ì´ëŠ” ë¬´ì¤‘ë‹¨ ë°°í¬ êµ¬ì¶•ì„ ìœ„í•¨ì´ë‹¤. Dockerfileì´ ìˆëŠ” ê³³ì— docker-compose.blue.ymlì„ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•œë‹¤. 123456789version: '2'services: linking-server: image: ë¹Œë“œí•œ ë„ì»¤ ì´ë¯¸ì§€ volumes: - ./deploy:/deploy/linking ports: - \"NAVER Cloud ì„œë²„ í¬íŠ¸:ì»¨í…Œì´ë„ˆ í¬íŠ¸\" image: ì•„ê¹Œ ë¹Œë“œí•œ ì´ë¯¸ì§€ ì´ë¦„ì„ ì‘ì„±í•œë‹¤. volumes: host í´ë”ì™€ ì»¨í…Œì´ë„ˆ í´ë”ë¥¼ ì„¤ì •í•˜ì—¬ ê³µìœ í•œë‹¤.(ì‹¬ë³¼ë¦­ ë§í¬ì™€ ë¹„ìŠ·í•œ ê°œë…ì´ë¼ê³  í•œë‹¤.) ports: host í¬íŠ¸ì™€ ì»¨í…Œì´ë„ˆ í¬íŠ¸ ìˆœìœ¼ë¡œ ì‘ì„±í•˜ì—¬ í¬íŠ¸ í¬ì›Œë”© ì„¤ì •ì„ í•œë‹¤. ê°™ì€ ê³³ì— docker-compose.green.ymlì„ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•œë‹¤.host í¬íŠ¸ë§Œ ë‹¤ë¥´ë‹¤. 3-3. deploy script ì‘ì„±í•˜ê¸°. ê°™ì€ ê³³ì— deploy.shë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•œë‹¤. 123456789101112131415161718192021#!/bin/bash DOCKER_APP_NAME=linking-server EXIST_BLUE=$(docker-compose -p $&#123;DOCKER_APP_NAME&#125;-blue -f docker-compose.blue.yml ps | grep Up) if [ -z \"$EXIST_BLUE\" ]; then echo \"blue up\" docker-compose -p $&#123;DOCKER_APP_NAME&#125;-blue -f docker-compose.blue.yml up -d sleep 10 docker-compose -p $&#123;DOCKER_APP_NAME&#125;-green -f docker-compose.green.yml downelse echo \"green up\" docker-compose -p $&#123;DOCKER_APP_NAME&#125;-green -f docker-compose.green.yml up -d sleep 10 docker-compose -p $&#123;DOCKER_APP_NAME&#125;-blue -f docker-compose.blue.yml downfi ì§€ê¸ˆê¹Œì§€ ì˜ ë”°ë¼ í–ˆë‹¤ë©´ ì•„ë˜ì™€ ë¹„ìŠ·í•œ ë””ë ‰í† ë¦¬ êµ¬ì¡°ë¥¼ ë³¼ ìˆ˜ ìˆì„ ê²ƒì´ë‹¤. ì»¨í…Œì´ë„ˆ ìƒì„±í•˜ê¸° docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml up -dë¥¼ ì…ë ¥í•˜ì—¬ blue ì»¨í…Œì´ë„ˆë¥¼ ë¨¼ì € ìƒì„±í•´ì¤€ë‹¤. docker ps -aë¡œ ì»¨í…Œì´ë„ˆê°€ ì˜ ì‹¤í–‰ë˜ê³  ìˆëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆë‹¤. 3-4. NGINX ì„¤ì •í•˜ê¸°.ë‹¤ìŒì€ NGINXë¡œ blue, greenì˜ ë¡œë“œë°¸ëŸ°ì‹±ì„ ì„¤ì •í•´ ì£¼ì–´ì•¼ í•œë‹¤. vi /etc/nginx/sites-available/linking-serverë¥¼ ì…ë ¥í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•œë‹¤.linking-serverëŠ” í•„ìê°€ ì •í•œ ì´ë¦„ì´ë‹¤. 12345678910111213# Load Balancingupstream linking-server &#123; least_conn; server 127.0.0.1:1025 weight=5 max_fails=3 fail_timeout=10s; server 127.0.0.1:1026 weight=10 max_fails=3 fail_timeout=10s;&#125;server &#123; listen 1024; server_name NAVER Cloud ì„œë²„ ì•„ì´í”¼; location / &#123; proxy_pass http://linking-server; &#125;&#125; ê·¸ëŸ° ë‹¤ìŒ ì•„ë˜ ëª…ë ¹ì–´ë¡œ ì´ íŒŒì¼ì„ /etc/nginx/sites-enabled ë””ë ‰í„°ë¦¬ì— ë§í¬í•´ì¤€ë‹¤. sudo ln -fs /etc/nginx/sites-available/linking-server /etc/nginx/sites-enabled/ ë§ˆì§€ë§‰ìœ¼ë¡œ sudo nginx -t ëª…ë ¹ì–´ë¡œ ë¬¸ë²• ì´ìƒ ìœ ë¬´ë¥¼ í™•ì¸í•˜ê³  ì´ìƒì´ ì—†ì„ ê²½ìš°, systemctl stop nginx ëª…ë ¹ì–´ë¡œ NGINXë¥¼ ì¢…ë£Œí•œ í›„ì— systemctl start nginx ë¡œ ë‹¤ì‹œ ì‹œì‘í•œë‹¤. 3-5. NAVER Cloud Platform ACG ì„¤ì •í•˜ê¸°.ì—¬ê¸°ì„œ ë§ˆì§€ë§‰ìœ¼ë¡œ í•œ ê°€ì§€ í•´ì•¼í•  ê²ƒì€ ACG ì„¤ì •ì´ë‹¤. ACG ì„¤ì •í•˜ê¸° NAVER Cloud Platform ì½˜ì†”ì—ì„œ 1024í¬íŠ¸ë¥¼ ì—´ì–´ì¤€ë‹¤. ìœ„ì—ì„œ blue, green ëª¨ë‘ ë‹¤ë¥¸ í¬íŠ¸ì§€ë§Œ NGINXë¥¼ í†µí•´ 1024 í¬íŠ¸ë¡œ ë¡œë“œ ë°¸ëŸ°ì‹± ë˜ê¸°ì— ì‚¬ìš©ìëŠ” ì´ë¥¼ í†µí•´ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.(ë³´í†µ ë°±ì—”ë“œì™€ í”„ë¡ íŠ¸ì—”ë“œë¥¼ ë¶„ë¦¬í•˜ë©´ì„œ í”„ë¡œì íŠ¸ë¥¼ ì§„í–‰í•˜ê³  ìˆë‹¤ë©´ í”„ë¡ íŠ¸ì—”ë“œëŠ” 80í¬íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ”ê²Œ ì¢‹ë‹¤. 80ì´ ê¸°ë³¸ í¬íŠ¸ë¼ ìƒëµ ê°€ëŠ¥í•˜ë¯€ë¡œ) ì´ê²ƒìœ¼ë¡œ NAVER Cloud ì„œë²„ì—ì„œì˜ ì„¤ì •ì€ ëë‚¬ë‹¤. 4. ë§ˆì§€ë§‰ ì‘ì—…ì´ì œ ë§ˆì§€ë§‰ Jenkinsì—ì„œ ë¹Œë“œí•  ë•Œ ì„¤ì •ì„ í•´ì£¼ì–´ì•¼ ìœ„ì—ì„œ ì„¤ì •í•œ ë¬´ì¤‘ë‹¨ ë°°í¬ê°€ ìë™í™”ëœë‹¤. Jenkins í”„ë¡œì íŠ¸ ê´€ë¦¬ì—ì„œ â€œExecute managed scriptâ€ë¥¼ í´ë¦­í•œë‹¤.ë‹¤ë§Œ, ì•„ì§ ì‘ì„±í•œ ìŠ¤í¬ë¦½íŠ¸ê°€ ì—†ê¸°ì— Jenkins ê´€ë¦¬ &gt; Managed files &gt; Add a new Configë¥¼ í†µí•´ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‘ì„±í•œë‹¤. ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•œë‹¤. 123456789101112131415#!/bin/shssh -T root@ì„œë²„ ì•„ì´í”¼ &lt;&lt;EOF rm -rf /home/docker-image/deploy/* exitEOF scp -r /var/lib/jenkins/jobs/LinkingCI/workspace/* root@ì„œë²„ ì•„ì´í”¼:/home/docker-image/deploy/ #!/bin/shssh -T root@ì„œë²„ ì•„ì´í”¼ &lt;&lt;EOF cd /home/docker-image docker image build -t linking-server-docker-image . ./deploy.sh exitEOF 1) Jenkinsê°€ ë¹Œë“œ ë™ì•ˆ í•´ë‹¹ ì„œë²„ì— ì ‘ì†í•˜ì—¬ ì›ë˜ ìˆë˜ ì• í”Œë¦¬ì¼€ì´ì…˜ ì½”ë“œë¥¼ ì‚­ì œí•œë‹¤. 2) ë¹Œë“œëœ íŒŒì¼ì„ í•´ë‹¹ ì„œë²„ì— ë³µì‚¬í•œë‹¤. 3) í•´ë‹¹ ì„œë²„ì— ë‹¤ì‹œ ì ‘ì†í•˜ì—¬ ìƒˆë¡œ ë³µì‚¬ëœ íŒŒì¼ì„ í† ëŒ€ë¡œ ë„ì»¤ ì´ë¯¸ì§€ë¥¼ ë¹Œë“œí•œë‹¤. 4) ë°°í¬ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‹¤í–‰í•œë‹¤. ìœ„ì™€ ê°™ì€ ê³¼ì •ì´ ì¼ì–´ë‚˜ê³  ì§€ê¸ˆê¹Œì§€ ì„¤ì •í•œ ê²ƒë“¤ì´ ëª¨ë‘ ìë™í™”ë˜ì–´ ë¬´ì¤‘ë‹¨ ë°°í¬ê¹Œì§€ ì§„í–‰ëœë‹¤. ì´ë¥¼ ì´ì œ Jenkins í”„ë¡œì íŠ¸ ê´€ë¦¬ì—ì„œ ì‹¤í–‰í•˜ë„ë¡ í•œë‹¤. 5. ë¹Œë“œ ìƒíƒœ í‘œì‹œ, Slack ì•Œë¦¼ì¶”ê°€ë¡œ í”„ë¡œì íŠ¸ì—ì„œ ë³´ì´ëŠ” Embeddable Build Statusë¥¼ í´ë¦­í•˜ë©´ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ Github ë ˆí¬ì§€í† ë¦¬ì— ë¹Œë“œ ìƒíƒœë°”ë¥¼ ë³´ì´ê²Œ í•  ìˆ˜ ìˆë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ íŒ€ì›ë“¤ì´ ë¹Œë“œ ìƒíƒœ(ì‹œì‘, ì‹¤íŒ¨, ì„±ê³µ)ì„ ì•Œê³  ì‹¶ì„ ë•Œ Slackì„ í†µí•´ ì•Œë¦¼ì„ ë°›ë„ë¡ í•  ìˆ˜ë„ ìˆë‹¤.1í¸ì—ì„œ ì´ë¯¸ ê´€ë ¨ í”ŒëŸ¬ê·¸ì¸ì„ ì„¤ì¹˜í•˜ì˜€ê¸°ì— ë°”ë¡œ ì„¤ì •ì´ ê°€ëŠ¥í•˜ë‹¤. Slackì— ì±„ë„ì„ ë§Œë“¤ì—ˆë‹¤ë©´ Appsì—ì„œ Jenkinsë¥¼ ê²€ìƒ‰ í›„ í´ë¦­í•œë‹¤. ì•Œë¦¼ì„ ë°›ì„ ì±„ë„ì„ ì„¤ì •í•˜ë©´ Jenkinsì—ì„œ ì–´ë–»ê²Œ ì„¤ì •í•´ì•¼ í•˜ëŠ”ì§€ ì¹œì ˆí•˜ê²Œ ë‚˜ì˜¨ë‹¤. ì„¤ì •ì„ í•˜ê³  ë‚˜ë©´ Jenkins í”„ë¡œì íŠ¸ì—ì„œ ë¹Œë“œ í›„ ì¡°ì¹˜ì— ì•Œë¦¼ ë°›ì„ ë‚´ì—­ì„ ì„¤ì •í•  ìˆ˜ê°€ ìˆê²Œ ëœë‹¤. ë¹Œë“œ ì‹œì‘ë¶€í„° ëê¹Œì§€ ì•Œë¦¼ì´ ë‚ ë¼ì˜¨ë‹¤. ì´ê²ƒìœ¼ë¡œ CI/CD ë¬´ì¤‘ë‹¨ ë°°í¬ í™˜ê²½ êµ¬ì¶•ì„ ë§ˆì¹œë‹¤. -ë-","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://doyuni.github.io/categories/DevOps/"},{"name":"CI/CD","slug":"DevOps/CI-CD","permalink":"https://doyuni.github.io/categories/DevOps/CI-CD/"}],"tags":[{"name":"NAVER CLOUD","slug":"NAVER-CLOUD","permalink":"https://doyuni.github.io/tags/NAVER-CLOUD/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://doyuni.github.io/tags/Jenkins/"},{"name":"Docker","slug":"Docker","permalink":"https://doyuni.github.io/tags/Docker/"},{"name":"NGINX","slug":"NGINX","permalink":"https://doyuni.github.io/tags/NGINX/"}]},{"title":"Jenkins, NAVER Cloud Platform, Dockerë¡œ CI/CD ë¬´ì¤‘ë‹¨ ë°°í¬ í™˜ê²½ êµ¬ì¶•í•˜ê¸° - 1í¸","slug":"DevOps/cicd-1","date":"2020-01-21T13:01:34.000Z","updated":"2020-01-25T04:56:07.287Z","comments":true,"path":"2020/01/21/DevOps/cicd-1/","link":"","permalink":"https://doyuni.github.io/2020/01/21/DevOps/cicd-1/","excerpt":"","text":"ì´ë²ˆ ë‚´ìš©ì€ í•„ìê°€ í”„ë¡œì íŠ¸ë¥¼ ì§„í–‰í•˜ë©´ì„œ ì²˜ìŒìœ¼ë¡œ DevOpsë¥¼ ë§¡ìœ¼ë©´ì„œ ê¼­ ê³µìœ  í•˜ê² ë‹¤ê³  ë§ˆìŒ ë¨¹ê³  ì‘ì„±í•˜ì˜€ë‹¤. CI/CDë€? CI(Continuous Integration)ì§€ì†ì ì¸ í†µí•©ì„ ì˜ë¯¸í•œë‹¤. ì´ëŠ” ê°œë°œìë¥¼ ìœ„í•œ ìë™í™” í”„ë¡œì„¸ìŠ¤ ì¤‘ í•˜ë‚˜ì´ë©° ì–´í”Œë¦¬ì¼€ì´ì…˜ì„ ë³€ê²½í•  ë•Œ ìë™ìœ¼ë¡œ ë¹Œë“œ ë° í…ŒìŠ¤íŠ¸ë˜ì–´ Github ê³µìœ  ë ˆí¬ì§€í† ë¦¬ì— ë³‘í•©ëœë‹¤. ê·¸ë ‡ê¸°ì— í˜‘ì—… ì‹œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì¶©ëŒë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤. CD(Continuous Deployment)ì§€ì†ì ì¸ ë°°í¬ë¥¼ ì˜ë¯¸í•œë‹¤. ì–´í”Œë¦¬ì¼€ì´ì…˜ ë³€ê²½ ì‚¬í•­ì´ ë°˜ì˜ëœ ê³µìœ  ë ˆí¬ì§€í† ë¦¬ì—ì„œ ì‚¬ìš©ìê°€ ì‚¬ìš© ê°€ëŠ¥í•œ í™˜ê²½ê¹Œì§€ ìë™ìœ¼ë¡œ ë°°í¬í•˜ëŠ” ê²ƒì„ ë§í•œë‹¤. ì´ë¥¼ í†µí•´ ì–´í”Œë¦¬ì¼€ì´ì…˜ì„ ì›í™œíˆ ê·¸ë¦¬ê³  ë” ë¹ ë¥´ê²Œ ì œê³µí•˜ë¯€ë¡œì¨ ì‚¬ìš©ìì˜ í”¼ë“œë°±ì„ ë¹ ë¥´ê²Œ ë°˜ì˜í•  ìˆ˜ ìˆë‹¤. ì•„ë˜ëŠ” í•„ìê°€ ë§¡ì€ í”„ë¡œì íŠ¸ì˜ ì „ì²´ ì‹œìŠ¤í…œ êµ¬ì¡°ì´ë©´ì„œ ë™ì‹œì—, CI/CD ê³¼ì •ì„ ë³¼ ìˆ˜ ìˆë‹¤. ì „ì²´ ì‹œìŠ¤í…œ êµ¬ì¡° ëŒ€ë¶€ë¶„ Travis CI, AWS, Docker, NGINXë¥¼ ì‚¬ìš©í•˜ì—¬ CI/CD ë¬´ì¤‘ë‹¨ ë°°í¬ë¥¼ êµ¬ì¶•í•œë‹¤ëŠ” ì ì—ì„œ ë¹„êµí•˜ì—¬ ë³´ì•„ë„ ì¢‹ì„ ê²ƒì´ë‹¤. ì„ íƒì˜ ìˆœê°„ë“¤AWSê°€ ì•„ë‹Œ NAVER CLOUD ì„ íƒAWSì™€ NAVER Cloud Platformì„ ì‚¬ìš©í•´ ë³´ë©´ì„œ ëŠë‚€ ê²ƒì€ í™•ì‹¤íˆ AWSì˜ ê¸°ëŠ¥ì´ í›¨ì”¬ ë§ê³  ìœ ìš©í•˜ë‹¤.ê·¸ëŸ¼ì—ë„ NAVER Cloud Platformì„ ì‚¬ìš©í•œ ê²ƒì€ 40ë§Œ í¬ë ˆë”§(ì§€ì› ë°›ì•˜ë‹¤.)ì´ ì œì¼ ì»¸ë‹¤.AWSì—ëŠ” ë¬´ì¤‘ë‹¨ ë°°í¬ê¹Œì§€ ì§€ì›í•˜ëŠ” ì„œë¹„ìŠ¤ì¸ Blue-Green Deploymentê°€ ìˆëŠ”ë° ë°˜í•´ NAVER CloudëŠ” ì—†ë‹¤â€¦ê·¸ëŸ¼ êµ³ì´ ì™œ AWSë¥¼ ì„ íƒí•˜ì§€ ì•Šì•˜ëƒê³  í•  ìˆ˜ ìˆëŠ”ë° ë‚´ê°€ ì§ì ‘ ì„¤ì •í•´ì„œ êµ¬ì¶•í•˜ê³  ì‹¶ì—ˆê¸° ë•Œë¬¸ì´ë‹¤. (ì‚¬ì„œ ê³ ìƒí•œë‹¤ëŠ” ì–˜ê¸°) Travisê°€ ì•„ë‹Œ Jenkins ì„ íƒTravis referenceë§Œ ë³´ì•„ë„ AWSë‘ ì–¼ë§ˆë‚˜ ì£½ì´ ì˜ ë§ëŠ”ì§€ë¥¼ ì•Œ ìˆ˜ ìˆë‹¤. (AWSë§ê³ ë„ Google Cloud, Azureë„ ì§€ì›í•œë‹¤.) ì´ë¯¸ NAVER Cloudë¥¼ ì„ íƒí•œ ì´ìƒ TravisëŠ” ë” ì–´ë ¤ìš´ ë°©ë²•ìœ¼ë¡œ ê°€ëŠ” ê¸¸ì´ë¼ ìƒê°í–ˆë‹¤. ì˜¤íˆë ¤ ì„¤ì •í•  ìˆ˜ ìˆëŠ” ë²”ìœ„ê°€ ë„“ì€ Jenkinsë¥¼ íƒí•˜ëŠ” ê²ƒì´ ì‰½ë‹¤ê³  íŒë‹¨í•˜ì˜€ë‹¤. ì²˜ìŒì— AWSì™€ Travisë¡œ ìë™í™” ë°°í¬ í™˜ê²½ êµ¬ì¶•ì„ ì—°ìŠµí–ˆì—ˆëŠ”ë°, ê°œì¸ì ì¸ ì…ì¥ìœ¼ë¡œëŠ” Jenkinsê°€ ì¢€ ë” ì‰¬ìš´ ê²ƒ ê°™ë‹¤. 40ë§Œ í¬ë ˆë”§ì˜ ìœ„ì—„ìœ¼ë¡œ Jenkinsë¥¼ ë„ì»¤ê°€ ì•„ë‹Œ Naver Cloudë¡œ ì„œë²„ë¥¼ ë”°ë¡œ êµ¬ì¶•í–ˆë‹¤. ì§€ê¸ˆ ìƒê°í•´ë³´ë©´ ìì› ë‚­ë¹„ì¸ ì…ˆì´ì§€ë§Œ ì•ˆì •ì„± ì¸¡ë©´ì—ì„œëŠ” ë”°ë¡œ ì„œë²„ë¥¼ ë‘ëŠ” ê²ƒì´ ì¢‹ë‹¤. í™˜ê²½ êµ¬ì¶•í•˜ê¸°NAVER Cloud ì‚¬ìš© ì„¤ëª…ì„œëŠ” ë¬´ì²™ ì˜ ë˜ì–´ ìˆê³  AWSì˜ EC2ë‚˜ S3ì™€ ê°™ì€ ê°œë…ê³¼ ë˜‘ê°™ê¸°ì— ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì„¤ì •í•˜ë©´ ëœë‹¤. NAVER Cloudì˜ Server = AWSì˜ EC2 NAVER Cloudì˜ Object Storage = AWSì˜ S3 ì•„ë˜ì™€ ê°™ì´ SourcePipeline ì„œë¹„ìŠ¤ë¥¼ ì´ìš©í•˜ë©´ Githubì—ì„œ pushí•œ ê²ƒì„ ìë™ìœ¼ë¡œ ë¹Œë“œí•˜ê³  ë°°í¬í•  ìˆ˜ ìˆëŠ”ë°, ì•„ë˜ ì‚¬ì§„ ìš°ì¸¡ ìƒë‹¨ì— ë³´ì´ëŠ” íŒŒì´í”„ë¼ì¸ ì‹¤í–‰í•˜ê¸°ë¥¼ ë§¤ë²ˆ í´ë¦­í•´ì¤˜ì•¼ í•œë‹¤â€¦ë‚´ê°€ ì›í•œê±´ pushë§Œ í•´ë„ ìë™í™” ë¹Œë“œ ë° ë°°í¬ì´ë‹¤. ê²°êµ­ ì´ê±¸ ì ‘ê³  Jenkinsì™€ NAVER Cloudì˜ Serverë§Œ ì‚¬ìš©í•˜ê¸°ë¡œ ê²°ì •í–ˆë‹¤. 1. Jenkins ì„¤ì •í•˜ê¸°Dockerë¡œ Jenkins ì„œë²„ë¥¼ ìš´ì˜í•´ë„ ë˜ì§€ë§Œ NAVER Cloudì—ì„œ ë‹¤ìŒê³¼ ê°™ì´ ì§€ì›í•˜ê¸°ì— ì‚¬ìš©í•˜ì˜€ë‹¤.ë‹¤ë§Œ ìˆ˜ë™ìœ¼ë¡œ ìµœì‹  ì—…ë°ì´íŠ¸ í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤. 1-1. Jenkins ë³´ì•ˆ ì„¤ì •JenkinsëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë³´ì•ˆ ì„¤ì •ì´ ë˜ì–´ìˆì§€ ì•Šë‹¤.Jenkins ê´€ë¦¬ &gt; Configure Global Securityì—ì„œ ì„¤ì •í•  ìˆ˜ ìˆë‹¤. ì²˜ìŒì— ì‚¬ìš©ìì˜ ê°€ì…ì„ í—ˆìš©í•˜ì—¬ admin ê³„ì •ì„ ìƒì„±í•œë‹¤. íŒ€ì›ê³¼ í•¨ê»˜ ì‘ì—…í•œë‹¤ë©´ íŒ€ì› ê°ê° ê³„ì • ìƒì„±í•˜ë„ë¡ ë‘”ë‹¤. ê³„ì • ìƒì„±ì„ ëëƒˆìœ¼ë©´ â€˜Matrix-based securityâ€™ë¥¼ ì ì ˆíˆ ì„¤ì •í•œë‹¤. (ì—†ë‹¤ë©´ Matrix Authorization Strategy Pluginë¥¼ ì„¤ì¹˜í•˜ì.)í•„ìëŠ” ìµëª…ì—ê²Œ ì½ê¸° ê¶Œí•œ ì¤‘ Job(Jenkins ì‘ì—… ë‹¨ìœ„) ë¶€ë¶„ë§Œ ë³¼ ìˆ˜ ìˆê²Œ í•˜ì˜€ë‹¤. ì´ëŠ” ë‚˜ì¤‘ì— ì„¤ì •í•  Githubì˜ build statusë¥¼ ë³´ì—¬ì£¼ê¸° ìœ„í•¨ì´ë‹¤.ê·¸ë¦¬ê³  í˜¼ì í™˜ê²½ êµ¬ì¶•ì„ ë‹´ë‹¹ í•˜ì˜€ê¸°ì— íŒ€ì› ê³„ì • ì—­ì‹œ ìµëª…ê³¼ ê°™ì€ ê¶Œí•œì„ ì£¼ì—ˆë‹¤. 1-2. í”ŒëŸ¬ê·¸ì¸ ì„¤ì¹˜í•˜ê¸°Jenkins ê´€ë¦¬ &gt; í”ŒëŸ¬ê·¸ì¸ ê´€ë¦¬ Github plugin: Jenkinsì™€ Github í†µí•© Global Slack Notifier Plugin: Slack ì—°ë™(Job ì•Œë¦¼ ì„¤ì •) Publish Over SSH: sshë¡œ ë¹Œë“œ íŒŒì¼ ë³´ë‚´ê¸° Embeddable Build Status Plugin: Github ë ˆí¬ì§€í† ë¦¬ì— ë¹Œë“œ ìƒíƒœë°” ìƒì„± Managed Scripts: Node.js ê¸°ë°˜ì˜ ì„œë²„ë¥¼ ë°°í¬í•˜ê¸° ìœ„í•œ ìŠ¤í¬ë¦½íŠ¸ 1-3. Jenkins Global ì„¤ì •í•˜ê¸°Jenkins ê´€ë¦¬ &gt; ì‹œìŠ¤í…œ ì„¤ì • &gt; GitHub Serversì—ì„œ ë‹¤ìŒê³¼ ê°™ì´ ì„¤ì •í•œë‹¤. Credentials ì„¤ì •ì„ ìœ„í•´ ìì‹ ì˜ Github &gt; Settings &gt; Developer settings &gt; Personal access tokensì—ì„œ ë‹¤ìŒê³¼ ê°™ì´ í† í°ì„ ìƒì„±í•œë‹¤. ìƒì„± í›„ í™”ë©´ì— ë³´ì´ëŠ” secret ë¬¸ìì—´ì„ ì•„ë˜ì˜ Secretì— ì…ë ¥í•œë‹¤. 1-4. í”„ë¡œì íŠ¸ ìƒì„± ë° ì„¤ì •í•˜ê¸°ìƒˆë¡œìš´ Itemì„ í´ë¦­í•˜ê³  í”„ë¡œì íŠ¸ ì´ë¦„ì„ ì…ë ¥, Freestyleì„ ëˆ„ë¥¸ë‹¤. ë‹¤ìŒê³¼ ê°™ì´ í”„ë¡œì íŠ¸ urlì„ ì…ë ¥í•˜ê³  Credentialsë¥¼ ì„¤ì •í•œë‹¤. ì´ ì‘ì—…ì€ Githubì„ ì—°ë™í•˜ëŠ” ê²ƒì¸ë°, IDì™€ PWë¡œ ì—°ë™í•˜ë©´ ë³´ì•ˆì— ì·¨ì•½í•˜ê¸°ì— sshí‚¤ë¡œ ì—°ë™í•˜ì˜€ë‹¤. ssh í‚¤ ìƒì„±í•˜ê¸° sshë¡œ Jenkins ì„œë²„ì— ì›ê²© ì ‘ì†í•˜ì—¬ ë‹¤ìŒì„ ì…ë ¥í•œë‹¤.1ssh-keygen -t rsa -f id_rsa id_rsa, id_rsa.pub ë¥¼ í¬í•¨í•´ ì´ 4ê°œì˜ í‚¤ê°€ ìƒì„±ëœë‹¤. ì•„ë˜ Add í‘œì‹œë¥¼ ëˆŒëŸ¬ cat ~/.ssh/id_rsa ì…ë ¥ í›„ ë‚˜ì˜¤ëŠ” private keyë¥¼ ë„£ì–´ì¤€ë‹¤ BEGIN ~ë¶€í„° ëª¨ë‘ ë³µì‚¬í•˜ì—¬ ì…ë ¥í•œë‹¤. Githubì— ê³µê°œ í‚¤ ë“±ë¡í•˜ê¸°. cat ~/.ssh/id_rsa.pub ë¥¼ ì…ë ¥í•˜ë©´ ë‚˜ì˜¤ëŠ” ê³µê°œ í‚¤ë¥¼ í”„ë¡œì íŠ¸ ë ˆí¬ì§€í† ë¦¬ì˜ Setting &gt; Deploy keysì— ë“±ë¡í•œë‹¤. ì´ì œ Jenkinsê³¼ Githubì„ ì—°ë™ì‹œì¼°ê¸°ì—, Jenkinsì— ì½”ë“œë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ìˆê²Œ ë˜ì—ˆë‹¤. ë‹¤ìŒìœ¼ë¡œëŠ” pushí–ˆì„ ë•Œ Jenkinsê°€ push ì´ë²¤íŠ¸ë¥¼ ë°›ì„ ìˆ˜ ìˆë„ë¡ ì„¤ì • í•´ë³´ì.ë§ˆì°¬ê°€ì§€ë¡œ ë ˆí¬ì§€í† ë¦¬ì˜ setting &gt; webhooks ì—ì„œ ë¹¨ê°„ìƒ‰ ë„¤ëª¨ë°•ìŠ¤ì— Jenkins ip ì£¼ì†Œë¥¼ ì…ë ¥í•˜ê³  ë‚˜ë¨¸ì§€ëŠ” ê·¸ëŒ€ë¡œ ì…ë ¥í•œë‹¤. Githubì—ì„œì˜ ì„¤ì •ì€ ëë‚¬ê³  Jenkins í”„ë¡œì íŠ¸ì—ì„œ ë‹¤ìŒì„ ì²´í¬í•¨ìœ¼ë¡œì¨ ì´ë²¤íŠ¸ ì„¤ì •ì€ ëì´ ë‚¬ë‹¤.ì´ì   pushë§Œ í•˜ë©´ Jenkins í•´ë‹¹ í”„ë¡œì íŠ¸ì—ì„œ ë¹Œë“œê°€ ì‹œì‘ë¨ì„ ë³¼ ìˆ˜ ìˆë‹¤. ë¹Œë“œ ê¸°ë¡ì„ í†µí•´ ì†ŒìŠ¤ ì½”ë“œê°€ ë¹Œë“œ ì¤‘ì¸ì§€ ë¹Œë“œ ì™„ë£Œ ë˜ì—ˆëŠ”ì§€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ì´ê²ƒìœ¼ë¡œ Jenkinsë¡œ CI í™˜ê²½ êµ¬ì¶•ì€ ëì´ ë‚¬ë‹¤. 2í¸ì—ì„œëŠ” CD í™˜ê²½ êµ¬ì¶•ê³¼ ë¬´ì¤‘ë‹¨ ë°°í¬ë¥¼ êµ¬ì¶•í•´ë³´ê² ë‹¤.","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://doyuni.github.io/categories/DevOps/"},{"name":"CI/CD","slug":"DevOps/CI-CD","permalink":"https://doyuni.github.io/categories/DevOps/CI-CD/"}],"tags":[{"name":"NAVER CLOUD","slug":"NAVER-CLOUD","permalink":"https://doyuni.github.io/tags/NAVER-CLOUD/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://doyuni.github.io/tags/Jenkins/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://doyuni.github.io/tags/CI-CD/"}]}]}