{"meta":{"title":"JUST WRITE IT.","subtitle":"","description":"","author":"Geum Doyun","url":"https://doyuni.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-01-20T12:25:32.000Z","updated":"2020-01-25T04:38:20.526Z","comments":true,"path":"tags/index.html","permalink":"https://doyuni.github.io/tags/index.html","excerpt":"","text":"CI/CD Docker Jenkins NAVER CLOUD NGINX Algorithm"},{"title":"categories","date":"2020-01-20T12:25:42.000Z","updated":"2020-01-25T04:38:20.521Z","comments":true,"path":"categories/index.html","permalink":"https://doyuni.github.io/categories/index.html","excerpt":"","text":"DevOps CI/CD Algorithm BOJ Programmers SWEA"}],"posts":[{"title":"백준 11559번 Puyo Puyo","slug":"Algorithm/BOJ/11559","date":"2020-01-25T04:30:32.000Z","updated":"2020-01-25T08:58:11.135Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/11559/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/11559/","excerpt":"","text":"#11559. Puyo Puyo문제링크 Problem 뿌요는 바닥이나 다른 뿌요가 있을 때까지 아래로 떨어짐 뿌요가 놓여지고 같은 색 뿌요가 4개 이상 상하좌우로 연결되어 있으면연결된 같은 색 뿌요들이 모두 사라진다. 위 과정이 반복되면 1연쇄씩 늘어난다. (터지는 그룹이 동시에 여럿이라도 1연쇄) 입력 12*6의 문자 .은 빈공간 이외 뿌요 색깔 R, G, B, P, Y 뿌요들이 전부 아래로 떨어진 뒤의 상태가 주어짐 Goal: 몇 연쇄가 되는지 출력, 안터지면 0 출력 Solution다음과 같은 과정이 일어난다. 현재 map에서 터뜨릴 수 있는 것들 터뜨리기 아래로 떨어뜨리기 위 과정 반복하기(더이상 터뜨릴 수 없는 경우 종료) 터뜨리기 BFS를 활용하여 4개 이상 연속인지 확인을 한다. void bfs(현재 위치) 탐색용도 queue와 지울(터뜨릴)용도 queue 선언 현재 위치 넣어주고, check 탐색용도 queue를 전부 비울 때까지 탐색 탐색이 끝나면(더이상 갈 때가 없는 것) 지울 용도의 queue 크기가 4이상이면 터뜨리기 bfs 탐색이 끝나면 다음과 같이 4개 연속인 것들 터뜨리기 12345678void changeMap(queue&lt;pair&lt;int, int&gt;&gt; &amp;erase) &#123; while (!erase.empty()) &#123; int r = erase.front().first; int c = erase.front().second; erase.pop(); map[r][c] = '.'; &#125;&#125; 이 과정이 모든 map의 각 행과 열에서 이루어지면 그때 아래로 떨어뜨린다.(모든 위치에서 BFS탐색이 끝난 경우) 아래로 떨어뜨리기 Queue를 이용하여 맨 아래에서 부터 위로 탐색을 시작하여 . 인 지점을 순서대로 넣어준다. . 이 아니라면 queue에 들어간 순서대로 위치를 교환한다.1234567891011121314151617void update() &#123; for (int i = 0; i &lt; 6; ++i) &#123; queue&lt;pair&lt;int, int&gt;&gt; point; for (int j = 11; j &gt;= 0; --j) &#123; if (map[j][i] == '.') point.push(&#123; j, i &#125;); else &#123; if (point.empty()) continue; int x = point.front().first; int y = point.front().second; point.pop(); map[x][y] = map[j][i]; map[j][i] = '.'; point.push(&#123; j, i &#125;); &#125; &#125; &#125;&#125; 1 Try 틀린 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;char map[12][6];bool check[12][6];int answer, len;bool flag, loop = true;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; 12 &amp;&amp; c &lt; 6) return true; return false;&#125;void update() &#123; for (int i = 0; i &lt; 6; ++i) &#123; queue&lt;pair&lt;int, int&gt;&gt; point; for (int j = 11; j &gt;= 0; --j) &#123; if (map[j][i] == '.') point.push(&#123; j, i &#125;); else &#123; if (point.empty()) continue; int x = point.front().first; int y = point.front().second; point.pop(); map[x][y] = map[j][i]; map[j][i] = '.'; point.push(&#123; j, i &#125;); &#125; &#125; &#125;&#125;void changeMap(queue&lt;pair&lt;int, int&gt;&gt; erase) &#123; while (!erase.empty()) &#123; int r = erase.front().first; int c = erase.front().second; erase.pop(); map[r][c] = '.'; &#125;&#125;void dfs(int r, int c, queue&lt;pair&lt;int, int&gt;&gt; erase) &#123; check[r][c] = true; erase.push(&#123; r, c &#125;); bool flag = false; for (int i = 0; i &lt; 4; ++i) &#123; int x = r + dx[i]; int y = c + dy[i]; if (isBound(x, y) &amp;&amp; !check[x][y] &amp;&amp; map[x][y] == map[r][c] &amp;&amp; map[r][c] != '.') &#123; check[x][y] = true; flag = true; erase.push(&#123; x, y &#125;); len++; dfs(x, y, erase); &#125; &#125; if (!flag &amp;&amp; len &gt;= 4) &#123; loop = true; changeMap(erase); &#125;&#125;int main() &#123; for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; scanf(\" %c\", &amp;map[i][j]); &#125; &#125; queue&lt;pair&lt;int, int&gt;&gt; erase; while (loop) &#123; loop = false; memset(check, 0, sizeof(check)); for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; if (map[i][j] != '.' &amp;&amp; !check[i][j]) &#123; len = 1; dfs(i, j, erase); &#125; &#125; &#125; if (loop) &#123; update(); answer++; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; DFS로 하니까 map에서 연속인 것들을 제대로 지우지 못 한다는 것을 깨닫고(실제 값 확인해보면 erase queue에 연속적으로 못 넣고 return하게 됨) BFS를 사용하여 쉽게 풀었다..(진작에 할걸) 2 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;char map[12][6];bool check[12][6];bool loop = true;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; 12 &amp;&amp; c &lt; 6) return true; return false;&#125;void update() &#123; for (int i = 0; i &lt; 6; ++i) &#123; queue&lt;pair&lt;int, int&gt;&gt; point; for (int j = 11; j &gt;= 0; --j) &#123; if (map[j][i] == '.') point.push(&#123; j, i &#125;); else &#123; if (point.empty()) continue; int x = point.front().first; int y = point.front().second; point.pop(); map[x][y] = map[j][i]; map[j][i] = '.'; point.push(&#123; j, i &#125;); &#125; &#125; &#125;&#125;void changeMap(queue&lt;pair&lt;int, int&gt;&gt; &amp;erase) &#123; while (!erase.empty()) &#123; int r = erase.front().first; int c = erase.front().second; erase.pop(); map[r][c] = '.'; &#125;&#125;void bfs(int r, int c)&#123; queue&lt;pair&lt;int, int&gt;&gt; q, erase; q.push(&#123; r, c &#125;); erase.push(&#123; r, c &#125;); check[r][c] = true; while (!q.empty()) &#123; int length = q.size(); for (int i = 0; i &lt; length; ++i) &#123; r = q.front().first; c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; !check[x][y] &amp;&amp; map[x][y] == map[r][c] &amp;&amp; map[x][y] != '.') &#123; check[x][y] = true; q.push(&#123; x, y &#125;); erase.push(&#123; x, y &#125;); &#125; &#125; &#125; &#125; if (erase.size() &gt;= 4) &#123; loop = true; changeMap(erase); &#125;&#125;int main() &#123; for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; scanf(\" %c\", &amp;map[i][j]); &#125; &#125; int answer = 0; while (loop) &#123; loop = false; memset(check, 0, sizeof(check)); for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; if (map[i][j] != '.' &amp;&amp; !check[i][j]) &#123; bfs(i, j); &#125; &#125; &#125; if (loop) &#123; update(); answer++; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; Debug 디버깅용 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;char map[12][6];bool check[12][6];int answer;bool loop = true;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;bool isBound(int r, int c) &#123; if (r &gt; -1 &amp;&amp; c &gt; -1 &amp;&amp; r &lt; 12 &amp;&amp; c &lt; 6) return true; return false;&#125;void update() &#123; for (int i = 0; i &lt; 6; ++i) &#123; queue&lt;pair&lt;int, int&gt;&gt; point; for (int j = 11; j &gt;= 0; --j) &#123; if (map[j][i] == '.') point.push(&#123; j, i &#125;); else &#123; if (point.empty()) continue; int x = point.front().first; int y = point.front().second; point.pop(); map[x][y] = map[j][i]; map[j][i] = '.'; point.push(&#123; j, i &#125;); &#125; &#125; &#125; /*printf(\"start\\n\"); for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; printf(\"%c\", map[i][j]); &#125; printf(\"\\n\"); &#125;*/&#125;void changeMap(queue&lt;pair&lt;int, int&gt;&gt; &amp;erase) &#123; //printf(\"erase\\n\"); while (!erase.empty()) &#123; int r = erase.front().first; int c = erase.front().second; //printf(\"%d %d\\n\", r, c); erase.pop(); map[r][c] = '.'; &#125;&#125;void bfs(int r, int c)&#123; queue&lt;pair&lt;int, int&gt;&gt; q, erase; q.push(&#123; r, c &#125;); erase.push(&#123; r, c &#125;); check[r][c] = true; while (!q.empty()) &#123; int length = q.size(); for (int i = 0; i &lt; length; ++i) &#123; r = q.front().first; c = q.front().second; q.pop(); for (int j = 0; j &lt; 4; ++j) &#123; int x = r + dx[j]; int y = c + dy[j]; if (isBound(x, y) &amp;&amp; !check[x][y] &amp;&amp; map[x][y] == map[r][c] &amp;&amp; map[x][y] != '.') &#123; check[x][y] = true; q.push(&#123; x, y &#125;); erase.push(&#123; x, y &#125;); &#125; &#125; &#125; &#125; if (erase.size() &gt;= 4) &#123; loop = true; changeMap(erase); &#125;&#125;int main() &#123; for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; scanf(\" %c\", &amp;map[i][j]); &#125; &#125; while (loop) &#123; loop = false; memset(check, 0, sizeof(check)); for (int i = 0; i &lt; 12; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; if (map[i][j] != '.' &amp;&amp; !check[i][j]) &#123; bfs(i, j); &#125; &#125; &#125; if (loop) &#123; update(); answer++; &#125; &#125; printf(\"%d\\n\", answer); return 0;&#125; 디버깅용 Test case 1. output : 14Y..... B..... R.R... G.R... YG.... YBR..Y RR...Y YYRBRB YRBGBB GBRBGR GBRBGR GBRBGR 2. output : 1...... ...... ...... ...... ...... ...... ...... ...... R..... ...... RRYYGG RRYYGG 3. output: 2...... ..R... ..R.GG ...GG. ..R... ...... ..R... ...... R..... ....G. RRY..G RRYYGG","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 11047번 동전 0","slug":"Algorithm/BOJ/11047","date":"2020-01-25T04:23:59.000Z","updated":"2020-01-25T08:58:11.151Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/11047/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/11047/","excerpt":"","text":"#11047. 동전 0문제링크 Problem 동전의 종류 N 동전을 적절히 사용해 합을 K로 만드려고 한다. Goal: K를 만드는데 필요한 동전 개수의 최솟값 구하기 Solution 동전의 가치는 오름차순으로 주어지고이전 가치보다 항상 몇 배 더 크다. 4200 1000 4 100 2 6개 4790 4000 4 790 500 1 290 100 2 90 50 1 40 10 * 4 12개 12 1, 3, 4, 5 5 2 2 1 2 4개 하지만 4 * 3 3개 위와 같은 상황이 일어날까?동전의 가치가 이전 가치의 배수이기에 일어날 수 없을 것이다. 1 Try123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; costs;int main()&#123; int i, n, goal, answer = 0; cin &gt;&gt; n &gt;&gt; goal; costs.resize(n); for(i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; costs[i]; &#125; while(goal != 0) &#123; if(goal &gt;= costs[i-1]) &#123; goal -= costs[i-1]; answer++; &#125; else i--; &#125; cout &lt;&lt; answer &lt;&lt; '\\n'; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 10989번 수 정렬하기 3","slug":"Algorithm/BOJ/10989","date":"2020-01-25T04:21:51.000Z","updated":"2020-01-25T08:58:11.156Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/10989/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/10989/","excerpt":"","text":"#10989. 수 정렬하기 3문제링크 Problem 시간 제한 3초 메모리 제한 8MB Goal : 주어진 수를 오름차순으로 정렬하기 Solution 메모리 제한이 8MB라는 점에 주의한다. 주어진 수는 최대 천만수의 최댓값은 최대 만 int 형 배열을 천만개 크기로 만들면10000000 * 4 = 4천만 byte = 38…MB(이미 초과 하지만 10001 크기의 배열만으로 문제를 풀 수 있다.40004 = 0.038..MB(충분히 통과) 위의 크기만 가지고 문제를 푸려면 counting sort가 적절하다. 입력으로 받은 수를 각각 세어준다. → 끝 ??? 진짜 끝이다. 남은건 해당 숫자만큼 차례대로 카운트한 횟수만큼 출력해주면 된다. 1 Try12345678910111213141516171819#include &lt;cstdio&gt;#define MAX 10000using namespace std; // 이거 안써도 된다...int cnt[MAX+1];int main()&#123; int n, input; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;input); cnt[input]++; &#125; for(int i = 1; i &lt;= MAX; ++i) &#123; for(int j = 0; j &lt; cnt[i]; j++) &#123; printf(\"%d\\n\", i); &#125; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 10814번 나이순 정렬","slug":"Algorithm/BOJ/10814","date":"2020-01-25T04:21:45.000Z","updated":"2020-01-25T08:58:11.129Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/10814/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/10814/","excerpt":"","text":"#10814. 나이순 정렬문제링크 Problem 나이와 이름이 입력으로 주어진다. 나이순으로 정렬 나이가 같다면 가입한 순서로 정렬(입력 순으로) Solution 으로 key가 중복될 수 있으니 multimap을 사용한다. map 자체가 key가 오름차순을 유지하도록 data를 넣어준다.같다면 입력순으로 된다. 1 Try12345678910111213141516171819#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;int main()&#123; int n, age; string name; multimap&lt;int, string&gt; answer; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; age &gt;&gt; name; answer.insert(make_pair(age, name)); &#125; for(auto ans : answer) &#123; cout &lt;&lt; ans.first &lt;&lt; \" \" &lt;&lt; ans.second &lt;&lt; '\\n'; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 9019번 DSLR","slug":"Algorithm/BOJ/9019","date":"2020-01-25T04:21:38.000Z","updated":"2020-01-25T08:58:11.154Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/9019/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/9019/","excerpt":"","text":"#9019. DSLRProblem 문제링크 Solution 이 문제는 명령어 ‘L’과 ‘R’을 어떻게 수행하느냐가 제일 중요하다. 처음에 deque를 사용하여 숫자를 배열로 나누고 합치고 이러다가 시간초과… 사실 사칙연산만 사용하면 위 명령어를 수행할 수 있다. L 명령어 Next = (Now % 1000 * 10) + (Now / 1000) R 명령어 Next = (Now / 10) + (Now % 10 * 1000) 주의해야 할 사항 테스트 케이스를 여러 번 수행하는 문제이므로 초기화가 필요한 변수나 배열은 초기화를 해줘야 한다. 명령어를 저장하고 있어야 하므로, 해당 숫자를 어떻게 만들었는지 경로를 저장할 배열을, 그 숫자를 만들 때 쓴 명령어가 무엇인지 저장할 배열을 만든다. from[a] = b a를 만들기 이전 숫자 b how[a] = &#39;b&#39; a를 만들 때 수행된 명령어 b 1 Try code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define MAX 10000using namespace std;char cmd[4] = &#123; 'D', 'S', 'L', 'R' &#125;;bool check[MAX];int from[MAX];char how[MAX];int A, B;void Init() &#123; memset(check, 0, sizeof(check));&#125;void PrintCmd(int a, int b) &#123; if (a != b) &#123; PrintCmd(a, from[b]); cout &lt;&lt; how[b]; &#125; &#125;void BFS() &#123; queue&lt;int&gt; q; q.push(A); check[A] = true; while (!q.empty()) &#123; int a = q.front(); q.pop(); if (a == B) &#123; PrintCmd(A, B); cout &lt;&lt; \"\\n\"; return; &#125; int d = a * 2 &gt; MAX - 1 ? a * 2 % MAX : a * 2; if (!check[d]) &#123; check[d] = true; how[d] = 'D'; from[d] = a; q.push(d); &#125; int s = a == 0 ? MAX - 1 : a - 1; if (!check[s]) &#123; check[s] = true; how[s] = 'D'; from[s] = a; q.push(s); &#125; int cur = a; deque&lt;int&gt; ld, rd; for (int i = 0, div = 1000; i &lt; 4; ++i, div /= 10) &#123; int num = cur / div; cur %= div; ld.push_back(num); rd.push_back(num); &#125; int tmp = ld.front(); ld.pop_front(); ld.push_back(tmp); tmp = rd.back(); rd.pop_back(); rd.push_front(tmp); int l = 0, r = 0; for (int i = 0, div = 1; i &lt; 4; ++i, div *= 10) &#123; l += ld.back() * div; r += rd.back() * div; ld.pop_back(); rd.pop_back(); &#125; if (!check[l]) &#123; check[l] = true; how[l] = 'L'; from[l] = a; q.push(l); &#125; if (!check[r]) &#123; check[r] = true; how[r] = 'R'; from[r] = a; q.push(r); &#125; &#125;&#125;int main() &#123; int T; cin &gt;&gt; T; for (int t = 0; t &lt; T; ++t) &#123; Init(); cin &gt;&gt; A &gt;&gt; B; BFS(); &#125; return 0;&#125; 시간초과 2 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define MAX 10000using namespace std;char cmd[4] = &#123; 'D', 'S', 'L', 'R' &#125;;bool check[MAX];int from[MAX];char how[MAX];int A, B;void Init() &#123; memset(check, 0, sizeof(check));&#125;void PrintCmd(int a, int b) &#123; if (a != b) &#123; PrintCmd(a, from[b]); cout &lt;&lt; how[b]; &#125; &#125;void BFS() &#123; queue&lt;int&gt; q; q.push(A); check[A] = true; while (!q.empty()) &#123; int a = q.front(); q.pop(); if (a == B) &#123; PrintCmd(A, B); cout &lt;&lt; \"\\n\"; return; &#125; int d = a * 2 % MAX; if (!check[d]) &#123; check[d] = true; how[d] = 'D'; from[d] = a; q.push(d); &#125; int s = a == 0 ? MAX - 1 : a - 1; if (!check[s]) &#123; check[s] = true; how[s] = 'S'; from[s] = a; q.push(s); &#125; int l = (a % 1000 * 10) + (a / 1000); if (!check[l]) &#123; check[l] = true; how[l] = 'L'; from[l] = a; q.push(l); &#125; int r = (a / 10) + (a % 10 * 1000); if (!check[r]) &#123; check[r] = true; how[r] = 'R'; from[r] = a; q.push(r); &#125; &#125;&#125;int main() &#123; int T; cin &gt;&gt; T; for (int t = 0; t &lt; T; ++t) &#123; Init(); cin &gt;&gt; A &gt;&gt; B; BFS(); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 3190번 뱀","slug":"Algorithm/BOJ/3190","date":"2020-01-25T04:21:13.000Z","updated":"2020-01-25T08:58:11.149Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/3190/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/3190/","excerpt":"","text":"#3190. 뱀문제링크 Problem N x N 보드판 양 끝 모서리에 벽이 있음 뱀의 길이 1, 시작 위치 (1, 1), 방향: → 매 초마다 이동 머리를 다음 칸에 위치 이동한 칸에 사과가 있으면 사과 먹고 꼬리 움직이지 않음(몸길이 늘어남) 꼬리 움직인다. (몸길이 그대로) Goal: 사과의 위치와 뱀의 이동경로가 주어질 때 게임이 몇 초만에 끝나는지 계산 게임은 벽이나 자기자신의 몸과 부딪히면 끝난다. 뱀의 이동 경로는 (왼쪽 오른쪽 으로 90도 방향 회전) 입력 방향 변환 정보에서 주어진 초는 게임 시작 시간으로부터 X초가 끝난 뒤를 말한다. Solution 주어진 문제대로 구현하면 된다. (시뮬레이션) 방향전환 시간은 오름차순으로 주어지기에 queue에 저장 사과가 있는 곳은 -1로 표시 뱀이 있는 곳은 1부터~현재 길이까지 표시 (머리가 가장 큰 수) 머리를 기준으로 현재 방향에 맞게 움직인다. 머리가 움직였을 때 그곳이 벽이거나 자신의 몸인지 확인한다.필자는 다음과 같은 경우에 뱀이 동시에 움직일거라 생각하여 게임이 안끝난다고 생각했다. // 4가 머리이고 머리가 위쪽으로 가는 경우일 때 1 2 -&gt; 4 1 4 3 3 2 하지만 동시에 움직이지 않고 머리부터 움직여서 꼬리가 따라온다. 그렇기에 위와 같은 경우는 게임이 종료된다. 방향 전환 시간인지 확인한다.해당 경우에 맞게 방향을 변경한다. 사과가 있는지 확인한다.사과가 있으면 길이가 1 늘어나고 이동하지 않는다. 이동한다.이동방법: 머리에서부터 시작해서 자신보다 1 적은 수를 찾는다. 찾으면 그 값을 넣는다. 이를 총 길이-1만큼 반복하고(머리를 제외하기 때문) 다음 탐색 부분에 머리를, 원래 꼬리 부분을 0으로 변경해준다. 1 2 3 4 —&gt; 1 1 2 3 —&gt; 0 1 2 3 5 4 5 4 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt; #include &lt;queue&gt;using namespace std;int n, k, l;int board[101][101];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;int d_left[4] = &#123; 2, 3, 1, 0 &#125;; // 'L'int d_right[4] = &#123; 3, 2, 0, 1 &#125;; // 'D'queue&lt;pair&lt;int, char&gt; &gt; direction;bool isWall(int x, int y) &#123; // 벽이면 true if (x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; n) return true; return false;&#125;bool isBound(int x, int y) &#123; if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &lt;= n) return true; return false;&#125;int game() &#123; int x = 1; int y = 1; // 시작위치 int dir = 3; // 시작방향: 오른쪽 int len = 1; // 뱀의 길이 int time = 0; // 게임 시작 시간 board[x][y] = 1; while (true) &#123; int convert = 0; if (!direction.empty()) &#123; convert = direction.front().first; &#125; time++; // 현재 방향에 맞는 한 칸 이동 int d_x = x + dx[dir]; int d_y = y + dy[dir]; // 벽인지 자신의 몸인지 확인 if (isWall(d_x, d_y) || board[d_x][d_y] &gt; 0) return time; // 방향 전환 시간인지 확인 if (time == convert) &#123; if (direction.front().second == 'D') &#123; dir = d_right[dir]; &#125; else &#123; dir = d_left[dir]; &#125; direction.pop(); &#125; // 사과 있는지 확인 if (board[d_x][d_y] == -1) &#123; board[d_x][d_y] = ++len; x = d_x; y = d_y; continue; &#125; // 이동 int tmp_x = x, tmp_y = y; for (int i = 1; i &lt; len; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; int d_tmp_x = tmp_x + dx[j]; int d_tmp_y = tmp_y + dy[j]; if (isBound(d_tmp_x, d_tmp_y)) &#123; if (board[d_tmp_x][d_tmp_y] == board[tmp_x][tmp_y] - 1) &#123; board[tmp_x][tmp_y] = board[d_tmp_x][d_tmp_y]; tmp_x = d_tmp_x; tmp_y = d_tmp_y; break; &#125; &#125; &#125; &#125; board[d_x][d_y] = len; board[tmp_x][tmp_y] = 0; x = d_x; y = d_y; &#125;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;k); for (int i = 0; i &lt; k; ++i) &#123; int r, c; scanf(\"%d %d\", &amp;r, &amp;c); board[r][c] = -1; &#125; scanf(\"%d\", &amp;l); for (int i = 0; i &lt; l; ++i) &#123; int x; char dir; scanf(\"%d %c\", &amp;x, &amp;dir); direction.push(&#123; x, dir &#125;); &#125; printf(\"%d\\n\", game()); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 3055번 탈출","slug":"Algorithm/BOJ/3055","date":"2020-01-25T04:18:12.000Z","updated":"2020-01-25T08:58:11.137Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/3055/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/3055/","excerpt":"","text":"#3055. 탈출Problem 문제링크 Solution 조건 중에 “물이 찰 예정인 칸에 고슴도치가 움직일 수 없다.“에 집중하였다. 물이 이동할 queue와 고슴도치가 이동할 queue를 따로 두어 탐색을 시작한다. 단, 물이 먼저 이동해야 한다.(위 조건 때문에) 모든 탐색은 BFS로 이루어지며, 물은 이동할 때마다 map을 갱신한다. 고슴도치는 갱신 안한다. 고슴도치가 ‘D’에 도착하지 못 하고 탐색할 지점이 없을 때 -1을 리턴하여 도착할 수 없다는 것을 표시한다. ‘D’에 도착하면 그때 시간을 바로 출력하도록 한다. 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;tuple&gt;#include &lt;queue&gt;using namespace std;int R, C;char map[51][51];bool visit[50][50];queue&lt;pair&lt;int, int&gt;&gt; q;queue&lt;pair&lt;int, int&gt;&gt; water;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void Input() &#123; scanf(\"%d %d\", &amp;R, &amp;C); for (int i = 0; i &lt; R; ++i) &#123; for (int j = 0; j &lt; C; ++j) &#123; scanf(\" %c\", &amp;map[i][j]); if (map[i][j] == 'S') &#123; q.push(&#123; i, j &#125;); visit[i][j] = true; &#125; else if (map[i][j] == '*') water.push(&#123; i, j &#125;); &#125; &#125;&#125;bool isBound(int x, int y) &#123; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; R &amp;&amp; y &lt; C) return true; return false;&#125;int BFS() &#123; int time = 0; while (!q.empty()) &#123; // 고슴도치가 탐색할 지점이 없을 때까지 진행 int w_len = water.size(); for (int i = 0; i &lt; w_len; ++i) &#123; // 물의 이동 int water_x, water_y; tie(water_x, water_y) = water.front(); water.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_w_x = water_x + dx[dir]; int d_w_y = water_y + dy[dir]; if (isBound(d_w_x, d_w_y)) &#123; if (map[d_w_x][d_w_y] == '.' || map[d_w_x][d_w_y] == 'S') &#123; map[d_w_x][d_w_y] = '*'; water.push(&#123; d_w_x, d_w_y &#125;); &#125; &#125; &#125; &#125; int len = q.size(); for (int i = 0; i &lt; len; ++i) &#123; // 고슴도치 이동 int x, y; tie(x, y) = q.front(); q.pop(); if (map[x][y] == 'D') return time; // 목적지 도착하면 시간 리턴 for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (isBound(d_x, d_y) &amp;&amp; !visit[d_x][d_y]) &#123; if (map[d_x][d_y] != 'X' &amp;&amp; map[d_x][d_y] != '*') &#123; visit[d_x][d_y] = true; q.push(&#123; d_x, d_y &#125;); &#125; &#125; &#125; &#125; time++; &#125; return -1;&#125;void Solve() &#123; int ans = BFS(); if (ans == -1) printf(\"KAKTUS\\n\"); else printf(\"%d\\n\", ans);&#125;int main() &#123; Input(); Solve(); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2869번 달팽이는 올라가고 싶다","slug":"Algorithm/BOJ/2869","date":"2020-01-25T04:11:45.000Z","updated":"2020-01-25T08:58:11.145Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2869/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2869/","excerpt":"","text":"#2869. 달팽이는 올라가고 싶다Problem높이 V미터인 나무막대 낮에 A미터 올라감 밤에 B미터 내려감 정상에서는 안내려감 나무 막대 모두 올라가는데 걸리는 일 수 하루에 +A -B B &lt; A ≤ V ≤ 10억 어차피 값은 10억을 넘을 수 없으니 int 사용해도 무방 Ex. input 2 1 5 output 4 설명 1일: 0+2 = 2 2일: 2-1+2 =3 3일: 3-1+2 = 4 4일: 4-1+2 = 5 하지만 제한시간이 0.15초이기에 이런 단계로 풀면 안된다.하루는 무조건 A가 되고 그 후는 -B+A가 반복이니 다음이 성립한다. V = A + (A-B)xx \\ge \\frac {V-A}{A-B}하지만 x는 정수이므로 위와 같은 부등호를 붙여주어야 한다. 3 1 6 1일: 3 2일: 3-1+3 = 5 3일: 5-1+3 = 7 공식: x ≥ 1.xx 따라서 x는 2, 총 일 수는 2+1 = 3일이된다. 근데 이 공식 적용하면 V가 되었다가 다시 줄어드는 경우가 있어서 답에 영향을 주나? → NO ceil() 때문에 피연산자는 double형으로, 결과값은 int형으로 두었다.(결과값을 double로 설정하면 출력값이 큰 경우 부동소수점 방식으로 출력되어 틀린 답이 된다.)12345678910111213#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; double a, b, v; int day = 1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; v; double ans = (v-a) / (a-b); ans = ceil(ans); day += ans; cout &lt;&lt; day &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2798번 블랙잭","slug":"Algorithm/BOJ/2798","date":"2020-01-25T04:11:38.000Z","updated":"2020-01-25T08:58:11.147Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2798/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2798/","excerpt":"","text":"#2798. 블랙잭 N장의 카드 M : 목표 N장의 카드 중 3개 선택 3개의 숫자 합이 M에 최대한 가깝도록(M을 넘어서면 안됨) N은 최대 100이기에 100장 중 3장을 선택하는 경우의 수 100 x 99 x 98 = 970,200‬가 최대이다.그러므로 충분히 모든 경우의 수를 구해 답을 찾아낼 수 있는 문제이다. 재귀나 for문을 이용하여 풀 수 있을 것이다. 필자는 재귀를 사용하였다. M은 최대 300000이기에 MAX 값으로 두었고 재귀의 내용은 다음과 같다. 매개변수 numbers : N개의 숫자를 담을 vector goal : M ans : 숫자 합 index : numbers의 인덱스 selected : 남은 카드 선택 횟수 실패 조건 숫자 합이 M보다 클 때 index가 numbers의 크기를 넘었을 때 성공 조건 3번을 뽑았을 경우, goal과 ans의 차이가 최소인 값 재귀함수 카드를 선택하지 않을 때 카드를 선택했을 때ans에 선택한 카드가 더해짐12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;#define MAX 300000;using namespace std;int min_diff = MAX;vector&lt;int&gt; numbers;void doCombination(vector&lt;int&gt; numbers, int goal, int ans, int index, int selected) &#123; if(ans &gt; goal) return; if(selected == 0) &#123; min_diff = min_diff &gt; goal-ans ? goal-ans : min_diff; return; &#125; if(index &gt;= numbers.size()) &#123; return; &#125; doCombination(numbers, goal, ans, index+1, selected); // not selected ans += numbers[index]; doCombination(numbers, goal, ans, index+1, selected-1); // selected&#125;int main() &#123; int n, m, answer = 0; cin &gt;&gt; n &gt;&gt; m; numbers.resize(n); for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; numbers[i]; &#125; doCombination(numbers, m, 0, 0, 3); answer = m - min_diff; cout &lt;&lt; answer &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2748번 피보나치 수 2","slug":"Algorithm/BOJ/2748","date":"2020-01-25T04:11:30.000Z","updated":"2020-01-25T08:58:11.143Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2748/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2748/","excerpt":"","text":"#2748. 피보나치 수 2문제링크 Problem Goal : n번째 피보나치 수를 구하여라 condition 최대 90번째 피보나치 수를 구할 수 있어야 함 시간 제한 1초 SolutionF_n = F_{n-1} + F_{n-2}수식 그대로 DP를 적용한다.12// dp[n]은 n번째 피보나치 수dp[n] = dp[n-1] + dp[n-2]; 1 Try1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;long long dp[91]; long long fibo(int n)&#123; dp[0] = 0, dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125;int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; fibo(n) &lt;&lt; endl; return 0;&#125; 주의할 점은 90번째 피보나치 수(10의 18승보다 큼)를 담으려면 long long을 써야 한다는 점이다.(long은 안된다.)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2468번 안전 영역","slug":"Algorithm/BOJ/2468","date":"2020-01-25T04:11:03.000Z","updated":"2020-01-25T08:58:11.158Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2468/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2468/","excerpt":"","text":"#2468. 안전 영역Problem 문제링크 Solution 높이 1부터 최대 높이까지 작업을 진행한다. → set에 높이 정보를 담고 오름차순으로 정렬하면 더 빠를듯 각 높이마다 모든 영역을 탐색한다. (말이 모든 영역이지 이미 높이보다 같거나 작은 영역이나 방문한 영역이면 탐색을 하지 않는다.)탐색은 BFS로 안전영역을 표시한다. 탐색이 끝나면 안전 영역의 수를 1증가한다. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;int N, max_height, ans = 1;int arr[100][100];bool visited[100][100];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void BFS(int x, int y, int h) &#123; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123; x, y &#125;); visited[x][y] = true; while (!q.empty()) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int nx = x + dx[dir]; int ny = y + dy[dir]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= N) continue; if (visited[nx][ny] || arr[nx][ny] &lt;= h) continue; visited[nx][ny] = true; q.push(&#123; nx, ny &#125;); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++)&#123; for (int j = 0; j &lt; N; j++)&#123; cin &gt;&gt; arr[i][j]; if (max_height &lt; arr[i][j]) max_height = arr[i][j]; &#125; &#125; for (int h = 1; h &lt;= max_height; ++h) &#123; int area = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; if (visited[i][j] || arr[i][j] &lt;= h) continue; BFS(i, j, h); area++; &#125; &#125; if (ans &lt; area) ans = area; memset(visited, false, sizeof(visited)); &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2251번 물통","slug":"Algorithm/BOJ/2251","date":"2020-01-25T04:10:51.000Z","updated":"2020-01-25T08:58:11.148Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2251/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2251/","excerpt":"","text":"#2251. 물통Problem 문제링크 Solution 첫 시작은 C 물통만 가득 차 있으니 전체 합은 C의 물통이다. 물을 옮기는 경우는 총 6경우로 0을 A, 1을 B, 2를 C라고 했을 때 다음과 같은 경우가 존재한다.1230 -&gt; 1, 0 -&gt; 21 -&gt; 0, 1 -&gt; 22 -&gt; 0, 2 -&gt; 1 경우의 수가 중복되지 않도록 표시해주는 배열은 2차원으로도 해결 가능하다. (전체 양은 일정하니 A, B만 알아도 C를 알 수 있기 때문이다.) 처음 A, B, C의 부피를 저장한다. 시작은 (0, 0)에서 시작하고, ans[C 물의 양]이 true임을 표시해 A가 0일 때 C의 물의양임을 나타낸다. BFS 탐색을 시작한다. 각 경우에서 계속해서 나아가는 방식이기에 적합하다. (경우의 수도 많지 않음) 물을 옮기는 건 2가지 경우가 존재한다. from x → to y x + y ≤ Yx + y의 값이 y를 가진 물통의 부피(Y)이하일 때x를 다 옮길 수 있으므로 x를 가졌던 물통의 물의 양은 0이 된다.y를 가진 물통의 물의 양은 x+y가 된다. x + y &gt; Yx + y의 값이 Y보다 클 때 x를 다 옮길 수 없으므로x를 가졌던 물통의 물의 양은 x + y - Y가된다.y를 가졌던 물통의 물의 양은 Y가 된다. check와 A의 물의 양이 0인지 판단하여 BFS 탐색을 한다. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int bucket[3]; // 물통 부피bool check[201][201]; // A, B만 알아도 C를 알 수 있음bool ans[201]; // A가 비어있을 때 C의 물의 양queue&lt;pair&lt;int, int&gt;&gt; q;int from[6] = &#123; 0, 0, 1, 1, 2, 2 &#125;; // 0: A, 1: B, 2: Cint to[6] = &#123; 1, 2, 0, 2, 0, 1 &#125;;void Output() &#123; for (int i = 0; i &lt;= 200; ++i) &#123; if (ans[i]) cout &lt;&lt; i &lt;&lt; \" \"; &#125; cout &lt;&lt; \"\\n\";&#125;void BFS() &#123; int sum = bucket[2]; q.push(&#123; 0, 0 &#125;); check[0][0]= true; ans[sum] = true; while (!q.empty()) &#123; int cur[3]; cur[0] = q.front().first; cur[1] = q.front().second; cur[2] = sum - cur[0] - cur[1]; q.pop(); for (int i = 0; i &lt; 6; ++i) &#123; int next[3] = &#123; cur[0], cur[1], cur[2] &#125;; if (next[from[i]] + next[to[i]] &lt;= bucket[to[i]]) &#123; next[to[i]] += next[from[i]]; next[from[i]] = 0; &#125; else &#123; // 옮긴 물의 양이 해당 물통 부피보다 클 때 next[from[i]] += next[to[i]] - bucket[to[i]]; next[to[i]] = bucket[to[i]]; &#125; if (!check[next[0]][next[1]]) &#123; check[next[0]][next[1]] = true; q.push(&#123; next[0], next[1] &#125;); if (next[0] == 0) ans[next[2]] = true; &#125; &#125; &#125; &#125;int main() &#123; for (int i = 0; i &lt; 3; ++i) cin &gt;&gt; bucket[i]; BFS(); Output(); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2231번 분해합","slug":"Algorithm/BOJ/2231","date":"2020-01-25T04:10:46.000Z","updated":"2020-01-25T08:58:11.160Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2231/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2231/","excerpt":"","text":"#2231. 분해합문제링크 Problem 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합 245의 분해합 : 245+2+4+5 = 256245는 256의 생성자 생성자는 없을 수도 여러 개일 수도 있음 없다면 0 출력 Goal: N이 주어졌을 때 N의 가장 작은 생성자 출력 Solution 1부터 최대 N-1까지 분해합을 구하면서 풀어보면 어떻게 될까? 1부터 분해합을 구하다가 N이 되었을 때 종료하면 가장 작은 생성자를 출력할 수 있다. 분해합 구하기1234567891011121314151617181920212223242526272829303132212의 분해합 구하기212 자릿수 3// #1.212 / 10^2 = 2 -&gt; 212+2212 - 2*10^2 = 12// #2.12 / 10^1 = 1 -&gt; 212+2+112 - 1*10^1 = 2 -&gt; 212+2+1+211의 분해합 구하기11 자릿수 2div = 10 (10의 제곱 수)sum = 11 (분해합)// #1.temp = 11 / 10 = 1 (계산 용도)num = 11 - 10 = 1sum = 11 + 1 = 12div = 1// #2.temp = 1 / 1 = 1num = 1 - 1 = 0sum = 12 + 1 = 13div = 0그냥 더 간단한 방법이 생각났다. (2 Try 참고)sum, temp = 11sum = 11 + 11 % 10temp = 11 / 10 = 1sum = 12 + 1 % 10 = 13즉, sum += temp % 10temp /= 10 1 Try12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;// 자릿 수 체크int getLength(int num) &#123; int count = 0; do &#123; count++; &#125;while(num/=10); return count;&#125;// 분해합 게산 int distributeSum(int num) &#123; int length = getLength(num); int div = pow(10, length-1); int sum = num; int temp; for(int i = 0; i &lt; length; ++i) &#123; temp = num / div; num = num - temp * div; sum += temp; div /= 10; &#125; return sum;&#125;int main()&#123; int n, i; cin &gt;&gt; n; for(i = 1; i &lt; n; ++i) &#123; if(n == distributeSum(i)) &#123; cout &lt;&lt; i &lt;&lt; '\\n'; break; &#125; &#125; if(i == n) cout &lt;&lt; 0 &lt;&lt; '\\n'; return 0;&#125; 108ms 2 Try12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int distributeSum(int num) &#123; int sum, temp; sum = temp = num; do &#123; sum += temp % 10; &#125;while(temp /= 10); return sum;&#125;int main() &#123; int n, i; cin &gt;&gt; n; for(i = 1; i &lt; n; ++i) &#123; if(n == distributeSum(i)) &#123; cout &lt;&lt; i &lt;&lt; '\\n'; break; &#125; &#125; if(i == n) cout &lt;&lt; 0 &lt;&lt; '\\n'; return 0;&#125; 8ms","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2206번 벽 부수고 이동하기","slug":"Algorithm/BOJ/2206","date":"2020-01-25T04:10:43.000Z","updated":"2020-01-25T08:58:11.132Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2206/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2206/","excerpt":"","text":"#2206. 벽 부수고 이동하기문제링크 Problem N x M 크기의 맵 0은 이동가능 1은 벽을 나타냄 (0, 0) → (N-1, M-1)까지 이동 (상하좌우) 벽을 1개까지 부수고 이동 가능 Goal: (0, 0)에서 (N-1, M-1)까지 이동하는데 걸리는 경로 중 최단 경로 구하기 Solution 이동하기 시작지점(0, 0)에서부터 상하좌우로 갈 수 있는 방향을 탐색한다.도착지점까지 모든 곳을 탐색해야 하며, 이때 BFS를 사용한다.현재 지점에서 상하좌우로 가는데 걸리는 비용이 동일하기 때문이다. 벽을 부수었는지 여부를 경로를 갱신할 때마다 가지고 있어야 한다. 탐색할 때 이미 값이 있다면 이미 지나온 경로이므로 다른 지점을 탐색해야 한다. 그외는 다음을 확인하고 경로를 갱신한다. 탐색할 지점이 0이라면 경로 갱신 탐색할 지점이 1인데 이전까지 벽을 부수지 않았다면 경로 갱신 위와 같은 작업으로 문제를 해결할 수 있다. 1 Try1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;queue&gt;#define MAX 1001using namespace std;int n, m;int map[MAX][MAX];int path[MAX][MAX][2]; // 벽을 안부순 경로, 벽을 부순 경로int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;struct INFO &#123; int r, c; bool break_wall = false;&#125;;int bfs() &#123; queue&lt;INFO&gt; q; q.push(&#123; 0, 0, false &#125;); path[0][0][0] = 1; while (!q.empty()) &#123; int r = q.front().r; int c = q.front().c; bool bw = q.front().break_wall; q.pop(); if (r == n - 1 &amp;&amp; c == m - 1) return path[r][c][bw]; for (int i = 0; i &lt; 4; ++i) &#123; int x = r + dx[i]; int y = c + dy[i]; if (x &gt; -1 &amp;&amp; y &gt; -1 &amp;&amp; x &lt; n &amp;&amp; y &lt; m) &#123; if (path[x][y][bw]) continue; if (map[x][y] == 0) &#123; path[x][y][bw] = path[r][c][bw] + 1; q.push(&#123; x, y, bw &#125;); &#125; else if(map[x][y] == 1 &amp;&amp; bw == 0) &#123; path[x][y][1] = path[r][c][bw] + 1; q.push(&#123; x, y, true &#125;); &#125; &#125; &#125; &#125; return -1;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; scanf(\"%1d\", &amp;map[i][j]); &#125; &#125; printf(\"%d\\n\", bfs()); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 2146번 다리 만들기","slug":"Algorithm/BOJ/2146","date":"2020-01-25T04:10:23.000Z","updated":"2020-01-25T08:58:11.152Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/2146/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/2146/","excerpt":"","text":"2146. 다리 만들기Problem 문제링크 Solution 각 섬의 id를 매긴다. → DFS 이용 가장 짧은 다리의 길이를 구한다. → BFS 이용 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int map[100][100];bool visited[100][100];int N, ans =1e9;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;void DFS(int x, int y, int idx) &#123; visited[x][y] = true; map[x][y] = idx; for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; N &amp;&amp; d_y &lt; N) &#123; if (map[d_x][d_y] == 0 || visited[d_x][d_y]) continue; DFS(d_x, d_y, idx); &#125; &#125;&#125;int BFS(int x, int y) &#123; memset(visited, false, sizeof(visited)); queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123; x, y &#125;); int temp = map[x][y]; int res = 0; while (int len = q.size()) &#123; while(len--) &#123; int x = q.front().first; int y = q.front().second; q.pop(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; N &amp;&amp; d_y &lt; N) &#123; if (map[d_x][d_y] != 0 &amp;&amp; map[d_x][d_y] != temp) return res; if (map[d_x][d_y] == 0 &amp;&amp; !visited[d_x][d_y]) &#123; visited[d_x][d_y] = true; q.push(&#123; d_x, d_y &#125;); &#125; &#125; &#125; &#125; res++; &#125; return ans;&#125;int main() &#123; cin &gt;&gt; N; int idx = 1; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; // 각 섬에 번호 매기기 for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (visited[i][j] || map[i][j] == 0) continue; DFS(i, j, idx++); &#125; &#125; // 가장 짧은 다리 길이 구하기 for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; if (map[i][j] == 0) continue; ans = min(ans, BFS(i, j)); &#125; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 1938번 통나무 옮기기","slug":"Algorithm/BOJ/1938","date":"2020-01-25T04:09:53.000Z","updated":"2020-01-25T06:28:02.580Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/1938/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/1938/","excerpt":"","text":"#1938. 통나무 옮기기Problem 문제링크 Solution 통나무 중점 좌표를 토대로 BFS 탐색을 하였다.중심을 기준으로 그대로(회전), 상, 하, 좌, 우로 이동하면 각각 작동횟수 + 1이기에BFS로 탐색하는게 최적이다.중복 탐색을 막기 위해 3차원 방문 배열을 두어 중점 좌표의 각 모양(타입)에 따라 표시를 하였다. 중점 좌표로 이동하다보니 이동 후 다음을 꼭 확인해야 한다. 평지 범위를 벗어나지 않는지세 좌표 모두 범위를 벗어나지 않도록 확인해야한다. 방문한 지점인지 움직일 수 있는지상하좌우 → 움직인 세 좌표에 ‘1’이 없는지 확인회전 → 움직인 중점좌표 기준으로 3x3dp ‘1’이 없는지 확인 도착 지점에 도착하면 종료 1 Try123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define endl \"\\n\"#define MAX 50using namespace std;int N, ans = 1e9;char land[MAX + 1][MAX + 1];bool visited[MAX + 1][MAX + 1][2];vector&lt;pair&lt;int, int&gt;&gt; start_point;vector&lt;pair&lt;int, int&gt;&gt; end_point;int dr[5] = &#123; 0, -1, 1, 0, 0 &#125;;int dc[5] = &#123; 0, 0, 0, -1, 1 &#125;;struct Log &#123; int type; // 0 : 가로, 1 : 세로 int r, c; // 중점 좌표&#125;;bool isIn(int r, int c, int type) &#123; // 통나무가 평지 범위인지 if (type == 0) c--; else r--; for (int i = 0; i &lt; 3; ++i) &#123; if (r &lt; 0 || c &lt; 0 || r &gt; N - 1 || c &gt; N - 1) return false; if (type == 0) c++; else r++; &#125; return true;&#125;bool isEnd(int r, int c, int type) &#123; // EEE에 도착했는지 if (type == 0) c--; else r--; for (int i = 0; i &lt; end_point.size(); i++) &#123; if (end_point[i].first != r || end_point[i].second != c) return false; if (type == 0) c++; else r++; &#125; return true;&#125;bool Check(int r, int c, int type) &#123; // 이동이 가능한지 if (type == 0) c--; else r--; for (int i = 0; i &lt; 3; ++i) &#123; if (land[r][c] == '1') return false; if (type == 0) c++; else r++; &#125; return true;&#125;bool CheckRotate(int r, int c, int type) &#123; // 회전이 가능한지 int sr = r - 1, sc = c - 1; for (int i = sr; i &lt; sr + 3; ++i) &#123; for (int j = sc; j &lt; sc+ 3; ++j) &#123; if (land[i][j] == '1') return false; &#125; &#125; return true;&#125;void BFS() &#123; queue&lt;Log&gt; q; int type, r, c; if (start_point[0].first == start_point[1].first) &#123; type = 0; r = start_point[0].first; c = start_point[1].second; &#125; else &#123; type = 1; c = start_point[0].second; r = start_point[1].first; &#125; q.push(&#123; type, r, c &#125;); visited[r][c][type] = true; int cnt = 0; while (int s = q.size()) &#123; while (s--) &#123; int r = q.front().r, c = q.front().c; int type = q.front().type; if (isEnd(r, c, type)) &#123; ans = cnt; return; &#125; q.pop(); for (int dir = 0; dir &lt; 5; ++dir) &#123; if (dir == 0 || dir == 1) type = (type+1) % 2; // 회전 후 타입 원래대로 int nr = r + dr[dir]; int nc = c + dc[dir]; if (!isIn(nr, nc, type)) continue; if (visited[nr][nc][type]) continue; if (dir == 0) if (!CheckRotate(nr, nc, type)) continue; // 3 x 3 확인 후 회전 if (Check(nr, nc, type)) &#123; visited[nr][nc][type] = true; q.push(&#123; type, nr, nc &#125;); &#125; &#125; &#125; cnt++; &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; cin &gt;&gt; land[i][j]; if (land[i][j] == 'B') start_point.push_back(&#123; i, j &#125;); else if (land[i][j] == 'E') end_point.push_back(&#123; i, j &#125;); &#125; &#125; BFS(); if (ans == 1e9) ans = 0; cout &lt;&lt; ans &lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 1932번 정수 삼각형","slug":"Algorithm/BOJ/1932","date":"2020-01-25T04:09:30.000Z","updated":"2020-01-25T06:54:13.895Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/1932/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/1932/","excerpt":"","text":"#1932. 정수 삼각형문제링크 Problem 맨 위층부터 시작 → 맨 아래 층선택된 수들을 합하면서 내려옴 현재 층에서 선택된 수의 대각선(왼 or 오)만 가능 condition 층은 최대 500 수의 범위 0~9999 Goal : 합이 최대가 되는 수 Solution 입력을 보면 알겠지만 자기 자신 바로 아래와 오른쪽만 가능123456&#x2F;&#x2F; input73 88 1 02 7 4 44 5 2 6 5 그냥 재귀함수를 쓰면 반복되는 호출이 많이 일어난다.DP를 사용해야 함을 알 수 있다.12345678910&#x2F;&#x2F; #07&#x2F;&#x2F; #17+3 &#x2F; 7+8&#x2F;&#x2F; #27+3+8, 7+3+1 &#x2F; 7+8+1, 7+8+0&#x2F;&#x2F; #37+3+8+2, 7+3+8+7 &#x2F; 7+3+1+7, 7+3+1+4 &#x2F; 7+8+1+7, 7+8+1+4 &#x2F; 7+8+0+4, 7+8+0 +4&#x2F;&#x2F; #420+4, 20+5 &#x2F; 25+5, 25+2 &#x2F; 18+5, 18+2 &#x2F; 14+2, 14+6 &#x2F; 23+5, 23+2 &#x2F; ... 경우의 수는 1→2→4→8→16으로 늘어난다. 500일 때 최대 500^2 = 250000(25만)의 경우의 수가 나온다. 물론 재귀함수를 사용하면 이보다 더 많은 함수 호출이 일어나 시간초과가 발생할 것이다. 6개월 전에 풀었던 것을 다시 풀어보려니…생각이 안난다. dp[a][b] 1 Try (6개월 전 코드)1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int t[500][500];int d[500][500];int main()&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; cin &gt;&gt; t[i][j]; &#125; &#125; d[0][0] = t[0][0]; for (int k = 1; k &lt; n; k++) &#123; for (int h = 0; h &lt; n; h++) &#123; if (h == 0) &#123; d[k][0] = d[k - 1][0] + t[k][0]; //바로 위의 최대경로만 가져올 수 있음. &#125; else if (k == h) &#123; d[k][h] = d[k - 1][h - 1] + t[k][h]; // 바로 위 왼쪽의 최대경로만 가져올 수 있음. &#125; else &#123; d[k][h] = max(d[k - 1][h - 1], d[k - 1][h]) + t[k][h]; &#125; &#125; &#125; int max_cost = 0; // 0보다 작을 수 없음. for (int index = 0; index &lt; n; index++) &#123; max_cost = max(d[n - 1][index], max_cost); &#125; cout &lt;&lt; max_cost &lt;&lt; endl; return 0;&#125; 12345678910111213141516171819202122232425262728#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int max_sum = 0;vector&lt;vector&lt;int&gt;&gt; dp;int main() &#123; int n, input; scanf(\" %d\", &amp;n); dp.resize(n); vector&lt;vector&lt;int&gt;&gt; tri(n); for(int i = 0; i &lt; n; ++i) &#123; for(int j = i; j &gt;= 0; --j) &#123; scanf(\" %d\", &amp;input); tri[i].push_back(input); &#125; &#125; dp[0][0] = tri[0][0]; for(int i = 1; i &lt; n; ++i) &#123; for(int j = 0; j &lt;= i; ++j) &#123; dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]); &#125; &#125; cout &lt;&lt; max_sum &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 1525번 퍼즐","slug":"Algorithm/BOJ/1525","date":"2020-01-25T04:04:59.000Z","updated":"2020-01-25T04:49:31.051Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/1525/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/1525/","excerpt":"","text":"1525. 퍼즐Problem 문제링크 Solution 상당히 어려운 문제다. (접근법을 알아둘 필요가 있다.) 접근법 2차원 배열을 1차원 배열로 생각하기 퍼즐에 적혀있는 숫자를 하나로 쭉 이어진 수로 생각한다. 이어진 수 하나가 경우의 수라고 생각한다. (문제 목표는 123456789인 수(경우)를 찾는 것) map&lt;해당 경우(수), 이동 횟수&gt;를 사용하여 해당 경우에 도달하기까지 걸리는 이동 횟수를 저장한다. 9(0)이 있는 위치에서 시작하여 BFS 탐색을 하고 탐색 시에 swap을 해야 한다. (이동을 할 때 인덱스 계산에 주의한다.) swap을 위해 string을 사용한다.123456789101112ex) 현재 193425786 (0대신 9를 해야 각 자릿 수가 모두 채워진다. 0123...으로 하면 0이 사라짐)193425786 -&gt; 913425786 (왼쪽 이동)-&gt; 123495786 (아래쪽 이동)-&gt; 149425786 (오른쪽 이동)3 x 3 0 1 23 4 56 7 8행 &#x3D; 9번 위치(0~8 중) &#x2F; 3열 &#x3D; 9번 위치 % 3 주의 아래 코드에서 dist.count(next_num) == 0 대신 dist[next_num] == 0 을 하면 틀리다.dist[해당 수]에는 이동 횟수가 들어있고 dist.count(해당 수)는 해당 경우의 수가 몇 번 나왔는지 알려주기 때문이다. map에서 해당 키, 값을 넣어주지 않았는데 바로 해당 키에 대한 값을 참조하려고(dist[next_num] == 0) 하면 제대로 연산이 수행되지 않을 것이다. 1 Try12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1, 1 &#125;;queue&lt;int&gt; q;map&lt;int, int&gt; dist;void BFS(int start) &#123; q.push(start); dist[start] = 0; while (!q.empty()) &#123; int now_num = q.front(); q.pop(); string now = to_string(now_num); int zero = now.find('9'); // 0의 위치 int x = zero / 3; // 행 int y = zero % 3; // 열 for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; 3 &amp;&amp; d_y &lt; 3) &#123; string next = now; swap(next[x * 3 + y], next[d_x * 3 + d_y]); // 문자열 인덱스(2차원-&gt;1차원) int next_num = stoi(next); if (dist.count(next_num) == 0) &#123; q.push(next_num); dist[next_num] = dist[now_num] + 1; &#125; &#125; &#125; &#125;&#125;int main() &#123; string s = \"\"; for (int i = 0; i &lt; 3; ++i) &#123; for (int j = 0; j &lt; 3; ++j) &#123; int num; cin &gt;&gt; num; if (num == 0) num = 9; s += to_string(num); &#125; &#125; int start = stoi(s); BFS(start); if (dist.count(123456789) == 0) cout &lt;&lt; -1 &lt;&lt; \"\\n\"; else cout &lt;&lt; dist[123456789] &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"백준 1261번 알고스팟","slug":"Algorithm/BOJ/1261","date":"2020-01-25T04:04:31.000Z","updated":"2020-01-25T08:57:02.058Z","comments":true,"path":"2020/01/25/Algorithm/BOJ/1261/","link":"","permalink":"https://doyuni.github.io/2020/01/25/Algorithm/BOJ/1261/","excerpt":"","text":"1261. 알고스팟Problem 문제링크 Solution 벽을 최소한으로 부수면서 목적지에 도착해야 한다. 벽을 부수지 않고 갈 경우 비용은 0 벽을 부수고 갈 경우 비용은 1 따라서 deque를 사용하여 BFS 탐색을 한다. 벽을 부수지 않는 경우 front에 넣는다. 벽을 부수는 경우 back에 넣는다. front 부분을 탐색하고 pop한다.그래야 벽을 최소한으로 부수면서 visit(방문) 표시가 가능하다. 1 Try 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;tuple&gt;#include &lt;deque&gt;using namespace std;int N, M;int map[100][100];bool visit[100][100];int cnt[100][100];int dx[4] = &#123; -1, 1, 0, 0 &#125;;int dy[4] = &#123; 0, 0, -1 ,1 &#125;;void Input() &#123; scanf(\"%d %d\", &amp;N, &amp;M); for (int i = 0; i &lt; M; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; scanf(\"%1d\", &amp;map[i][j]); &#125; &#125;&#125;void BFS() &#123; deque &lt;pair&lt;int, int&gt;&gt; q; q.push_front(&#123; 0, 0 &#125;); visit[0][0] = true; while (!q.empty()) &#123; int x, y; tie(x, y) = q.front(); q.pop_front(); for (int dir = 0; dir &lt; 4; ++dir) &#123; int d_x = x + dx[dir]; int d_y = y + dy[dir]; if (d_x == N - 1 &amp;&amp; d_y == M - 1) &#123; cnt[d_x][d_y] = cnt[x][y]; return; &#125; if (d_x &gt; -1 &amp;&amp; d_y &gt; -1 &amp;&amp; d_x &lt; M &amp;&amp; d_y &lt; N) &#123; if (visit[d_x][d_y]) continue; if (map[d_x][d_y] == 1) &#123; cnt[d_x][d_y] = cnt[x][y] + 1; q.push_back(&#123; d_x, d_y &#125;); &#125; else &#123; cnt[d_x][d_y] = cnt[x][y]; q.push_front(&#123; d_x, d_y &#125;); &#125; visit[d_x][d_y] = true; &#125; &#125; &#125;&#125;int main() &#123; Input(); BFS(); printf(\"%d\\n\", cnt[M - 1][N - 1]); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://doyuni.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://doyuni.github.io/tags/Algorithm/"}]},{"title":"Jenkins, NAVER Cloud Platform, Docker로 CI/CD 무중단 배포 환경 구축하기 - 2편","slug":"cicd-2","date":"2020-01-21T13:06:11.000Z","updated":"2020-01-25T04:56:07.289Z","comments":true,"path":"2020/01/21/cicd-2/","link":"","permalink":"https://doyuni.github.io/2020/01/21/cicd-2/","excerpt":"","text":"2편에서는 CD에서 무중단 배포까지 구축한다. (1편에서는 Github Push 후에 Jenkins가 자동으로 빌드되도록 설정하였다.) 2. Jenkins로 Node.js기반 프로젝트 배포 설정하기배포를 위해 scp를 사용하여 Jenkins에 있는 프로젝트 코드를 NAVER Cloud 서버에 복사해야 한다.Node.js 기반의 프로젝트는 Tomcat과 같은 WAS(웹 서버+웹 컨테이너)가 존재하지 않아 ssh로 접속, scp로 파일을 주고 받는 작업으로 비교적 간단히 배포할 수 있다. 2-1. NAVER Cloud 서버에도 ssh 키를 생성한다.1ssh-keygen -t rsa 키가 생성되면 authorized_keys, id_rsa, id_rsa.pub, known_hosts 가 생성되어 있는 것을 볼 수 있다. scp로 파일을 주고 받는다 하였는데 이때 복사 받을 서버의 접속 비밀번호를 알아야 한다. 그렇게되면 복사할 때마다 매번 비밀번호를 요구하여 자동화 배포는 불가능하게 된다. 이를 해결하기 위해 위의 4개의 키를 이용한다.Jenkins에서는 NAVER Cloud 서버를 호스트로, NAVER Cloud 서버에서는 Jenkins 서버의 공개 키를 허가받은 키로 등록한다. 이러면 비밀번호를 요구하지 않고 자동화 배포가 가능하다. 2-2. Jenkins 서버에서 NAVER Cloud 서버를 known_hosts로 등록한다.1ssh-keyscan -H (NAVER CLOUD 서버)ip &gt;&gt; ~/.ssh/known_hosts 2-3. Jenkins에서 생성한 키 중에 공개 키(id_rsa.pub)를 NAVER Cloud 서버에서 생성한 authorized_keys에 입력한다. Jenkins 서버의 공개 키 NAVER Cloud 서버의 authorized_keys 1vi ~/.ssh/authorized_keys scp로 테스트하기접속 비밀번호를 요구하지 않았다면 성공이다. Jenkins 서버에서 test.txt 파일을 생성한다. Jenkins 서버에서 scp를 사용해 test.txt를 NAVER Cloud 서버의 /root/test 폴더에 복사한다.비밀번호를 요구하지 않으면 성공. NAVER Cloud 서버에서 복사된 파일을 확인한다. 3. NAVER Cloud 서버에 Docker, NGINX 설정하기이제 프로젝트가 배포되는 NAVER Cloud 서버에서 설정해야 할 부분이다.(*Docker 및 NGINX 설치는 생략한다.) 3-1. Dockerfile 작성.ssh로 서버에 접속하고 Dockerfile을 다음과 같이 작성한다. 123456789101112131415FROM 이미지 환경 MAINTAINER 개발자 VOLUME 호스트와 공유할 폴더 RUN mkdir -p /app WORKDIR /app COPY ./프로젝트 소스코드 폴더/ /app RUN npm install CMD npm start FROM: Node 이미지(Node version 명시) MAINTAINER: 개발자(팀명) VOLUME: host와 컨테이너가 공유할 폴더 경로 RUN: 해당 명령어 실행( 위에선 app 폴더 생성 ) WORKDIR: 작업 디렉토리 설정(위에서 만든 app 폴더로 설정) COPY: NAVER Cloud 서버에 있는 파일을 컨테이너 폴더에 복사서버에 있는 파일은 Dockerfile이 존재하는 현재 경로 내에 존재하는 것만 가능하다.(즉, 절대 경로는 Dockerfile이 있는 경로 이내가 아니라면 불가능) 그 다음은 패키지 파일들을 설치하고 서버를 실행한다. docker image build -t 도커이미지이름 .를 입력하여 이미지를 빌드한다. 3-2. Docker-compose 작성하기docker-compose(컨테이너 관리)를 설치하여 편하게 컨테이너를 설정한다.여기서 blue-green 배포 방식이 사용되는데, 이는 무중단 배포 구축을 위함이다. Dockerfile이 있는 곳에 docker-compose.blue.yml을 다음과 같이 작성한다. 123456789version: '2'services: linking-server: image: 빌드한 도커 이미지 volumes: - ./deploy:/deploy/linking ports: - \"NAVER Cloud 서버 포트:컨테이너 포트\" image: 아까 빌드한 이미지 이름을 작성한다. volumes: host 폴더와 컨테이너 폴더를 설정하여 공유한다.(심볼릭 링크와 비슷한 개념이라고 한다.) ports: host 포트와 컨테이너 포트 순으로 작성하여 포트 포워딩 설정을 한다. 같은 곳에 docker-compose.green.yml을 다음과 같이 작성한다.host 포트만 다르다. 3-3. deploy script 작성하기. 같은 곳에 deploy.sh를 다음과 같이 작성한다. 123456789101112131415161718192021#!/bin/bash DOCKER_APP_NAME=linking-server EXIST_BLUE=$(docker-compose -p $&#123;DOCKER_APP_NAME&#125;-blue -f docker-compose.blue.yml ps | grep Up) if [ -z \"$EXIST_BLUE\" ]; then echo \"blue up\" docker-compose -p $&#123;DOCKER_APP_NAME&#125;-blue -f docker-compose.blue.yml up -d sleep 10 docker-compose -p $&#123;DOCKER_APP_NAME&#125;-green -f docker-compose.green.yml downelse echo \"green up\" docker-compose -p $&#123;DOCKER_APP_NAME&#125;-green -f docker-compose.green.yml up -d sleep 10 docker-compose -p $&#123;DOCKER_APP_NAME&#125;-blue -f docker-compose.blue.yml downfi 지금까지 잘 따라 했다면 아래와 비슷한 디렉토리 구조를 볼 수 있을 것이다. 컨테이너 생성하기 docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml up -d를 입력하여 blue 컨테이너를 먼저 생성해준다. docker ps -a로 컨테이너가 잘 실행되고 있는지 확인할 수 있다. 3-4. NGINX 설정하기.다음은 NGINX로 blue, green의 로드밸런싱을 설정해 주어야 한다. vi /etc/nginx/sites-available/linking-server를 입력하여 다음과 같이 작성한다.linking-server는 필자가 정한 이름이다. 12345678910111213# Load Balancingupstream linking-server &#123; least_conn; server 127.0.0.1:1025 weight=5 max_fails=3 fail_timeout=10s; server 127.0.0.1:1026 weight=10 max_fails=3 fail_timeout=10s;&#125;server &#123; listen 1024; server_name NAVER Cloud 서버 아이피; location / &#123; proxy_pass http://linking-server; &#125;&#125; 그런 다음 아래 명령어로 이 파일을 /etc/nginx/sites-enabled 디렉터리에 링크해준다. sudo ln -fs /etc/nginx/sites-available/linking-server /etc/nginx/sites-enabled/ 마지막으로 sudo nginx -t 명령어로 문법 이상 유무를 확인하고 이상이 없을 경우, systemctl stop nginx 명령어로 NGINX를 종료한 후에 systemctl start nginx 로 다시 시작한다. 3-5. NAVER Cloud Platform ACG 설정하기.여기서 마지막으로 한 가지 해야할 것은 ACG 설정이다. ACG 설정하기 NAVER Cloud Platform 콘솔에서 1024포트를 열어준다. 위에서 blue, green 모두 다른 포트지만 NGINX를 통해 1024 포트로 로드 밸런싱 되기에 사용자는 이를 통해 접근할 수 있다.(보통 백엔드와 프론트엔드를 분리하면서 프로젝트를 진행하고 있다면 프론트엔드는 80포트를 사용하는게 좋다. 80이 기본 포트라 생략 가능하므로) 이것으로 NAVER Cloud 서버에서의 설정은 끝났다. 4. 마지막 작업이제 마지막 Jenkins에서 빌드할 때 설정을 해주어야 위에서 설정한 무중단 배포가 자동화된다. Jenkins 프로젝트 관리에서 “Execute managed script”를 클릭한다.다만, 아직 작성한 스크립트가 없기에 Jenkins 관리 &gt; Managed files &gt; Add a new Config를 통해 스크립트를 작성한다. 다음과 같이 작성한다. 123456789101112131415#!/bin/shssh -T root@서버 아이피 &lt;&lt;EOF rm -rf /home/docker-image/deploy/* exitEOF scp -r /var/lib/jenkins/jobs/LinkingCI/workspace/* root@서버 아이피:/home/docker-image/deploy/ #!/bin/shssh -T root@서버 아이피 &lt;&lt;EOF cd /home/docker-image docker image build -t linking-server-docker-image . ./deploy.sh exitEOF 1) Jenkins가 빌드 동안 해당 서버에 접속하여 원래 있던 애플리케이션 코드를 삭제한다. 2) 빌드된 파일을 해당 서버에 복사한다. 3) 해당 서버에 다시 접속하여 새로 복사된 파일을 토대로 도커 이미지를 빌드한다. 4) 배포 스크립트를 실행한다. 위와 같은 과정이 일어나고 지금까지 설정한 것들이 모두 자동화되어 무중단 배포까지 진행된다. 이를 이제 Jenkins 프로젝트 관리에서 실행하도록 한다. 5. 빌드 상태 표시, Slack 알림추가로 프로젝트에서 보이는 Embeddable Build Status를 클릭하면 마크다운 형식으로 Github 레포지토리에 빌드 상태바를 보이게 할 수 있다. 마지막으로 팀원들이 빌드 상태(시작, 실패, 성공)을 알고 싶을 때 Slack을 통해 알림을 받도록 할 수도 있다.1편에서 이미 관련 플러그인을 설치하였기에 바로 설정이 가능하다. Slack에 채널을 만들었다면 Apps에서 Jenkins를 검색 후 클릭한다. 알림을 받을 채널을 설정하면 Jenkins에서 어떻게 설정해야 하는지 친절하게 나온다. 설정을 하고 나면 Jenkins 프로젝트에서 빌드 후 조치에 알림 받을 내역을 설정할 수가 있게 된다. 빌드 시작부터 끝까지 알림이 날라온다. 이것으로 CI/CD 무중단 배포 환경 구축을 마친다. -끝-","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://doyuni.github.io/categories/DevOps/"},{"name":"CI/CD","slug":"DevOps/CI-CD","permalink":"https://doyuni.github.io/categories/DevOps/CI-CD/"}],"tags":[{"name":"NAVER CLOUD","slug":"NAVER-CLOUD","permalink":"https://doyuni.github.io/tags/NAVER-CLOUD/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://doyuni.github.io/tags/Jenkins/"},{"name":"Docker","slug":"Docker","permalink":"https://doyuni.github.io/tags/Docker/"},{"name":"NGINX","slug":"NGINX","permalink":"https://doyuni.github.io/tags/NGINX/"}]},{"title":"Jenkins, NAVER Cloud Platform, Docker로 CI/CD 무중단 배포 환경 구축하기 - 1편","slug":"cicd-1","date":"2020-01-21T13:01:34.000Z","updated":"2020-01-25T04:56:07.287Z","comments":true,"path":"2020/01/21/cicd-1/","link":"","permalink":"https://doyuni.github.io/2020/01/21/cicd-1/","excerpt":"","text":"이번 내용은 필자가 프로젝트를 진행하면서 처음으로 DevOps를 맡으면서 꼭 공유 하겠다고 마음 먹고 작성하였다. CI/CD란? CI(Continuous Integration)지속적인 통합을 의미한다. 이는 개발자를 위한 자동화 프로세스 중 하나이며 어플리케이션을 변경할 때 자동으로 빌드 및 테스트되어 Github 공유 레포지토리에 병합된다. 그렇기에 협업 시 발생할 수 있는 충돌문제를 해결할 수 있다. CD(Continuous Deployment)지속적인 배포를 의미한다. 어플리케이션 변경 사항이 반영된 공유 레포지토리에서 사용자가 사용 가능한 환경까지 자동으로 배포하는 것을 말한다. 이를 통해 어플리케이션을 원활히 그리고 더 빠르게 제공하므로써 사용자의 피드백을 빠르게 반영할 수 있다. 아래는 필자가 맡은 프로젝트의 전체 시스템 구조이면서 동시에, CI/CD 과정을 볼 수 있다. 전체 시스템 구조 대부분 Travis CI, AWS, Docker, NGINX를 사용하여 CI/CD 무중단 배포를 구축한다는 점에서 비교하여 보아도 좋을 것이다. 선택의 순간들AWS가 아닌 NAVER CLOUD 선택AWS와 NAVER Cloud Platform을 사용해 보면서 느낀 것은 확실히 AWS의 기능이 훨씬 많고 유용하다.그럼에도 NAVER Cloud Platform을 사용한 것은 40만 크레딧(지원 받았다.)이 제일 컸다.AWS에는 무중단 배포까지 지원하는 서비스인 Blue-Green Deployment가 있는데 반해 NAVER Cloud는 없다…그럼 굳이 왜 AWS를 선택하지 않았냐고 할 수 있는데 내가 직접 설정해서 구축하고 싶었기 때문이다. (사서 고생한다는 얘기) Travis가 아닌 Jenkins 선택Travis reference만 보아도 AWS랑 얼마나 죽이 잘 맞는지를 알 수 있다. (AWS말고도 Google Cloud, Azure도 지원한다.) 이미 NAVER Cloud를 선택한 이상 Travis는 더 어려운 방법으로 가는 길이라 생각했다. 오히려 설정할 수 있는 범위가 넓은 Jenkins를 택하는 것이 쉽다고 판단하였다. 처음에 AWS와 Travis로 자동화 배포 환경 구축을 연습했었는데, 개인적인 입장으로는 Jenkins가 좀 더 쉬운 것 같다. 40만 크레딧의 위엄으로 Jenkins를 도커가 아닌 Naver Cloud로 서버를 따로 구축했다. 지금 생각해보면 자원 낭비인 셈이지만 안정성 측면에서는 따로 서버를 두는 것이 좋다. 환경 구축하기NAVER Cloud 사용 설명서는 무척 잘 되어 있고 AWS의 EC2나 S3와 같은 개념과 똑같기에 같은 방식으로 설정하면 된다. NAVER Cloud의 Server = AWS의 EC2 NAVER Cloud의 Object Storage = AWS의 S3 아래와 같이 SourcePipeline 서비스를 이용하면 Github에서 push한 것을 자동으로 빌드하고 배포할 수 있는데, 아래 사진 우측 상단에 보이는 파이프라인 실행하기를 매번 클릭해줘야 한다…내가 원한건 push만 해도 자동화 빌드 및 배포이다. 결국 이걸 접고 Jenkins와 NAVER Cloud의 Server만 사용하기로 결정했다. 1. Jenkins 설정하기Docker로 Jenkins 서버를 운영해도 되지만 NAVER Cloud에서 다음과 같이 지원하기에 사용하였다.다만 수동으로 최신 업데이트 하는 것을 권장한다. 1-1. Jenkins 보안 설정Jenkins는 기본적으로 보안 설정이 되어있지 않다.Jenkins 관리 &gt; Configure Global Security에서 설정할 수 있다. 처음에 사용자의 가입을 허용하여 admin 계정을 생성한다. 팀원과 함께 작업한다면 팀원 각각 계정 생성하도록 둔다. 계정 생성을 끝냈으면 ‘Matrix-based security’를 적절히 설정한다. (없다면 Matrix Authorization Strategy Plugin를 설치하자.)필자는 익명에게 읽기 권한 중 Job(Jenkins 작업 단위) 부분만 볼 수 있게 하였다. 이는 나중에 설정할 Github의 build status를 보여주기 위함이다.그리고 혼자 환경 구축을 담당 하였기에 팀원 계정 역시 익명과 같은 권한을 주었다. 1-2. 플러그인 설치하기Jenkins 관리 &gt; 플러그인 관리 Github plugin: Jenkins와 Github 통합 Global Slack Notifier Plugin: Slack 연동(Job 알림 설정) Publish Over SSH: ssh로 빌드 파일 보내기 Embeddable Build Status Plugin: Github 레포지토리에 빌드 상태바 생성 Managed Scripts: Node.js 기반의 서버를 배포하기 위한 스크립트 1-3. Jenkins Global 설정하기Jenkins 관리 &gt; 시스템 설정 &gt; GitHub Servers에서 다음과 같이 설정한다. Credentials 설정을 위해 자신의 Github &gt; Settings &gt; Developer settings &gt; Personal access tokens에서 다음과 같이 토큰을 생성한다. 생성 후 화면에 보이는 secret 문자열을 아래의 Secret에 입력한다. 1-4. 프로젝트 생성 및 설정하기새로운 Item을 클릭하고 프로젝트 이름을 입력, Freestyle을 누른다. 다음과 같이 프로젝트 url을 입력하고 Credentials를 설정한다. 이 작업은 Github을 연동하는 것인데, ID와 PW로 연동하면 보안에 취약하기에 ssh키로 연동하였다. ssh 키 생성하기 ssh로 Jenkins 서버에 원격 접속하여 다음을 입력한다.1ssh-keygen -t rsa -f id_rsa id_rsa, id_rsa.pub 를 포함해 총 4개의 키가 생성된다. 아래 Add 표시를 눌러 cat ~/.ssh/id_rsa 입력 후 나오는 private key를 넣어준다 BEGIN ~부터 모두 복사하여 입력한다. Github에 공개 키 등록하기. cat ~/.ssh/id_rsa.pub 를 입력하면 나오는 공개 키를 프로젝트 레포지토리의 Setting &gt; Deploy keys에 등록한다. 이제 Jenkins과 Github을 연동시켰기에, Jenkins에 코드를 가져올 수 있게 되었다. 다음으로는 push했을 때 Jenkins가 push 이벤트를 받을 수 있도록 설정 해보자.마찬가지로 레포지토리의 setting &gt; webhooks 에서 빨간색 네모박스에 Jenkins ip 주소를 입력하고 나머지는 그대로 입력한다. Github에서의 설정은 끝났고 Jenkins 프로젝트에서 다음을 체크함으로써 이벤트 설정은 끝이 났다.이젠 push만 하면 Jenkins 해당 프로젝트에서 빌드가 시작됨을 볼 수 있다. 빌드 기록을 통해 소스 코드가 빌드 중인지 빌드 완료 되었는지를 확인할 수 있다. 이것으로 Jenkins로 CI 환경 구축은 끝이 났다. 2편에서는 CD 환경 구축과 무중단 배포를 구축해보겠다.","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://doyuni.github.io/categories/DevOps/"},{"name":"CI/CD","slug":"DevOps/CI-CD","permalink":"https://doyuni.github.io/categories/DevOps/CI-CD/"}],"tags":[{"name":"NAVER CLOUD","slug":"NAVER-CLOUD","permalink":"https://doyuni.github.io/tags/NAVER-CLOUD/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://doyuni.github.io/tags/Jenkins/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://doyuni.github.io/tags/CI-CD/"}]}]}