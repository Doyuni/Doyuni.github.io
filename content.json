{"meta":{"title":"JUST WRITE IT.","subtitle":"","description":"","author":"Geum Doyun","url":"https://doyuni.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-01-20T12:25:42.000Z","updated":"2020-01-21T13:39:51.944Z","comments":true,"path":"categories/index.html","permalink":"https://doyuni.github.io/categories/index.html","excerpt":"","text":"DevOps CI/CD"},{"title":"tags","date":"2020-01-20T12:25:32.000Z","updated":"2020-01-21T13:38:14.788Z","comments":true,"path":"tags/index.html","permalink":"https://doyuni.github.io/tags/index.html","excerpt":"","text":"CI/CD Docker Jenkins NAVER CLOUD NGINX"}],"posts":[{"title":"Jenkins, NAVER Cloud Platform, Docker로 CI/CD 무중단 배포 환경 구축하기 - 2편","slug":"cicd-2","date":"2020-01-21T13:06:11.000Z","updated":"2020-01-23T14:18:24.057Z","comments":true,"path":"2020/01/21/cicd-2/","link":"","permalink":"https://doyuni.github.io/2020/01/21/cicd-2/","excerpt":"","text":"2편에서는 CD에서 무중단 배포까지 구축한다. (1편에서는 Github Push 후에 Jenkins가 자동으로 빌드되도록 설정하였다.) 2. Jenkins로 Node.js기반 프로젝트 배포 설정하기배포를 위해 scp를 사용하여 Jenkins에 있는 프로젝트 코드를 NAVER Cloud 서버에 복사해야 한다.Node.js 기반의 프로젝트는 Tomcat과 같은 WAS(웹 서버+웹 컨테이너)가 존재하지 않아 ssh로 접속, scp로 파일을 주고 받는 작업으로 비교적 간단히 배포할 수 있다. 2-1. NAVER Cloud 서버에도 ssh 키를 생성한다.1ssh-keygen -t rsa 키가 생성되면 authorized_keys, id_rsa, id_rsa.pub, known_hosts 가 생성되어 있는 것을 볼 수 있다. scp로 파일을 주고 받는다 하였는데 이때 복사 받을 서버의 접속 비밀번호를 알아야 한다. 그렇게되면 복사할 때마다 매번 비밀번호를 요구하여 자동화 배포는 불가능하게 된다. 이를 해결하기 위해 위의 4개의 키를 이용한다.Jenkins에서는 NAVER Cloud 서버를 호스트로, NAVER Cloud 서버에서는 Jenkins 서버의 공개 키를 허가받은 키로 등록한다. 이러면 비밀번호를 요구하지 않고 자동화 배포가 가능하다. 2-2. Jenkins 서버에서 NAVER Cloud 서버를 known_hosts로 등록한다.1ssh-keyscan -H (NAVER CLOUD 서버)ip &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts 2-3. Jenkins에서 생성한 키 중에 공개 키(id_rsa.pub)를 NAVER Cloud 서버에서 생성한 authorized_keys에 입력한다. Jenkins 서버의 공개 키 NAVER Cloud 서버의 authorized_keys 1vi ~&#x2F;.ssh&#x2F;authorized_keys scp로 테스트하기접속 비밀번호를 요구하지 않았다면 성공이다. Jenkins 서버에서 test.txt 파일을 생성한다. Jenkins 서버에서 scp를 사용해 test.txt를 NAVER Cloud 서버의 /root/test 폴더에 복사한다.비밀번호를 요구하지 않으면 성공. NAVER Cloud 서버에서 복사된 파일을 확인한다. 3. NAVER Cloud 서버에 Docker, NGINX 설정하기이제 프로젝트가 배포되는 NAVER Cloud 서버에서 설정해야 할 부분이다.(*Docker 및 NGINX 설치는 생략한다.) 3-1. Dockerfile 작성.ssh로 서버에 접속하고 Dockerfile을 다음과 같이 작성한다. 123456789101112131415FROM 이미지 환경 MAINTAINER 개발자 VOLUME 호스트와 공유할 폴더 RUN mkdir -p /app WORKDIR /app COPY ./프로젝트 소스코드 폴더/ /app RUN npm install CMD npm start FROM: Node 이미지(Node version 명시) MAINTAINER: 개발자(팀명) VOLUME: host와 컨테이너가 공유할 폴더 경로 RUN: 해당 명령어 실행( 위에선 app 폴더 생성 ) WORKDIR: 작업 디렉토리 설정(위에서 만든 app 폴더로 설정) COPY: NAVER Cloud 서버에 있는 파일을 컨테이너 폴더에 복사서버에 있는 파일은 Dockerfile이 존재하는 현재 경로 내에 존재하는 것만 가능하다.(즉, 절대 경로는 Dockerfile이 있는 경로 이내가 아니라면 불가능) 그 다음은 패키지 파일들을 설치하고 서버를 실행한다. docker image build -t 도커이미지이름 .를 입력하여 이미지를 빌드한다. 3-2. Docker-compose 작성하기docker-compose(컨테이너 관리)를 설치하여 편하게 컨테이너를 설정한다.여기서 blue-green 배포 방식이 사용되는데, 이는 무중단 배포 구축을 위함이다. Dockerfile이 있는 곳에 docker-compose.blue.yml을 다음과 같이 작성한다. 123456789version: '2'services: linking-server: image: 빌드한 도커 이미지 volumes: - ./deploy:/deploy/linking ports: - \"NAVER Cloud 서버 포트:컨테이너 포트\" image: 아까 빌드한 이미지 이름을 작성한다. volumes: host 폴더와 컨테이너 폴더를 설정하여 공유한다.(심볼릭 링크와 비슷한 개념이라고 한다.) ports: host 포트와 컨테이너 포트 순으로 작성하여 포트 포워딩 설정을 한다. 같은 곳에 docker-compose.green.yml을 다음과 같이 작성한다.host 포트만 다르다. 3-3. deploy script 작성하기. 같은 곳에 deploy.sh를 다음과 같이 작성한다. 123456789101112131415161718192021#!/bin/bash DOCKER_APP_NAME=linking-server EXIST_BLUE=$(docker-compose -p $&#123;DOCKER_APP_NAME&#125;-blue -f docker-compose.blue.yml ps | grep Up) if [ -z \"$EXIST_BLUE\" ]; then echo \"blue up\" docker-compose -p $&#123;DOCKER_APP_NAME&#125;-blue -f docker-compose.blue.yml up -d sleep 10 docker-compose -p $&#123;DOCKER_APP_NAME&#125;-green -f docker-compose.green.yml downelse echo \"green up\" docker-compose -p $&#123;DOCKER_APP_NAME&#125;-green -f docker-compose.green.yml up -d sleep 10 docker-compose -p $&#123;DOCKER_APP_NAME&#125;-blue -f docker-compose.blue.yml downfi 지금까지 잘 따라 했다면 아래와 비슷한 디렉토리 구조를 볼 수 있을 것이다. 컨테이너 생성하기 docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml up -d를 입력하여 blue 컨테이너를 먼저 생성해준다. docker ps -a로 컨테이너가 잘 실행되고 있는지 확인할 수 있다. 3-4. NGINX 설정하기.다음은 NGINX로 blue, green의 로드밸런싱을 설정해 주어야 한다. vi /etc/nginx/sites-available/linking-server를 입력하여 다음과 같이 작성한다.linking-server는 필자가 정한 이름이다. 12345678910111213# Load Balancingupstream linking-server &#123; least_conn; server 127.0.0.1:1025 weight=5 max_fails=3 fail_timeout=10s; server 127.0.0.1:1026 weight=10 max_fails=3 fail_timeout=10s;&#125;server &#123; listen 1024; server_name NAVER Cloud 서버 아이피; location / &#123; proxy_pass http://linking-server; &#125;&#125; 그런 다음 아래 명령어로 이 파일을 /etc/nginx/sites-enabled 디렉터리에 링크해준다. sudo ln -fs /etc/nginx/sites-available/linking-server /etc/nginx/sites-enabled/ 마지막으로 sudo nginx -t 명령어로 문법 이상 유무를 확인하고 이상이 없을 경우, systemctl stop nginx 명령어로 NGINX를 종료한 후에 systemctl start nginx 로 다시 시작한다. 3-5. NAVER Cloud Platform ACG 설정하기.여기서 마지막으로 한 가지 해야할 것은 ACG 설정이다. ACG 설정하기 NAVER Cloud Platform 콘솔에서 1024포트를 열어준다. 위에서 blue, green 모두 다른 포트지만 NGINX를 통해 1024 포트로 로드 밸런싱 되기에 사용자는 이를 통해 접근할 수 있다.(보통 백엔드와 프론트엔드를 분리하면서 프로젝트를 진행하고 있다면 프론트엔드는 80포트를 사용하는게 좋다. 80이 기본 포트라 생략 가능하므로) 이것으로 NAVER Cloud 서버에서의 설정은 끝났다. 4. 마지막 작업이제 마지막 Jenkins에서 빌드할 때 설정을 해주어야 위에서 설정한 무중단 배포가 자동화된다. Jenkins 프로젝트 관리에서 “Execute managed script”를 클릭한다.다만, 아직 작성한 스크립트가 없기에 Jenkins 관리 &gt; Managed files &gt; Add a new Config를 통해 스크립트를 작성한다. 다음과 같이 작성한다. 123456789101112131415#!/bin/shssh -T root@서버 아이피 &lt;&lt;EOF rm -rf /home/docker-image/deploy/* exitEOF scp -r /var/lib/jenkins/jobs/LinkingCI/workspace/* root@서버 아이피:/home/docker-image/deploy/ #!/bin/shssh -T root@서버 아이피 &lt;&lt;EOF cd /home/docker-image docker image build -t linking-server-docker-image . ./deploy.sh exitEOF 1) Jenkins가 빌드 동안 해당 서버에 접속하여 원래 있던 애플리케이션 코드를 삭제한다. 2) 빌드된 파일을 해당 서버에 복사한다. 3) 해당 서버에 다시 접속하여 새로 복사된 파일을 토대로 도커 이미지를 빌드한다. 4) 배포 스크립트를 실행한다. 위와 같은 과정이 일어나고 지금까지 설정한 것들이 모두 자동화되어 무중단 배포까지 진행된다. 이를 이제 Jenkins 프로젝트 관리에서 실행하도록 한다. 5. 빌드 상태 표시, Slack 알림추가로 프로젝트에서 보이는 Embeddable Build Status를 클릭하면 마크다운 형식으로 Github 레포지토리에 빌드 상태바를 보이게 할 수 있다. 마지막으로 팀원들이 빌드 상태(시작, 실패, 성공)을 알고 싶을 때 Slack을 통해 알림을 받도록 할 수도 있다.1편에서 이미 관련 플러그인을 설치하였기에 바로 설정이 가능하다. Slack에 채널을 만들었다면 Apps에서 Jenkins를 검색 후 클릭한다. 알림을 받을 채널을 설정하면 Jenkins에서 어떻게 설정해야 하는지 친절하게 나온다. 설정을 하고 나면 Jenkins 프로젝트에서 빌드 후 조치에 알림 받을 내역을 설정할 수가 있게 된다. 빌드 시작부터 끝까지 알림이 날라온다. 이것으로 CI/CD 무중단 배포 환경 구축을 마친다. -끝-","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://doyuni.github.io/categories/DevOps/"},{"name":"CI/CD","slug":"DevOps/CI-CD","permalink":"https://doyuni.github.io/categories/DevOps/CI-CD/"}],"tags":[{"name":"NAVER CLOUD","slug":"NAVER-CLOUD","permalink":"https://doyuni.github.io/tags/NAVER-CLOUD/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://doyuni.github.io/tags/Jenkins/"},{"name":"Docker","slug":"Docker","permalink":"https://doyuni.github.io/tags/Docker/"},{"name":"NGINX","slug":"NGINX","permalink":"https://doyuni.github.io/tags/NGINX/"}]},{"title":"Jenkins, NAVER Cloud Platform, Docker로 CI/CD 무중단 배포 환경 구축하기 - 1편","slug":"cicd-1","date":"2020-01-21T13:01:34.000Z","updated":"2020-01-23T13:34:45.801Z","comments":true,"path":"2020/01/21/cicd-1/","link":"","permalink":"https://doyuni.github.io/2020/01/21/cicd-1/","excerpt":"","text":"이번 내용은 필자가 프로젝트를 진행하면서 처음으로 DevOps를 맡으면서 꼭 공유 하겠다고 마음 먹고 작성하였다. CI/CD란? CI(Continuous Integration)지속적인 통합을 의미한다. 이는 개발자를 위한 자동화 프로세스 중 하나이며 어플리케이션을 변경할 때 자동으로 빌드 및 테스트되어 Github 공유 레포지토리에 병합된다. 그렇기에 협업 시 발생할 수 있는 충돌문제를 해결할 수 있다. CD(Continuous Deployment)지속적인 배포를 의미한다. 어플리케이션 변경 사항이 반영된 공유 레포지토리에서 사용자가 사용 가능한 환경까지 자동으로 배포하는 것을 말한다. 이를 통해 어플리케이션을 원활히 그리고 더 빠르게 제공하므로써 사용자의 피드백을 빠르게 반영할 수 있다. 아래는 필자가 맡은 프로젝트의 전체 시스템 구조이면서 동시에, CI/CD 과정을 볼 수 있다. 전체 시스템 구조 대부분 Travis CI, AWS, Docker, NGINX를 사용하여 CI/CD 무중단 배포를 구축한다는 점에서 비교하여 보아도 좋을 것이다. 선택의 순간들AWS가 아닌 NAVER CLOUD 선택AWS와 NAVER Cloud Platform을 사용해 보면서 느낀 것은 확실히 AWS의 기능이 훨씬 많고 유용하다.그럼에도 NAVER Cloud Platform을 사용한 것은 40만 크레딧(지원 받았다.)이 제일 컸다.AWS에는 무중단 배포까지 지원하는 서비스인 Blue-Green Deployment가 있는데 반해 NAVER Cloud는 없다…그럼 굳이 왜 AWS를 선택하지 않았냐고 할 수 있는데 내가 직접 설정해서 구축하고 싶었기 때문이다. (사서 고생한다는 얘기) Travis가 아닌 Jenkins 선택Travis reference만 보아도 AWS랑 얼마나 죽이 잘 맞는지를 알 수 있다. (AWS말고도 Google Cloud, Azure도 지원한다.) 이미 NAVER Cloud를 선택한 이상 Travis는 더 어려운 방법으로 가는 길이라 생각했다. 오히려 설정할 수 있는 범위가 넓은 Jenkins를 택하는 것이 쉽다고 판단하였다. 처음에 AWS와 Travis로 자동화 배포 환경 구축을 연습했었는데, 개인적인 입장으로는 Jenkins가 좀 더 쉬운 것 같다. 40만 크레딧의 위엄으로 Jenkins를 도커가 아닌 Naver Cloud로 서버를 따로 구축했다. 지금 생각해보면 자원 낭비인 셈이지만 안정성 측면에서는 따로 서버를 두는 것이 좋다. 환경 구축하기NAVER Cloud 사용 설명서는 무척 잘 되어 있고 AWS의 EC2나 S3와 같은 개념과 똑같기에 같은 방식으로 설정하면 된다. NAVER Cloud의 Server = AWS의 EC2 NAVER Cloud의 Object Storage = AWS의 S3 아래와 같이 SourcePipeline 서비스를 이용하면 Github에서 push한 것을 자동으로 빌드하고 배포할 수 있는데, 아래 사진 우측 상단에 보이는 파이프라인 실행하기를 매번 클릭해줘야 한다…내가 원한건 push만 해도 자동화 빌드 및 배포이다. 결국 이걸 접고 Jenkins와 NAVER Cloud의 Server만 사용하기로 결정했다. 1. Jenkins 설정하기Docker로 Jenkins 서버를 운영해도 되지만 NAVER Cloud에서 다음과 같이 지원하기에 사용하였다.다만 수동으로 최신 업데이트 하는 것을 권장한다. 1-1. Jenkins 보안 설정Jenkins는 기본적으로 보안 설정이 되어있지 않다.Jenkins 관리 &gt; Configure Global Security에서 설정할 수 있다. 처음에 사용자의 가입을 허용하여 admin 계정을 생성한다. 팀원과 함께 작업한다면 팀원 각각 계정 생성하도록 둔다. 계정 생성을 끝냈으면 ‘Matrix-based security’를 적절히 설정한다. (없다면 Matrix Authorization Strategy Plugin를 설치하자.)필자는 익명에게 읽기 권한 중 Job(Jenkins 작업 단위) 부분만 볼 수 있게 하였다. 이는 나중에 설정할 Github의 build status를 보여주기 위함이다.그리고 혼자 환경 구축을 담당 하였기에 팀원 계정 역시 익명과 같은 권한을 주었다. 1-2. 플러그인 설치하기Jenkins 관리 &gt; 플러그인 관리 Github plugin: Jenkins와 Github 통합 Global Slack Notifier Plugin: Slack 연동(Job 알림 설정) Publish Over SSH: ssh로 빌드 파일 보내기 Embeddable Build Status Plugin: Github 레포지토리에 빌드 상태바 생성 Managed Scripts: Node.js 기반의 서버를 배포하기 위한 스크립트 1-3. Jenkins Global 설정하기Jenkins 관리 &gt; 시스템 설정 &gt; GitHub Servers에서 다음과 같이 설정한다. Credentials 설정을 위해 자신의 Github &gt; Settings &gt; Developer settings &gt; Personal access tokens에서 다음과 같이 토큰을 생성한다. 생성 후 화면에 보이는 secret 문자열을 아래의 Secret에 입력한다. 1-4. 프로젝트 생성 및 설정하기새로운 Item을 클릭하고 프로젝트 이름을 입력, Freestyle을 누른다. 다음과 같이 프로젝트 url을 입력하고 Credentials를 설정한다. 이 작업은 Github을 연동하는 것인데, ID와 PW로 연동하면 보안에 취약하기에 ssh키로 연동하였다. ssh 키 생성하기 ssh로 Jenkins 서버에 원격 접속하여 다음을 입력한다.1ssh-keygen -t rsa -f id_rsa id_rsa, id_rsa.pub 를 포함해 총 4개의 키가 생성된다. 아래 Add 표시를 눌러 cat ~/.ssh/id_rsa 입력 후 나오는 private key를 넣어준다 BEGIN ~부터 모두 복사하여 입력한다. Github에 공개 키 등록하기. cat ~/.ssh/id_rsa.pub 를 입력하면 나오는 공개 키를 프로젝트 레포지토리의 Setting &gt; Deploy keys에 등록한다. 이제 Jenkins과 Github을 연동시켰기에, Jenkins에 코드를 가져올 수 있게 되었다. 다음으로는 push했을 때 Jenkins가 push 이벤트를 받을 수 있도록 설정 해보자.마찬가지로 레포지토리의 setting &gt; webhooks 에서 빨간색 네모박스에 Jenkins ip 주소를 입력하고 나머지는 그대로 입력한다. Github에서의 설정은 끝났고 Jenkins 프로젝트에서 다음을 체크함으로써 이벤트 설정은 끝이 났다.이젠 push만 하면 Jenkins 해당 프로젝트에서 빌드가 시작됨을 볼 수 있다. 빌드 기록을 통해 소스 코드가 빌드 중인지 빌드 완료 되었는지를 확인할 수 있다. 이것으로 Jenkins로 CI 환경 구축은 끝이 났다. 2편에서는 CD 환경 구축과 무중단 배포를 구축해보겠다.","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://doyuni.github.io/categories/DevOps/"},{"name":"CI/CD","slug":"DevOps/CI-CD","permalink":"https://doyuni.github.io/categories/DevOps/CI-CD/"}],"tags":[{"name":"NAVER CLOUD","slug":"NAVER-CLOUD","permalink":"https://doyuni.github.io/tags/NAVER-CLOUD/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://doyuni.github.io/tags/Jenkins/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://doyuni.github.io/tags/CI-CD/"}]}]}